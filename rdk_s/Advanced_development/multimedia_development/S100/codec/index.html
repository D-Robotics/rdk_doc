<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper plugin-docs plugin-id-docs_s docs-version-current docs-doc-page docs-doc-id-Advanced_development/multimedia_development/S100/codec" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.8.1">
<title data-rh="true">编解码 | RDK DOC</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://developer.d-robotics.cc/rdk_doc/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://developer.d-robotics.cc/rdk_doc/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://developer.d-robotics.cc/rdk_doc/rdk_s/Advanced_development/multimedia_development/S100/codec"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" property="og:locale:alternate" content="en"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-docs_s-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-docs_s-current"><meta data-rh="true" property="og:title" content="编解码 | RDK DOC"><meta data-rh="true" name="description" content="系统概述"><meta data-rh="true" property="og:description" content="系统概述"><link data-rh="true" rel="icon" href="/rdk_doc/img/logo.png"><link data-rh="true" rel="canonical" href="https://developer.d-robotics.cc/rdk_doc/rdk_s/Advanced_development/multimedia_development/S100/codec"><link data-rh="true" rel="alternate" href="https://developer.d-robotics.cc/rdk_doc/rdk_s/Advanced_development/multimedia_development/S100/codec" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://developer.d-robotics.cc/rdk_doc/en/rdk_s/Advanced_development/multimedia_development/S100/codec" hreflang="en"><link data-rh="true" rel="alternate" href="https://developer.d-robotics.cc/rdk_doc/rdk_s/Advanced_development/multimedia_development/S100/codec" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"7. 进阶开发","item":"https://developer.d-robotics.cc/rdk_doc/rdk_s/Advanced_development"},{"@type":"ListItem","position":2,"name":"7.3 多媒体开发指南","item":"https://developer.d-robotics.cc/rdk_doc/rdk_s/03_multimedia_development"},{"@type":"ListItem","position":3,"name":"7.3.1 S100 多媒体开发指南","item":"https://developer.d-robotics.cc/rdk_doc/rdk_s/category/731-s100-多媒体开发指南"},{"@type":"ListItem","position":4,"name":"编解码","item":"https://developer.d-robotics.cc/rdk_doc/rdk_s/Advanced_development/multimedia_development/S100/codec"}]}</script><script src="https://hm.baidu.com/hm.js?24dd63cad43b63889ea6bede5fd1ab9e" async></script><link rel="stylesheet" href="/rdk_doc/assets/css/styles.0fbd7d27.css">
<script src="/rdk_doc/assets/js/runtime~main.5bf9437e.js" defer="defer"></script>
<script src="/rdk_doc/assets/js/main.b2344c79.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t="light";var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",e||t),document.documentElement.setAttribute("data-theme-choice",e||t)}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a href="https://d-robotics.cc/" target="_blank" rel="noopener noreferrer" class="navbar__brand"><div class="navbar__logo"><img src="/rdk_doc/img/logo.png" alt="地瓜机器人社区 logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/rdk_doc/img/logo.png" alt="地瓜机器人社区 logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">D-Robotics</b></a><a class="navbar__item navbar__link" href="/rdk_doc/RDK">RDK X3 / X5</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/rdk_doc/rdk_s/RDK">RDK S100</a><a href="https://developer.d-robotics.cc/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Community<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://github.com/D-Robotics" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link"><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_nlXk"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg>CN</a><ul class="dropdown__menu"><li><a href="/rdk_doc/rdk_s/Advanced_development/multimedia_development/S100/codec" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="zh-Hans">CN</a></li><li><a href="/rdk_doc/en/rdk_s/Advanced_development/multimedia_development/S100/codec" target="_self" rel="noopener noreferrer" class="dropdown__link" lang="en">EN</a></li></ul></div><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="切换浅色/暗黑模式（当前为system mode）"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><div class="navbar__search searchBarContainer_NW3z" dir="ltr"><input placeholder="搜索" aria-label="Search" class="navbar__search-input searchInput_YFbd" value=""><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper"><div class="docsWrapper_hBAB"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/rdk_doc/rdk_s/RDK">D-Robotics RDK 套件</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/rdk_doc/rdk_s/Quick_start">1. 快速开始</a><button aria-label="展开侧边栏分类 &#x27;1. 快速开始&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/rdk_doc/rdk_s/System_configuration">2. 系统配置</a><button aria-label="展开侧边栏分类 &#x27;2. 系统配置&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/rdk_doc/rdk_s/Basic_Application">3. 基础应用开发</a><button aria-label="展开侧边栏分类 &#x27;3. 基础应用开发&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/rdk_doc/rdk_s/Basic_Development">4. 算法应用开发</a><button aria-label="展开侧边栏分类 &#x27;4. 算法应用开发&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/rdk_doc/rdk_s/Robot_development">5. 机器人应用开发</a><button aria-label="展开侧边栏分类 &#x27;5. 机器人应用开发&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/rdk_doc/rdk_s/Application_case">6. 应用开发指南</a><button aria-label="展开侧边栏分类 &#x27;6. 应用开发指南&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/rdk_doc/rdk_s/Advanced_development">7. 进阶开发</a><button aria-label="折叠侧边栏分类 &#x27;7. 进阶开发&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/rdk_doc/rdk_s/hardware_development">7.1 硬件开发指南</a><button aria-label="展开侧边栏分类 &#x27;7.1 硬件开发指南&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/rdk_doc/rdk_s/linux_development">7.2. Linux开发指南</a><button aria-label="展开侧边栏分类 &#x27;7.2. Linux开发指南&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" tabindex="0" href="/rdk_doc/rdk_s/03_multimedia_development">7.3 多媒体开发指南</a><button aria-label="折叠侧边栏分类 &#x27;7.3 多媒体开发指南&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" tabindex="0" href="/rdk_doc/rdk_s/category/731-s100-多媒体开发指南">7.3.1 S100 多媒体开发指南</a><button aria-label="折叠侧边栏分类 &#x27;7.3.1 S100 多媒体开发指南&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/rdk_doc/rdk_s/Advanced_development/multimedia_development/S100/camsys">Camsys子系统</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/rdk_doc/rdk_s/Advanced_development/multimedia_development/S100/camera_bringup">Camera点亮</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/rdk_doc/rdk_s/Advanced_development/multimedia_development/S100/codec">编解码</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/rdk_doc/rdk_s/Advanced_development/multimedia_development/S100/display">显示子系统</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/rdk_doc/rdk_s/Advanced_development/multimedia_development/S100/camerasync">多路Camera及与Lidar同步</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/rdk_doc/rdk_s/02_multimedia_application">7.3.2 多媒体应用开发 </a><button aria-label="展开侧边栏分类 &#x27;7.3.2 多媒体应用开发 &#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/rdk_doc/rdk_s/04_toolchain_development">7.4 算法工具链开发指南</a><button aria-label="展开侧边栏分类 &#x27;7.4 算法工具链开发指南&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/rdk_doc/rdk_s/05_MCU_development">7.5 MCU开发指南</a><button aria-label="展开侧边栏分类 &#x27;7.5 MCU开发指南&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rdk_doc/rdk_s/Advanced_development/rdk_gen">7.6 RDK S100构建系统开发指南</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/rdk_doc/rdk_s/FAQ">8. 常见问题</a><button aria-label="展开侧边栏分类 &#x27;8. 常见问题&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/rdk_doc/rdk_s/Appendix">9. 附录</a><button aria-label="展开侧边栏分类 &#x27;9. 附录&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/rdk_doc/rdk_s/Release_Note/roadmap">10. 版本发布</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/rdk_doc/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><a class="breadcrumbs__link" href="/rdk_doc/rdk_s/Advanced_development"><span>7. 进阶开发</span></a></li><li class="breadcrumbs__item"><a class="breadcrumbs__link" href="/rdk_doc/rdk_s/03_multimedia_development"><span>7.3 多媒体开发指南</span></a></li><li class="breadcrumbs__item"><a class="breadcrumbs__link" href="/rdk_doc/rdk_s/category/731-s100-多媒体开发指南"><span>7.3.1 S100 多媒体开发指南</span></a></li><li class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link">编解码</span></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>编解码</h1></header>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="系统概述">系统概述<a href="#系统概述" class="hash-link" aria-label="系统概述的直接链接" title="系统概述的直接链接">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="概述">概述<a href="#概述" class="hash-link" aria-label="概述的直接链接" title="概述的直接链接">​</a></h3>
<p>Codec（Coder-Decoder）是指编解码器，用于压缩或解压缩视频、图像、音频等媒体数据；S100
Soc中存在两种硬件编解码单元，分别是VPU（Video process unit）和JPU（Jpeg process
unit），可提供4K@90fps的视频编解码能力和4K@90fps的图像编解码能力。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="jpu硬件特性">JPU硬件特性<a href="#jpu硬件特性" class="hash-link" aria-label="JPU硬件特性的直接链接" title="JPU硬件特性的直接链接">​</a></h4>
<table><thead><tr><th><strong>HW Feature</strong></th><th><strong>Feature Indicator</strong></th></tr></thead><tbody><tr><td>HW number</td><td>1</td></tr><tr><td>maximum input</td><td>8192x8192</td></tr><tr><td>minimum input</td><td>32x32</td></tr><tr><td>performance</td><td>4K@90fps</td></tr><tr><td>max instance</td><td>64</td></tr><tr><td>input image format</td><td>4:0:0, 4:2:0, 4:2:2, 4:4:0, and 4:4:4 color format</td></tr><tr><td>output image format</td><td>4:0:0, 4:2:0, 4:2:2, 4:4:0, and 4:4:4 color format</td></tr><tr><td>input crop</td><td>Supports</td></tr><tr><td>bitrate control</td><td>FIXQP(MJPEG)</td></tr><tr><td>rotation</td><td>90, 180, 270</td></tr><tr><td>mirror</td><td>Vertical, Horizontal, Vertical+Horizontal</td></tr><tr><td>quantization table</td><td>Supports Custom Settings</td></tr><tr><td>huffman table</td><td>Supports Custom Settings</td></tr></tbody></table>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="vpu硬件特性">VPU硬件特性<a href="#vpu硬件特性" class="hash-link" aria-label="VPU硬件特性的直接链接" title="VPU硬件特性的直接链接">​</a></h4>
<table><thead><tr><th><strong>HW Feature</strong></th><th><strong>Feature Indicator</strong></th></tr></thead><tbody><tr><td>HW number</td><td>1</td></tr><tr><td>maximum input</td><td>8192x4096</td></tr><tr><td>minimum input</td><td>256x128</td></tr><tr><td>input alignment required</td><td>width 32, height 8</td></tr><tr><td>performance</td><td>4K@90fps</td></tr><tr><td>max instance</td><td>32</td></tr><tr><td>input image format</td><td>4:2:0, 4:2:2 color format</td></tr><tr><td>output image format</td><td>4:2:0, 4:2:2 color format</td></tr><tr><td>input crop</td><td>Supports</td></tr><tr><td>bitrate control</td><td>CBR, VBR, AVBR, FIXQP, QPMAP</td></tr><tr><td>rotation</td><td>90, 180, 270</td></tr><tr><td>mirror</td><td>Vertical, Horizontal, Vertical+Horizontal</td></tr><tr><td>long-term reference prediction</td><td>Supports Custom Settings</td></tr><tr><td>intra refresh</td><td>Supports</td></tr><tr><td>deblocking filter</td><td>Supports</td></tr><tr><td>request IDR</td><td>Supports</td></tr><tr><td>ROI mode</td><td>mode1: Users can set multiple zones’(up to 64) qp value(0-51), should not work with CBR or AVBR mode mode2: Users can set multiple zones’(up to 64) important level(0-8), should work with CBR or AVBR mode</td></tr><tr><td>GOP mode</td><td>0: Custom GOP 1 : I-I-I-I,..I (all intra, gop_size=1) 2 : I-P-P-P,… P (consecutive P, gop_size=1) 3 : I-B-B-B,…B (consecutive B, gop_size=1) 4 : I-B-P-B-P,… (gop_size=2) 5 : I-B-B-B-P,… (gop_size=4) 6 : I-P-P-P-P,… (consecutive P, gop_size=4) 7 : I-B-B-B-B,… (consecutive B, gop_size=4) 8 : I-B-B-B-B-B-B-B-B,… (random access, gop_size=8) 9 : I-P-P-P,… P (consecutive P, gop_size = 1, with single reference)</td></tr></tbody></table>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="软件功能">软件功能<a href="#软件功能" class="hash-link" aria-label="软件功能的直接链接" title="软件功能的直接链接">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="整体框架">整体框架<a href="#整体框架" class="hash-link" aria-label="整体框架的直接链接" title="整体框架的直接链接">​</a></h4>
<p>MediaCodec子系统会提供音视频和图像的编解码组件，原始流封装和视频录像等功能。该系统主要会封装底层codec硬件资源和软件编解码库，为上层提供编解码能力。开发者可以基于提供的编解码接口实现H265和H264视频的编解码功能，也可以使用JPEG编码功能将摄像头数据存成JPEG图片，还可以使用视频录像功能实现摄像头数据的录制。</p>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/2f8364ee5efbb8cb14136e0dc942248e.png" alt="" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="码率控制模式">码率控制模式<a href="#码率控制模式" class="hash-link" aria-label="码率控制模式的直接链接" title="码率控制模式的直接链接">​</a></h4>
<p>MediaCodec支持对H264/H265和MJPEG协议的码率控制，分别支持H264/H265编码通道的CBR、VBR、AVBR、FixQp和QpMap五种码率控制方式，以及支持MJPGE编码通道的FixQp码率控制方式。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="cbr说明">CBR说明<a href="#cbr说明" class="hash-link" aria-label="CBR说明的直接链接" title="CBR说明的直接链接">​</a></h5>
<p>CBR表示恒定码率，能够保证整体的编码码率稳定。下面是CBR模式下各个参数含义：</p>
<table><thead><tr><th><strong>数据项</strong></th><th><strong>描述</strong></th><th><strong>取值范围</strong></th><th><strong>默认值</strong></th></tr></thead><tbody><tr><td>intra_period</td><td>I帧间隔</td><td>[0,2047]</td><td>28</td></tr><tr><td>intra_qp</td><td>I帧的QP值</td><td>[0,51]</td><td>0</td></tr><tr><td>bit_rate</td><td>目标平均比特率，单位是kbps</td><td>[0,700000]</td><td>0</td></tr><tr><td>frame_rate</td><td>目标帧率，单位是fps</td><td>[1,240]</td><td>30</td></tr><tr><td>initial_rc_qp</td><td>指定码率控制时的初始QP值，当该值不在[0,51]范围内,编码器内部会决定初始值</td><td>[0,63]</td><td>63</td></tr><tr><td>vbv_buffer_size</td><td>指定VBV Buffer的大小，单位是ms；实际的VBV buffer的空间大小为bit_rate*vbv_buffer_size/1000(kb)，该buffer的大小会影响编码图像质量和码率控制精度。当该buffer比较小时，码率控制精确度高，但图像编码质量较差；当该buffer比较大时，图像编码质量高，但是码率波动大。</td><td>[10,3000]</td><td>10</td></tr><tr><td>ctu_level_rc_enalbe</td><td>H264/H265的码率控制可以工作在CTU级别的控制，该模式可以达到更高精度的码率控制，但是会损失编码图像质量，该模式不可以和ROI编码一起工作，当使能ROI编码时，该功能自动失效。</td><td>[0,1]</td><td>0</td></tr><tr><td>min_qp_I</td><td>I帧的最小QP值</td><td>[0,51]</td><td>8</td></tr><tr><td>max_qp_I</td><td>I帧的最大QP值</td><td>[0,51]</td><td>51</td></tr><tr><td>min_qp_P</td><td>P帧的最小QP值</td><td>[0,51]</td><td>8</td></tr><tr><td>max_qp_P</td><td>P帧的最大QP值</td><td>[0,51]</td><td>51</td></tr><tr><td>min_qp_B</td><td>B帧的最小QP值</td><td>[0,51]</td><td>8</td></tr><tr><td>max_qp_B</td><td>B帧的最大QP值</td><td>[0,51]</td><td>51</td></tr><tr><td>hvs_qp_enable</td><td>H264/H265的码率控制可以工作在subCTU级别的控制，该模式会调整子宏块的QP值，进而提高主观图像质量。</td><td>[0,1]</td><td>1</td></tr><tr><td>hvs_qp_scale</td><td>当hvs_qp_enable使能后有效，该值表示QP缩放因子。</td><td>[0,4]</td><td>2</td></tr><tr><td>max_delta_qp</td><td>当hvs_qp_enable使能后有效，指定HVS qp值的最大偏差范围。</td><td>[0,51]</td><td>10</td></tr><tr><td>qp_map_enable</td><td>使能ROI编码时的QP map</td><td>[0,1]</td><td>0</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="vbr说明">VBR说明<a href="#vbr说明" class="hash-link" aria-label="VBR说明的直接链接" title="VBR说明的直接链接">​</a></h5>
<p>VBR表示可变码率，简单场景分配比较大的qp，压缩率小，质量高。复杂场景分配较小qp，可以保证编码图像的质量稳定。下面是VBR模式下各个参数含义：</p>
<table><thead><tr><th><strong>数据项</strong></th><th><strong>描述</strong></th><th><strong>取值范围</strong></th><th><strong>默认值</strong></th></tr></thead><tbody><tr><td>intra_period</td><td>I帧间隔</td><td>[0,2047]</td><td>28</td></tr><tr><td>intra_qp</td><td>I帧的QP值</td><td>[0,51]</td><td>0</td></tr><tr><td>frame_rate</td><td>目标帧率，单位是fps</td><td>[1,240]</td><td>0</td></tr><tr><td>qp_map_enable</td><td>使能ROI编码时的QP map</td><td>0,1</td><td>0</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="avbr说明">AVBR说明<a href="#avbr说明" class="hash-link" aria-label="AVBR说明的直接链接" title="AVBR说明的直接链接">​</a></h5>
<p>ABR表示恒定平均目标码率，简单场景分配较低码率，复杂场景分配足够码率，使得有限的码率能够在不同场景下合理分配，这类似VBR。同时一定时间内，平均码率又接近设置的目标码率，这样可以控制输出文件的大小，这又类似CBR。可以认为是CBR和VBR的折中方案，产生码率和图像质量相对稳定的码流。下面是AVBR模式下各个参数含义：</p>
<table><thead><tr><th><strong>数据项</strong></th><th><strong>描述</strong></th><th><strong>取值范围</strong></th><th><strong>默认值</strong></th></tr></thead><tbody><tr><td>intra_period</td><td>I帧间隔</td><td>[0,2047]</td><td>28</td></tr><tr><td>intra_qp</td><td>I帧的QP值</td><td>[0,51]</td><td>0</td></tr><tr><td>bit_rate</td><td>目标平均比特率，单位是kbps</td><td>[0,700000]</td><td>0</td></tr><tr><td>frame_rate</td><td>目标帧率，单位是fps</td><td>[1,240]</td><td>30</td></tr><tr><td>initial_rc_qp</td><td>指定码率控制时的初始QP值，当该值不在[0,51]范围内,编码器内部会决定初始值</td><td>[0,63]</td><td>63</td></tr><tr><td>vbv_buffer_size</td><td>指定VBVBuffer的大小，单位是ms；实际的VBVbuffer的空间大小为bit_rate*vbv_buffer_size/1000（kb），该buffer的大小会影响编码图像质量和码率控制精度。当该buffer比较小时，码率控制精确度高，但图像编码质量较差；当该buffer比较大时，图像编码质量高，但是码率波动大。</td><td>[10,3000]</td><td>3000</td></tr><tr><td>ctu_level_rc_enalbe</td><td>H264/H265的码率控制可以工作在CTU级别的控制，该模式可以达到更高精度的码率控制，但是会损失编码图像质量，该模式不可以和ROI编码一起工作，当使能ROI编码时，该功能自动失效。</td><td>[0,1]</td><td>0</td></tr><tr><td>min_qp_I</td><td>I帧的最小QP值</td><td>[0,51]</td><td>8</td></tr><tr><td>max_qp_I</td><td>I帧的最大QP值</td><td>[0,51]</td><td>51</td></tr><tr><td>min_qp_P</td><td>P帧的最小QP值</td><td>[0,51]</td><td>8</td></tr><tr><td>max_qp_P</td><td>P帧的最大QP值</td><td>[0,51]</td><td>51</td></tr><tr><td>min_qp_B</td><td>B帧的最小QP值</td><td>[0,51]</td><td>8</td></tr><tr><td>max_qp_B</td><td>B帧的最大QP值</td><td>[0,51]</td><td>51</td></tr><tr><td>hvs_qp_enable</td><td>H264/H265的码率控制可以工作在subCTU级别的控制，该模式会调整子宏块的QP值，进而提高主观图像质量。</td><td>[0,1]</td><td>1</td></tr><tr><td>hvs_qp_scale</td><td>当hvs_qp_enable使能后有效，该值表示QP缩放因子。</td><td>[0,4]</td><td>2</td></tr><tr><td>max_delta_qp</td><td>当hvs_qp_enable使能后有效，指定HVSqp值的最大偏差范围。</td><td>[0,51]</td><td>10</td></tr><tr><td>qp_map_enable</td><td>使能ROI编码时的QPmap</td><td>[0,1]</td><td>0</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="fixqp说明">FixQp说明<a href="#fixqp说明" class="hash-link" aria-label="FixQp说明的直接链接" title="FixQp说明的直接链接">​</a></h5>
<p>FixQp表示固定每一个I帧、P帧的QP值，对于I/P帧可以分别设值。下面是FixQp模式下各个参数含义：</p>
<table><thead><tr><th><strong>数据项</strong></th><th><strong>描述</strong></th><th><strong>取值范围</strong></th><th><strong>默认值</strong></th></tr></thead><tbody><tr><td>intra_period</td><td>I帧间隔</td><td>[0,2047]</td><td>28</td></tr><tr><td>frame_rate</td><td>目标帧率，单位是fps</td><td>[1,240]</td><td>30</td></tr><tr><td>force_qp_I</td><td>强制I帧的QP值</td><td>[0,51]</td><td>0</td></tr><tr><td>force_qp_P</td><td>强制P帧的QP值</td><td>[0,51]</td><td>0</td></tr><tr><td>force_qp_B</td><td>强制B帧的QP值</td><td>[0,51]</td><td>0</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="qpmap说明">QPMAP说明<a href="#qpmap说明" class="hash-link" aria-label="QPMAP说明的直接链接" title="QPMAP说明的直接链接">​</a></h5>
<p>QPMAP表示为一帧图像中的每一个块指定QP值，其中H265块大小为32x32,H264块大小为16x16。下面是QPMAP模式下各个参数含义：</p>
<table><thead><tr><th><strong>数据项</strong></th><th><strong>描述</strong></th><th><strong>取值范围</strong></th><th><strong>默认值</strong></th></tr></thead><tbody><tr><td>intra_period</td><td>I帧间隔</td><td>[0,2047]</td><td>28</td></tr><tr><td>frame_rate</td><td>目标帧率，单位是fps</td><td>[1,240]</td><td>30</td></tr><tr><td>qp_map_array</td><td>指定QPmap表，H265的subCTU大小为32x32，需要为每一个subCTU指定一个QP值，每个QP值占一个字节，并且按照光栅扫描方向排序。</td><td>指针地址</td><td>NULL</td></tr><tr><td>qp_map_array_count</td><td>指定QPmap表的大小。</td><td>[0, MC_VIDEO_MAX_SUB_CTU_NUM]&amp;&amp;(ALIGN64(picWidth)&gt;&gt;5)*(ALIGN64(picHeight)&gt;&gt;5)</td><td>0</td></tr></tbody></table>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="调试方法">调试方法<a href="#调试方法" class="hash-link" aria-label="调试方法的直接链接" title="调试方法的直接链接">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="编码效果调优">编码效果调优<a href="#编码效果调优" class="hash-link" aria-label="编码效果调优的直接链接" title="编码效果调优的直接链接">​</a></h4>
<p>根据当前客户使用codec进行视频编码的场景，多将码率模式设置为CBR，当编码的场景较为复杂时，为了保证视频质量，硬件会自动提高码率值，导致输出的视频较预期更大。因此为了兼顾视频质量和实际码率，需要统筹bit_rate和max_qp_I/P值的设置。下面给出了全I帧模式下，不同复杂场景下，码率设置为15000kbps时，不同max_qp_I下实际码率和qp的情况（不同场景复杂程度不同，下列数据仅供参考）：</p>
<table><thead><tr><th>场景&amp;参数</th><th>室外白天复杂场景 bitrate(15000) max_qp_I(35)</th><th>室外白天复杂场景 bitrate(15000) max_qp_I(38)</th><th>室外白天复杂场景 bitrate(15000) max_qp_I(39)</th></tr></thead><tbody><tr><td>Bit alloction(bps)（越大图像质量越高）</td><td>60300045</td><td>42186920</td><td>35898230</td></tr><tr><td>Qp avg（越小图像质量越高）</td><td>35</td><td>38</td><td>39</td></tr></tbody></table>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="gop结构说明">GOP结构说明<a href="#gop结构说明" class="hash-link" aria-label="GOP结构说明的直接链接" title="GOP结构说明的直接链接">​</a></h4>
<p>H264/H265编码支持GOP结构的设置，用户可从预置的3种GOP结构种选择，也可自定义GOP结构。</p>
<p>GOP结构表可定义一组周期性的GOP结构，该GOP结构将用于整个编码过程。单个结构表中的元素如下表所示，其中可以指定该图像的参考帧，如果IDR帧后的其他帧指  定的参考帧为IDR帧前的数据帧，编码器内部会自动处理这种情况使其不参考其他帧，用户无需关心这种情况。用户在自定义GOP结构时需要指明结构表的数量，最多可定义3个结构表，结构表的顺序需要按照解码顺序排列。
下面表示了结构表中各个元素的含义：</p>
<table><thead><tr><th>元素</th><th>描述</th></tr></thead><tbody><tr><td>Type</td><td>帧类型(I、P、B)</td></tr><tr><td>POC</td><td>GOP内帧的显示顺序，取值范围为[1,gop_size]。</td></tr><tr><td>QPoffset</td><td>自定义GOP中图片的量化参数</td></tr><tr><td>NUM_REF_PIC_L0</td><td>标记为P帧使用多参考图片，仅在PIC_TYPE为P时有效。</td></tr><tr><td>temporal_id</td><td>帧的时间层，帧无法从具有较高时间 id（0~6）的帧进行预测。</td></tr><tr><td>1st_ref_POC</td><td>L0的第一张参考图片的POC</td></tr><tr><td>2nd_ref_POC</td><td>Type为B时，第一张参考图片的POC是L1的； Type为P时，第二张参考图片的POC是L0的； 可以使reference_L1和B slice中的参考图片具有相同的POC， 但出于压缩效率的考虑，建议reference_L1和reference_L0的POC不同。</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="gop预置结构">GOP预置结构<a href="#gop预置结构" class="hash-link" aria-label="GOP预置结构的直接链接" title="GOP预置结构的直接链接">​</a></h5>
<p>一共支持设置九种GOP预置结构</p>
<table><thead><tr><th>序号</th><th>GOP结构</th><th>低延迟（编码顺序和显示顺序相同）</th><th>GOP大小</th><th>编码顺序</th><th>最小源帧buffer数量</th><th>最小解码图片buffer数量</th><th>周期内（I 帧间隔）要求</th></tr></thead><tbody><tr><td>1</td><td>I</td><td>Yes</td><td>1</td><td>I0-I1-I2…</td><td>1</td><td>1</td><td></td></tr><tr><td>2</td><td>P</td><td>Yes</td><td>1</td><td>P0-P1-P2…</td><td>1</td><td>2</td><td></td></tr><tr><td>3</td><td>B</td><td>Yes</td><td>1</td><td>B0-B1-B2…</td><td>1</td><td>3</td><td></td></tr><tr><td>4</td><td>BP</td><td>NO</td><td>2</td><td>B1-P0-B3-P2…</td><td>1</td><td>3</td><td></td></tr><tr><td>5</td><td>BBBP</td><td>Yes</td><td>1</td><td>B2-B1-B3-P0…</td><td>7</td><td>4</td><td></td></tr><tr><td>6</td><td>PPPP</td><td>Yes</td><td>4</td><td>P0-P1-P2-P3…</td><td>1</td><td>2</td><td></td></tr><tr><td>7</td><td>BBBB</td><td>Yes</td><td>4</td><td>B0-B1-B2-B3…</td><td>1</td><td>3</td><td></td></tr><tr><td>8</td><td>BBBB BBBB</td><td>Yes</td><td>1</td><td>B3-B2-B4- B1-B6-B5- B7-B0…</td><td>12</td><td>5</td><td></td></tr><tr><td>9</td><td>P</td><td>Yes</td><td>1</td><td>P0</td><td>1</td><td>2</td><td></td></tr></tbody></table>
<p>GOP Preset 1</p>
<ul>
<li>只有I帧，没有相互参考；</li>
<li>低延时；</li>
</ul>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/b02cc41ab083664ba3f8a3bef1543afa.png" alt="" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/fa1da95bc8801b2d6225b2abf1b2f2d3.png" alt="" class="img_ev3q"></p>
<p>GOP Preset 2</p>
<ul>
<li>只有I帧和P帧；</li>
<li>P帧参考2个前向参考帧；</li>
<li>低延时；</li>
</ul>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/e3c2f773a89f6ee2fe2dab03200b6fd0.png" alt="" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/8fa5f892bd7282e82ac8ed96011c943d.png" alt="" class="img_ev3q"></p>
<p>GOP Preset 3</p>
<ul>
<li>只有I帧和B帧；</li>
<li>B帧参考2个前向参考帧；</li>
<li>低延时；</li>
</ul>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/03bbdf35dc3e2a1b38f9e05d7038d064.png" alt="" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/e1b5707ea0c32b6a0c1658527a6186dd.png" alt="" class="img_ev3q"></p>
<p>GOP Preset 4</p>
<ul>
<li>只有I帧、P帧和B帧；</li>
<li>P帧参考2个前向参考帧；</li>
<li>B帧参考1个前向参考帧和一个后向参考帧；</li>
</ul>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/17e10e6a27db202fe9a0c2b5f3d5dd50.png" alt="" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/972bbe22d2e7364c1c0a3db03f57343e.png" alt="" class="img_ev3q"></p>
<p>GOP Preset 5</p>
<ul>
<li>只有I帧、P帧和B帧；</li>
<li>P帧参考2个前向参考帧；</li>
<li>B帧参考1个前向参考帧和一个后向参考帧，后向参考帧可为P帧或B帧；</li>
</ul>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/16ad2d15f0b22a91fda1450747a18422.png" alt="" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/8ff1393cdbb997c8768ea2f9f00c3c8b.png" alt="" class="img_ev3q"></p>
<p>GOP Preset 6</p>
<ul>
<li>只有I帧和P帧；</li>
<li>P帧参考2个前向参考帧；</li>
<li>低延时；</li>
</ul>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/a5fbffa7c85a3423729f06d45f83a601.png" alt="" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/1e88c6cbacb8fff86f5d5fc301e01abd.png" alt="" class="img_ev3q"></p>
<p>GOP Preset 7</p>
<ul>
<li>只有I帧和B帧；</li>
<li>B帧参考2个前向参考帧；</li>
<li>低延时；</li>
</ul>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/40cd6c4fa7cf66f9bf14c3675cb7ef20.png" alt="" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/be7fe30d2685e27e2b36f305ef745eb4.png" alt="" class="img_ev3q"></p>
<p>GOP Preset 8</p>
<ul>
<li>只有I帧和B帧；</li>
<li>B帧参考1个前向参考帧，一个后向参考帧；</li>
</ul>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/9c46efaf2a9106bcee2468098e209b1f.png" alt="" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/d016b90fa0a06e183b6871bc430a8714.png" alt="" class="img_ev3q"></p>
<p>GOP Preset 9</p>
<ul>
<li>只有I帧和P帧；</li>
<li>P帧参考1个前向参考帧；</li>
<li>低延时；</li>
</ul>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/0bc1b9d3e73b4037b64236650738b5cd.png" alt="" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/937b45950423ff5006e378cb510d695d.png" alt="" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="vpu调试方式">VPU调试方式<a href="#vpu调试方式" class="hash-link" aria-label="VPU调试方式的直接链接" title="VPU调试方式的直接链接">​</a></h4>
<p>VPU（视频处理单元）是一种专用的视觉处理单元，可以高效处理视频内容。VPU可以实现H265视频格式的编解码处理。用户通过Codec提供的接口即可获得输入的编码/解码流。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="编码状态">编码状态<a href="#编码状态" class="hash-link" aria-label="编码状态的直接链接" title="编码状态的直接链接">​</a></h5>
<p>编码调试信息</p>
<div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">cat </span><span class="token operator" style="color:#393A34">/</span><span class="token plain">sys</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">kernel</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">debug</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">vpu</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">venc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">root@ubuntu</span><span class="token operator" style="color:#393A34">:</span><span class="token operator" style="color:#393A34">~</span><span class="token plain"># cat </span><span class="token operator" style="color:#393A34">/</span><span class="token plain">sys</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">kernel</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">debug</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">vpu</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">venc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain">encode enc param</span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enc_idx  enc_id     profile       level width height pix_fmt fbuf_count extern_buf_flag bsbuf_count bsbuf_size mirror rotate</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">    h265        Main unspecified  </span><span class="token number" style="color:#36acaa">4096</span><span class="token plain">   </span><span class="token number" style="color:#36acaa">2160</span><span class="token plain">       </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">          </span><span class="token number" style="color:#36acaa">5</span><span class="token plain">               </span><span class="token number" style="color:#36acaa">1</span><span class="token plain">           </span><span class="token number" style="color:#36acaa">5</span><span class="token plain">   </span><span class="token number" style="color:#36acaa">13271040</span><span class="token plain">      </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">      </span><span class="token number" style="color:#36acaa">0</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain">encode h265cbr param</span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enc_idx rc_mode intra_period intra_qp bit_rate frame_rate initial_rc_qp vbv_buffer_size ctu_level_rc_enalbe min_qp_I max_qp_I min_qp_P max_qp_P min_qp_B max_qp_B hvs_qp_enable hvs_qp_scale qp_map_enable max_delta_qp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token number" style="color:#36acaa">0</span><span class="token plain"> h265cbr           </span><span class="token number" style="color:#36acaa">20</span><span class="token plain">       </span><span class="token number" style="color:#36acaa">30</span><span class="token plain">     </span><span class="token number" style="color:#36acaa">5000</span><span class="token plain">         </span><span class="token number" style="color:#36acaa">30</span><span class="token plain">            </span><span class="token number" style="color:#36acaa">30</span><span class="token plain">            </span><span class="token number" style="color:#36acaa">3000</span><span class="token plain">                   </span><span class="token number" style="color:#36acaa">1</span><span class="token plain">        </span><span class="token number" style="color:#36acaa">8</span><span class="token plain">       </span><span class="token number" style="color:#36acaa">50</span><span class="token plain">        </span><span class="token number" style="color:#36acaa">8</span><span class="token plain">       </span><span class="token number" style="color:#36acaa">50</span><span class="token plain">        </span><span class="token number" style="color:#36acaa">8</span><span class="token plain">       </span><span class="token number" style="color:#36acaa">50</span><span class="token plain">             </span><span class="token number" style="color:#36acaa">1</span><span class="token plain">            </span><span class="token number" style="color:#36acaa">2</span><span class="token plain">             </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">           </span><span class="token number" style="color:#36acaa">10</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain">encode gop param</span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enc_idx  enc_id gop_preset_idx custom_gop_size decoding_refresh_type</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">    h265              </span><span class="token number" style="color:#36acaa">2</span><span class="token plain">               </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                     </span><span class="token number" style="color:#36acaa">2</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain">encode intra refresh</span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enc_idx  enc_id intra_refresh_mode intra_refresh_arg</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">    h265                  </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                 </span><span class="token number" style="color:#36acaa">0</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain">encode longterm ref</span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enc_idx  enc_id use_longterm longterm_pic_period longterm_pic_using_period</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">    h265            </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                   </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                         </span><span class="token number" style="color:#36acaa">0</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain">encode roi_params</span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enc_idx  enc_id roi_enable roi_map_array_count</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">    h265          </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                   </span><span class="token number" style="color:#36acaa">0</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain">encode mode_decision </span><span class="token number" style="color:#36acaa">1</span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enc_idx  enc_id mode_decision_enable pu04_delta_rate pu08_delta_rate pu16_delta_rate pu32_delta_rate pu04_intra_planar_delta_rate pu04_intra_dc_delta_rate pu04_intra_angle_delta_rate pu08_intra_planar_delta_rate pu08_intra_dc_delta_rate pu08_intra_angle_delta_rate pu16_intra_planar_delta_rate pu16_intra_dc_delta_rate pu16_intra_angle_delta_rate</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">    h265                    </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">               </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">               </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">               </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">               </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                            </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                        </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                           </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                            </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                        </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                           </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                            </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                        </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                           </span><span class="token number" style="color:#36acaa">0</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain">encode mode_decision </span><span class="token number" style="color:#36acaa">2</span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enc_idx  enc_id pu32_intra_planar_delta_rate pu32_intra_dc_delta_rate pu32_intra_angle_delta_rate cu08_intra_delta_rate cu08_inter_delta_rate cu08_merge_delta_rate cu16_intra_delta_rate cu16_inter_delta_rate cu16_merge_delta_rate cu32_intra_delta_rate cu32_inter_delta_rate cu32_merge_delta_rate</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">    h265                            </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                        </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                           </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                     </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                     </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                     </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                     </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                     </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                     </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                     </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                     </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                     </span><span class="token number" style="color:#36acaa">0</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain">encode h265_transform</span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enc_idx  enc_id chroma_cb_qp_offset chroma_cr_qp_offset user_scaling_list_enable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">    h265                   </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                   </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                        </span><span class="token number" style="color:#36acaa">0</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain">encode h265_pred_unit</span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enc_idx  enc_id intra_nxn_enable constrained_intra_pred_flag strong_intra_smoothing_enabled_flag max_num_merge</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">    h265                </span><span class="token number" style="color:#36acaa">1</span><span class="token plain">                           </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                                   </span><span class="token number" style="color:#36acaa">1</span><span class="token plain">             </span><span class="token number" style="color:#36acaa">2</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain">encode h265 timing</span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enc_idx  enc_id vui_num_units_in_tick vui_time_scale vui_num_ticks_poc_diff_one_minus1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">    h265                  </span><span class="token number" style="color:#36acaa">1000</span><span class="token plain">          </span><span class="token number" style="color:#36acaa">30000</span><span class="token plain">                                 </span><span class="token number" style="color:#36acaa">0</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain">encode h265 slice params</span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enc_idx  enc_id h265_independent_slice_mode h265_independent_slice_arg h265_dependent_slice_mode h265_dependent_slice_arg</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">    h265                           </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                          </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                         </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                        </span><span class="token number" style="color:#36acaa">0</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain">encode h265 deblk filter</span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enc_idx  enc_id slice_deblocking_filter_disabled_flag slice_beta_offset_div2 slice_tc_offset_div2 slice_loop_filter_across_slices_enabled_flag</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">    h265                                     </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                      </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                    </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                                            </span><span class="token number" style="color:#36acaa">1</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain">encode h265 sao param</span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enc_idx  enc_id sample_adaptive_offset_enabled_flag</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">    h265                              </span><span class="token number" style="color:#36acaa">1</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain">encode status</span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enc_idx  enc_id cur_input_buf_cnt cur_output_buf_cnt left_recv_frame left_enc_frame total_input_buf_cnt total_output_buf_cnt     fps</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">    h265                 </span><span class="token number" style="color:#36acaa">4</span><span class="token plain">                  </span><span class="token number" style="color:#36acaa">1</span><span class="token plain">               </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">              </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                </span><span class="token number" style="color:#36acaa">1093</span><span class="token plain">                 </span><span class="token number" style="color:#36acaa">1089</span><span class="token plain">      </span><span class="token number" style="color:#36acaa">35</span><br></span></code></pre></div></div>
<p>参数解释</p>
<table><thead><tr><th>调试信息分组</th><th>状态参数</th><th>说明</th></tr></thead><tbody><tr><td>encode enc param</td><td>基础编码参数</td><td>enc_idx：编码实例值 enc_id：编码类型 profile：profile类型 level：h265 level类型 width：编码宽度 height：编码高度 pix_fmt：输入帧像素类型 fbuf_count：输入的rameBuffer数 extern_buf_flag：是否使用外部输入buffer bsbuf_count：bitstreamBuffer数 bsbuf_size：bitstreamBuffer大小 mirror：是否设置镜像 rotate：是否设置旋转</td></tr><tr><td>encode h265cbr param</td><td>CBR码率控制参数</td><td>enc_idx：编码实例值 rc_mode：码率控制类型 intra_period：I帧间隔 intra_qp：I帧qp值 bit_rate：码率值 frame_rate：帧率 initial_rc_qp：初始QP值 vbv_buffer_size：VBV buffer的大小 ctu_level_rc_enalbe：码率控制是否工作在ctu级别 min_qp_I：I帧最小QP值 max_qp_I：I帧最大QP值 min_qp_P：P帧最小QP值 max_qp_P：P帧最大QP值 min_qp_B：B帧最小QP值 max_qp_B：B帧最大QP值 hvs_qp_enable：码率控制是否工作在subCTU级别 hvs_qp_scale：QP缩放因子 qp_map_enable：使能ROI编码时的QP map max_delta_qp：指定HVS QP值的最大偏差范围</td></tr><tr><td>encode gop param</td><td>GOP参数</td><td>enc_idx：编码实例值 enc_id：编码类型 gop_preset_idx：选择预置的GOP结构 custom_gop_size：自定义时GOP的大小 decoding_refresh_type：设置IDR帧的具体类型</td></tr><tr><td>encode intra refresh</td><td>帧内刷新参数</td><td>enc_idx：编码实例值 enc_id：编码类型 intra_refresh_mode：帧内刷新模式 intra_refresh_arg：帧内刷新参数</td></tr><tr><td>encode longterm ref</td><td>长期参考帧参数</td><td>enc_idx：编码实例值 enc_id：编码类型 use_longterm：使能长期参考帧 longterm_pic_period：长期参考帧周期 longterm_pic_using_period：参考长期参考帧的周期</td></tr><tr><td>encode roi_params</td><td>ROI参数</td><td>enc_idx：编码实例值 enc_id：编码类型 roi_enable：使能ROI编码 roi_map_array_count：ROI map中元素的个数</td></tr><tr><td>encode mode_decision 1</td><td>块编码模式决策参数1</td><td>各种模式选择参数值，包括pu04_delta_rate，pu08_delta_rate等</td></tr><tr><td>encode mode_decision 2</td><td>块编码模式决策参数2</td><td>各种模式选择参数值，包括pu32_intra_planar_delta_rate， pu32_intra_dc_delta_rate等</td></tr><tr><td>encode h265_transform</td><td>Transform参数</td><td>enc_idx：编码实例值 enc_id：编码类型 chroma_cb_qp_offset：指定cb分量的QP偏差 chroma_cr_qp_offset：指定cr分量的QP偏差 user_scaling_list_enable：使能用户指定的scaling list</td></tr><tr><td>encode h265_pred_unit</td><td>预测单元参数</td><td>enc_idx：编码实例值 enc_id：编码类型 intra_nxn_enable：使能intra NXN PUs constrained_intra_pred_flag：帧内预测是否受限 strong_intra_smoothing_enabled_flag：滤波过程是否使用双向线性插值 max_num_merge：指定merge候选的数量</td></tr><tr><td>encode h265 timing</td><td>Timing参数</td><td>enc_idx：编码实例值 enc_id：编码类型 vui_num_units_in_tick：指定时间单位数 vui_time_scale：一秒内的时间单位数 vui_num_ticks_poc_diff_one_minus1：指定与等于1的图片顺序计数值之差对应的时钟滴答数</td></tr><tr><td>encode h265 slice params</td><td>Slice参数</td><td>enc_idx：编码实例值 enc_id：编码类型 h265_independent_slice_mode：独立slice编码模式 h265_independent_slice_arg：独立slice的大小 h265_dependent_slice_mode：非独立slice编码模式 h265_dependent_slice_arg：非独立slice的大小</td></tr><tr><td>encode h265 deblk filter</td><td>去块滤波参数</td><td>enc_idx：编码实例值 enc_id：编码类型 slice_deblocking_filter_disabled_flag：是否进行slice内部滤波 slice_beta_offset_div2：指定当前切片的β去块参数偏移量 slice_tc_offset_div2：指定当前切片的tC去块参数偏移量 slice_loop_filter_across_slices_enabled_flag：是否进行边界滤波</td></tr><tr><td>encode h265 sao param</td><td>SAO参数</td><td>enc_idx：编码实例值 enc_id：编码类型 sample_adaptive_offset_enabled_flag：是否对经过去块滤波处理后的重构图像进行采样自适应偏移处理</td></tr><tr><td>encode status</td><td>当前编码状态参数</td><td>enc_idx：编码实例值 enc_id：编码类型 cur_input_buf_cnt：当前使用的inputbuffer数量 cur_output_buf_cnt：当前使用的outputbuffer数量 left_recv_frame：剩余需要接收的帧数（设置receive_frame_number后有效） left_enc_frame：剩余需要编码的帧数（设置receive_frame_number后有效） total_input_buf_cnt：表示当前总使用的inputbuffer数 total_output_buf_cnt：表示当前总使用的outputbuffer数 fps：表示当前的帧率</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="解码状态">解码状态<a href="#解码状态" class="hash-link" aria-label="解码状态的直接链接" title="解码状态的直接链接">​</a></h5>
<p>解码调试信息</p>
<div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">cat </span><span class="token operator" style="color:#393A34">/</span><span class="token plain">sys</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">kernel</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">debug</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">vpu</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">vdec</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">root@ubuntu</span><span class="token operator" style="color:#393A34">:</span><span class="token operator" style="color:#393A34">~</span><span class="token plain"># cat </span><span class="token operator" style="color:#393A34">/</span><span class="token plain">sys</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">kernel</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">debug</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">vpu</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">vdec</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain">decode param</span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dec_idx dec_id feed_mode pix_fmt bitstream_buf_size bitstream_buf_count frame_buf_count</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">   h265     </span><span class="token number" style="color:#36acaa">1</span><span class="token plain">      </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">     </span><span class="token number" style="color:#36acaa">13271040</span><span class="token plain">          </span><span class="token number" style="color:#36acaa">6</span><span class="token plain">   </span><span class="token number" style="color:#36acaa">6</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain">h265 decode param</span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dec_idx dec_id reorder_enable skip_mode bandwidth_Opt cra_as_bla dec_temporal_id_mode target_dec_temporal_id_plus1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">   h265        </span><span class="token number" style="color:#36acaa">1</span><span class="token plain">          </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">          </span><span class="token number" style="color:#36acaa">1</span><span class="token plain">            </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">        </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                      </span><span class="token number" style="color:#36acaa">0</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain">decode frameinfo</span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dec_idx dec_id display_width display_height</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">   h265       </span><span class="token number" style="color:#36acaa">4096</span><span class="token plain">       </span><span class="token number" style="color:#36acaa">2160</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain">decode status</span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dec_idx dec_id cur_input_buf_cnt cur_output_buf_cnt total_input_buf_cnt total_output_buf_cnt fps</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">   h265          </span><span class="token number" style="color:#36acaa">5</span><span class="token plain">                </span><span class="token number" style="color:#36acaa">1</span><span class="token plain">              </span><span class="token number" style="color:#36acaa">458</span><span class="token plain">       </span><span class="token number" style="color:#36acaa">453</span><span class="token plain">         </span><span class="token number" style="color:#36acaa">53</span><br></span></code></pre></div></div>
<p>参数解释</p>
<table><thead><tr><th>调试信息分组</th><th>状态参数</th><th>说明</th></tr></thead><tbody><tr><td>decode param</td><td>基础解码参数</td><td>dec_idx：解码实例值 dec_id：解码类型 feed_mode：数据填充类型 pix_fmt：输出像素类型 bitstream_buf_size：输入的bitstream缓存区大小 bitstream_buf_count：输入的bitstream缓存区个数 frame_buf_count：输出的Framebuffer缓存的个数</td></tr><tr><td>h265 decode param</td><td>H265解码基础参数</td><td>dec_idx：解码实例值 dec_id：解码类型 reorder_enable：使能解码器按显示顺序输出帧序列 skip_mode：使能帧解码忽略模式 bandwidth_Opt：使能节省带宽模式 cra_as_bla：使能CRA作为BLA处理 dec_temporal_id_mode：指定temporal id的选择模式 target_dec_temporal_id_plus1：指定temporal id值</td></tr><tr><td>decode frameinfo</td><td>解码输出帧信息</td><td>dec_idx：解码实例值 dec_id：解码类型 display_width：显示的宽度 display_height：显示的高度</td></tr><tr><td>decode status</td><td>当前解码状态参数</td><td>dec_idx：解码实例值 dec_id：解码类型 cur_input_buf_cnt：当前使用的inputbuffer数量 cur_output_buf_cnt：当前使用的outputbuffer数量 total_input_buf_cnt：当前总使用的inputbuffer数 total_output_buf_cnt：当前总使用的outputbuffer数 fps：当前帧率</td></tr></tbody></table>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="jpu-调试方式">JPU 调试方式<a href="#jpu-调试方式" class="hash-link" aria-label="JPU 调试方式的直接链接" title="JPU 调试方式的直接链接">​</a></h4>
<p>JPU（图片处理单元）主要用以完成JPEG/MJPEG的编解码功能。用户可以通过CODEC接口输入待编码的YUV数据或待解码的JPEG图片，通过JPU处理后获取编码完的JPEG图片或解码完的YUV数据。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="编码状态-1">编码状态<a href="#编码状态-1" class="hash-link" aria-label="编码状态的直接链接" title="编码状态的直接链接">​</a></h5>
<p>编码调试信息</p>
<div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">cat </span><span class="token operator" style="color:#393A34">/</span><span class="token plain">sys</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">kernel</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">debug</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">jpu</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">jenc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">root@ubuntu</span><span class="token operator" style="color:#393A34">:</span><span class="token operator" style="color:#393A34">~</span><span class="token plain"># cat </span><span class="token operator" style="color:#393A34">/</span><span class="token plain">sys</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">kernel</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">debug</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">jpu</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">jenc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain">encode param</span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enc_idx  enc_id width height pix_fmt fbuf_count extern_buf_flag bsbuf_count bsbuf_size mirror rotate</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">    jpeg  </span><span class="token number" style="color:#36acaa">1920</span><span class="token plain">   </span><span class="token number" style="color:#36acaa">1088</span><span class="token plain">       </span><span class="token number" style="color:#36acaa">1</span><span class="token plain">          </span><span class="token number" style="color:#36acaa">5</span><span class="token plain">               </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">           </span><span class="token number" style="color:#36acaa">5</span><span class="token plain">    </span><span class="token number" style="color:#36acaa">3137536</span><span class="token plain">      </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">      </span><span class="token number" style="color:#36acaa">0</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain">encode rc param</span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enc_idx   rc_mode frame_rate quality_factor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token number" style="color:#36acaa">0</span><span class="token plain"> noratecontrol          </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">              </span><span class="token number" style="color:#36acaa">0</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain">encode status</span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enc_idx  enc_id cur_input_buf_cnt cur_output_buf_cnt left_recv_frame left_enc_frame total_input_buf_cnt total_output_buf_cnt     fps</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">    jpeg                 </span><span class="token number" style="color:#36acaa">4</span><span class="token plain">                  </span><span class="token number" style="color:#36acaa">1</span><span class="token plain">               </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">              </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                </span><span class="token number" style="color:#36acaa">4344</span><span class="token plain">                 </span><span class="token number" style="color:#36acaa">4340</span><span class="token plain">     </span><span class="token number" style="color:#36acaa">287</span><br></span></code></pre></div></div>
<p>参数解释</p>
<table><thead><tr><th>调试信息分组</th><th>状态参数</th><th>说明</th></tr></thead><tbody><tr><td>encode param</td><td>基础编码参数</td><td>enc_idx：编码实例 enc_id：编码类型 width：图像宽度 height：图像高度 pix_fmt：像素类型 fbuf_count：输入的Framebuffer缓存的个数 extern_buf_flag：是否使用用户分配的输入buffer bsbuf_count：输出的bitstream缓存区个数 bsbuf_size：输出的bitstream的大小 mirror：是否设置镜像 rotate：是否设置旋转</td></tr><tr><td>encode rc param</td><td>mjpeg码率控制参数</td><td>enc_idx：编码实例 rc_mode：码率控制模式 frame_rate：目标帧率 quality_factor：量化因子</td></tr><tr><td>encode status</td><td>当前编码状态参数</td><td>enc_idx：编码实例值 enc_id：编码类型 cur_input_buf_cnt：当前使用的inputbuffer数量 cur_output_buf_cnt：当前使用的outputbuffer数量 left_recv_frame：剩余需要接收的帧数（设置receive_frame_number后有效） left_enc_frame：剩余需要编码的帧数（设置receive_frame_number后有效） total_input_buf_cnt：表示当前总使用的inputbuffer数 total_output_buf_cnt：表示当前总使用的outputbuffer数 fps：表示当前的帧率</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="解码状态-1">解码状态<a href="#解码状态-1" class="hash-link" aria-label="解码状态的直接链接" title="解码状态的直接链接">​</a></h5>
<p>解码调试信息</p>
<div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">cat </span><span class="token operator" style="color:#393A34">/</span><span class="token plain">sys</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">kernel</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">debug</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">jpu</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">jdec</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">root@ubuntu</span><span class="token operator" style="color:#393A34">:</span><span class="token operator" style="color:#393A34">~</span><span class="token plain"># cat </span><span class="token operator" style="color:#393A34">/</span><span class="token plain">sys</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">kernel</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">debug</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">jpu</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">jdec</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain">decode param</span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dec_idx  dec_id feed_mode pix_fmt bitstream_buf_size bitstream_buf_count frame_buf_count mirror rotate</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">    jpeg         </span><span class="token number" style="color:#36acaa">1</span><span class="token plain">       </span><span class="token number" style="color:#36acaa">1</span><span class="token plain">            </span><span class="token number" style="color:#36acaa">3133440</span><span class="token plain">                   </span><span class="token number" style="color:#36acaa">5</span><span class="token plain">               </span><span class="token number" style="color:#36acaa">5</span><span class="token plain">      </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">      </span><span class="token number" style="color:#36acaa">0</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain">decode frameinfo</span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dec_idx  dec_id display_width display_height</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">    jpeg          </span><span class="token number" style="color:#36acaa">1920</span><span class="token plain">           </span><span class="token number" style="color:#36acaa">1088</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain">decode status</span><span class="token operator" style="color:#393A34">--</span><span class="token operator" style="color:#393A34">--</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dec_idx  dec_id cur_input_buf_cnt cur_output_buf_cnt total_input_buf_cnt total_output_buf_cnt     fps</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">    jpeg                 </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">                  </span><span class="token number" style="color:#36acaa">1</span><span class="token plain">                </span><span class="token number" style="color:#36acaa">3779</span><span class="token plain">                 </span><span class="token number" style="color:#36acaa">3779</span><span class="token plain">     </span><span class="token number" style="color:#36acaa">264</span><br></span></code></pre></div></div>
<p>参数解释</p>
<table><thead><tr><th>调试信息分组</th><th>状态参数</th><th>说明</th></tr></thead><tbody><tr><td>decode param</td><td>解码基础参数</td><td>dec_idx：解码实例 dec_id：解码类型 feed_mode： pix_fmt：图像像素 bitstream_buf_size：输入的bitstream缓存区大小 bitstream_buf_count：输入的bitstream缓存区个数 frame_buf_count：输出的Framebuffer缓存的个数 mirror：是否设置镜像 rotate：是否设置旋转</td></tr><tr><td>decode frameinfo</td><td>解码输出帧信息</td><td>dec_idx：解码实例值 dec_id：解码类型 display_width：显示的宽度 display_height：显示的高度</td></tr><tr><td>decode status</td><td>当前编码状态参数</td><td>dec_idx：解码实例值 dec_id：解码类型 cur_input_buf_cnt：当前使用的inputbuffer数量 cur_output_buf_cnt：当前使用的outputbuffer数量 total_input_buf_cnt：当前总使用的inputbuffer数 total_output_buf_cnt：当前总使用的outputbuffer数 fps：当前帧率</td></tr></tbody></table>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="典型场景">典型场景<a href="#典型场景" class="hash-link" aria-label="典型场景的直接链接" title="典型场景的直接链接">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="单路编码">单路编码<a href="#单路编码" class="hash-link" aria-label="单路编码的直接链接" title="单路编码的直接链接">​</a></h4>
<p>单路编码场景如下图所示。Scenario0是简单场景，从EMMC中读取YUV视频/图像文件，经过VPU硬件编码输出的H26x码流或JPU硬件编码输出的Jpeg图像，最后保存为文件存储到EMMC。Scenario1是串联前后级模块的复杂场景，将摄像头采集的数据编码压缩后进行保存或通过网络和PCIE传输。</p>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/788c1e3b839232111ccd53d35d25e278.png" alt="" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="单路解码">单路解码<a href="#单路解码" class="hash-link" aria-label="单路解码的直接链接" title="单路解码的直接链接">​</a></h4>
<p>单路解码场景如下图所示。Scenario0是简单场景，从EMMC中读取H26x码流/Jpeg图像文件，经过VPU或JPU硬件解码输出的YUV数据，最后保存为文件存储到EMMC。Scenario1是串联前后级模块的复杂场景，通过网络或PCIE接收已编码的视频或图像数据，经过VPU或JPU硬件解码后使用IDE显示播放。</p>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/e50f9bf3c4d1ecfbd36b354f9009e8bc.png" alt="" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="多路编码">多路编码<a href="#多路编码" class="hash-link" aria-label="多路编码的直接链接" title="多路编码的直接链接">​</a></h4>
<p>多路编码场景如下图所示，Scenario0是文件输入的简单场景，Scenario1是串联前后级模块的复杂场景，需要注意的是在Scenario1场景要综合考虑链路中各个模块的能力限制。</p>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/272e3467c640af379d1b4c0a1de27eae.png" alt="" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="多路解码">多路解码<a href="#多路解码" class="hash-link" aria-label="多路解码的直接链接" title="多路解码的直接链接">​</a></h4>
<p>多路解码场景如下图所示，Scenario0是文件输入的简单场景，Scenario1是串联前后级模块的复杂场景，需要注意的是在Scenario1场景要综合考虑链路中各个模块的能力限制。</p>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/04f0aba90a1d65017dfeb90f9afa43e2.png" alt="" class="img_ev3q"></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="codec-api">Codec API<a href="#codec-api" class="hash-link" aria-label="Codec API的直接链接" title="Codec API的直接链接">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="mediacodec接口说明">MediaCodec接口说明<a href="#mediacodec接口说明" class="hash-link" aria-label="MediaCodec接口说明的直接链接" title="MediaCodec接口说明的直接链接">​</a></h3>
<p>MediaCodec模块主要用于音频、视频和JPEG图像的编解码。本模块将会提供一系列的接口便于用户输入待处理的数据和获取处理完的数据。本模块支持多路编码或解码实例同时工作，其中视频和JPEG图像的编解码由硬件实现，用户需要调用libmultimedia.so，音频则基于FFMPEG的接口由软件实现，用户需要调用libffmedia.so，如下表所示为RDKS100所支持的视频编解码规范和音频编解码规范，需要注意的是AAC的编解码需要license授权，因此用户需要获得授权后才能使能相关代码。</p>
<p>H265 profile最高支持Main profile，Level最高支持L5.1，Tier支持Main-tier。H264 profile最高支持High profile，Level最高支持L5.2。MJPEG/JPEG 支持ISO/IEC 10918-1 Baseline sequential。音频支持：G.711 A-law/Mu-law，G.729 ADPCM，ADPCM IMA WAV，FLAC，AAC LC，AAC Main，AAC SSR，AAC LTP，AAC LD，AAC HE，AAC HEv2（AAC需要license授权）。</p>
<p>此外视频和图像的数据源包括VIO输入的图像和用户输入的YUV数据两类，用户输入的YUV数据则可能是从文件中加载或者通过网络传输获得；音频的数据源包括MIC输入的音频和用户输入的PCM数据两类，MIC输入的音频是由Audio Codec采集的数字信号，用户输入的PCM数据则可能是从文件或网络传输获得。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="gop">GOP<a href="#gop" class="hash-link" aria-label="GOP的直接链接" title="GOP的直接链接">​</a></h4>
<p>H264/H265编码支持GOP结构的设置，用户可从预置的9种GOP结构中选择，也可自定义GOP结构。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="gop结构表">GOP结构表<a href="#gop结构表" class="hash-link" aria-label="GOP结构表的直接链接" title="GOP结构表的直接链接">​</a></h5>
<p>GOP结构表可定义一组周期性的GOP结构，该GOP结构将用于整个编码过程。单个结构表中的元素如下表所示，其中可以指定该图像的参考帧，如果IDR帧后的其他帧指定的参考帧为IDR帧前的数据帧，编码器内部会自动处理这种情况使其不参考其他帧，用户无需关心这种情况。用户在自定义GOP结构时需要指明结构表的数量，最多可定义3个结构表，结构表的顺序需要按照解码顺序排列。</p>
<table><thead><tr><th>Element</th><th>Description</th></tr></thead><tbody><tr><td>Type</td><td>Slice type（I，P）</td></tr><tr><td>POC</td><td>Display order of the frame within a GOP，ranging from 1 to GOP size</td></tr><tr><td>QPoffset</td><td>A quantization parameter of the picture in the custom GOP</td></tr><tr><td>NUM_REF_PIC_L0</td><td>Flag to use multi reference picture for P picture. It is valid only if PIC_TYPE is P</td></tr><tr><td>temporal_id</td><td>Temporal layer of the frame. A frame cannot predict from a frame with a higher temporal id (0~6).</td></tr><tr><td>1st_ref_POC</td><td>The POC of the 1st reference picture of L0</td></tr><tr><td>2nd_ref_POC</td><td>The POC of 1st reference picture of L1 in case that Type is equal to B. The POC of 2nd reference picture of L0 in case that Type is equal to P. Note that reference_L1 can have the same POC as reference in B slice. But for compression efficiency it is recommended that reference_L1 have a different POC from reference_L0.</td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="gop预置结构-1">GOP预置结构<a href="#gop预置结构-1" class="hash-link" aria-label="GOP预置结构的直接链接" title="GOP预置结构的直接链接">​</a></h5>
<table><thead><tr><th>Index</th><th>GOP Stru cture</th><th>Low Delay (encoding order and display order are same)</th><th>GOP Size</th><th>Encoding Order</th><th>Minimum Source Frame Buffer</th><th>Minimum Decoded Picture Buffer</th><th>Intra Period (I Frame Interval) Requirement</th></tr></thead><tbody><tr><td>1</td><td>I</td><td>Yes</td><td>1</td><td>I0-I1-I2…</td><td>1</td><td>1</td><td></td></tr><tr><td>2</td><td>P</td><td>Yes</td><td>1</td><td>P0-P1-P2…</td><td>1</td><td>2</td><td></td></tr><tr><td>3</td><td>B</td><td>Yes</td><td>1</td><td>B0-B1-B2…</td><td>1</td><td>3</td><td></td></tr><tr><td>4</td><td>BP</td><td>NO</td><td>2</td><td>B1-P0-B3-P2…</td><td>1</td><td>3</td><td>Multiple of 2</td></tr><tr><td>5</td><td>BBBP</td><td>Yes</td><td>1</td><td>B2-B1-B3-P0…</td><td>7</td><td>4</td><td>Multiple of 4</td></tr><tr><td>6</td><td>PPPP</td><td>Yes</td><td>4</td><td>P0-P1-P2-P3…</td><td>1</td><td>2</td><td></td></tr><tr><td>7</td><td>BBBB</td><td>Yes</td><td>4</td><td>B0-B1-B2-B3…</td><td>1</td><td>3</td><td></td></tr><tr><td>8</td><td>BBBB BBBB</td><td>Yes</td><td>1</td><td>B3-B2-B4- B1-B6-B5- B7-B0…</td><td>12</td><td>5</td><td>Multiple of 8</td></tr><tr><td>9</td><td>P</td><td>Yes</td><td>1</td><td>P0</td><td>1</td><td>2</td><td></td></tr></tbody></table>
<p>以下会对9种预置的GOP结构进行说明。</p>
<p>GOP Preset 1</p>
<ul>
<li>只有I帧，没有相互参考；</li>
<li>低延时；</li>
</ul>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/gop1.png" alt="gop1" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/gop2.png" alt="gop2" class="img_ev3q"></p>
<p>GOP Preset 2</p>
<ul>
<li>只有I帧和P帧；</li>
<li>P帧参考2个前向参考帧；</li>
<li>低延时；</li>
</ul>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/gop3.png" alt="gop3" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/gop4.png" alt="gop4" class="img_ev3q"></p>
<p>GOP Preset 3</p>
<ul>
<li>只有I帧和B帧；</li>
<li>B帧参考2个前向参考帧；</li>
<li>低延时；</li>
</ul>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/gop5.png" alt="gop5" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/gop6.png" alt="gop6" class="img_ev3q"></p>
<p>GOP Preset 4</p>
<ul>
<li>只有I帧、P帧和B帧；</li>
<li>P帧参考2个前向参考帧；</li>
<li>B帧参考1个前向参考帧和一个后向参考帧；</li>
</ul>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/gop7.png" alt="gop7" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/gop8.png" alt="gop8" class="img_ev3q"></p>
<p>GOP Preset 5</p>
<ul>
<li>只有I帧、P帧和B帧；</li>
<li>P帧参考2个前向参考帧；</li>
<li>B帧参考1个前向参考帧和一个后向参考帧，后向参考帧可为P帧或B帧；</li>
</ul>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/gop9.png" alt="gop9" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/gop10.png" alt="gop10" class="img_ev3q"></p>
<p>GOP Preset 6</p>
<ul>
<li>只有I帧和P帧；</li>
<li>P帧参考2个前向参考帧；</li>
<li>低延时；</li>
</ul>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/gop11.png" alt="gop11" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/gop12.png" alt="gop12" class="img_ev3q"></p>
<p>GOP Preset 7</p>
<ul>
<li>只有I帧和B帧；</li>
<li>B帧参考2个前向参考帧；</li>
<li>低延时；</li>
</ul>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/gop13.png" alt="gop13" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/gop14.png" alt="gop14" class="img_ev3q"></p>
<p>GOP Preset 8</p>
<ul>
<li>只有I帧和B帧；</li>
<li>B帧参考1个前向参考帧，一个后向参考帧；</li>
</ul>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/gop15.png" alt="gop15" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/gop16.png" alt="gop16" class="img_ev3q"></p>
<p>GOP Preset 9</p>
<ul>
<li>只有I帧和P帧；</li>
<li>P帧参考1个前向参考帧；</li>
<li>低延时；</li>
</ul>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/gop17.png" alt="gop17" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/gop18.png" alt="gop18" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="长期参考帧">长期参考帧<a href="#长期参考帧" class="hash-link" aria-label="长期参考帧的直接链接" title="长期参考帧的直接链接">​</a></h4>
<p>用户可指定长期参考帧的周期和参考长期参考帧的周期，如下图所示：</p>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/reference_frame.png" alt="reference_frame" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="intra-refresh">Intra Refresh<a href="#intra-refresh" class="hash-link" aria-label="Intra Refresh的直接链接" title="Intra Refresh的直接链接">​</a></h4>
<p>Intra
Refresh模式通过在非I帧内部周期性的插入帧内编码的MB/CTU来提高容错性。它能够为解码器提供更多的修复点来避免时域错误造成的图像损坏。用户可以指定MB/CTU的连续行数、列数或者步长来强制编码器插入帧内编码单元，用户还可指定帧内编码单元的大小由编码器内部决定哪一块需要帧内编码。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="码率控制">码率控制<a href="#码率控制" class="hash-link" aria-label="码率控制的直接链接" title="码率控制的直接链接">​</a></h4>
<p>MediaCodec支持对H264、H265和MJPEG协议的码率控制，分别支持H264、H265编码通道的CBR、VBR、AVBR、FixQp和QpMap五种码率控制方式，以及支持MJPEG编码通道的FixQp码率控制方式。CBR能够保证整体的编码码率稳定；VBR则是保证编码图像的质量稳定；而AVBR会兼顾码率和图像质量，产生码率和图像质量相对稳定的码流；FixQp则是固定每一个I帧、P帧的QP值；QPMAP则是为一帧图像中的每一个块指定QP值，其中H265块大小为32x32，H264块大小为16x16。</p>
<p>对于CBR和AVBR来说，编码器内部会为每一帧图片找到合适的QP值，从而保证恒定码率。编码器内部支持三种级别的码率控制，分别为帧级别、CTU/MB级别和subCTU/subMB级别。其中帧级别的控制主要会根据目标码率为每一帧图片产生一个QP值，从而保证码率恒定；CTU/MB级别的控制则根据每一个64x64的CTU或16x16的MB的目标码率为每个block产生一个QP值，能够得到更好的码率控制，但是频繁的QP值调整会造成图像质量不稳定的问题；subCTU/subMB级别的控制则为每一个32x32的subCTU或8x8的subMB产生一个QP值，其中复杂的块会得到较高的QP值，静态的块则会得到较低的QP值，因为相比于复杂的区域人眼对于静态的区域更敏感，复杂和静态区域的检测主要依赖于内部硬件模块，这个级别控制主要是为了提高主观图像质量同时保证码率恒定，该模式控制下SSIM得分较高，但是PSNR得分会降低。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="roi">ROI<a href="#roi" class="hash-link" aria-label="ROI的直接链接" title="ROI的直接链接">​</a></h4>
<p>ROI编码的实现依赖于和QPMAP类似，需要用户按照光栅扫描的方向为每一个块设定QP值，如下图：</p>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/roi_map.png" alt="roi_map" class="img_ev3q"></p>
<p>对于H264编码来说，每一个块的大小为16x16，而H265中则为32x32。在ROI
map表中，每一个QP值占用一个字节，大小为0~51。ROI编码可以和CBR和AVBR一起工作，当不使能CBR或AVBR时，每个块区域的实际QP值就为ROI
map中指定的值，当使能CBR或AVBR时，则每个块区域的实际值由以下公式得到：</p>
<p>QP(i) = MQP(i)+ RQP(i) - ROIAvgQP</p>
<p>其中MQP为ROI map中的值， RQP为编码器内部码率控制得到的值， ROIAvaQP为ROI
map中QP的平均值。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="输入输出buffer管理">输入输出buffer管理<a href="#输入输出buffer管理" class="hash-link" aria-label="输入输出buffer管理的直接链接" title="输入输出buffer管理的直接链接">​</a></h4>
<p>MediaCodec的buffer包括输入和输出buffer两种，一般情况下，这些buffer会由MediaCodec通过ION接口统一分配，用户不需要关心buffer的分配，只需要在操作buffer前执行dequeue操作获取空闲的buffer，处理完后执行queue操作返还该buffer。但是为了减少某些情况下buffer的拷贝操作，比如PYM的输出buffer用来编码时，该buffer是由PYM内部通过ION分配，可直接作为MediaCodec的输入buffer，因此MediaCodec还支持编码时的输入buffer由用户分配，但是用户必须通过ION接口分配物理连续的buffer，还需要在MediaCodec配置前指定media_codec_context_t中的external_frame_buf变量。需要注意的是，当用户指定输入buffer不需要MediaCodec分配之后，在buffer操作时，用户仍然需要执行dequeue操作获取队列信息，然后对队列中的信息进行赋值（主要是虚拟地址和物理地址），再执行queue操作。</p>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/buffer.png" alt="buffer" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="帧率控制">帧率控制<a href="#帧率控制" class="hash-link" aria-label="帧率控制的直接链接" title="帧率控制的直接链接">​</a></h4>
<p>MediaCodec内部目前不支持帧率控制，当用户不使用hb_mm_mc_set_camera接口使能VIO和MediaCodec的直接交互时，用户可自行控制buffer的输入帧率；当用户使能VIO和MediaCodec的交互后，用户不需要控制输入buffer，只需要操作输出buffer，此时MediaCodec内部也不会对输入buffer进行帧率控制，当编码出现卡顿或者输入buffer队列满等情况时，MediaCodec会等待队列控线后再次操作。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="帧skip设置">帧Skip设置<a href="#帧skip设置" class="hash-link" aria-label="帧Skip设置的直接链接" title="帧Skip设置的直接链接">​</a></h4>
<p>用户可调用hb_mm_mc_skip_pic设置下一次queue操作输入的图像的编码模式为skip模式，该模式只对非I帧编码有效；skip模式下编码器内部会忽略输入帧，而是利用上一帧的重构帧生成该次输入的的重构帧，输入帧则被编码成P帧。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="jpeg编解码限制">JPEG编解码限制<a href="#jpeg编解码限制" class="hash-link" aria-label="JPEG编解码限制的直接链接" title="JPEG编解码限制的直接链接">​</a></h4>
<ul>
<li>JPEG/MJPEG编码 时，当输入为yuv420和yuv422格式时，要求输入的宽16对齐，输入的高8对齐，当输入为yuv440、yuv444和yuv400格式时，要求输入的宽和高8对齐，如果同时crop，要求输入的x和y坐标8对齐；</li>
<li>JPEG/MJPEG编码同时旋转90/270，当输入为yuv420格式时，要求输入的宽16对齐，高8对齐，当输入的格式为yuv422和yuv440时，要求输入的宽16对齐，输入的高16对齐，当输入的格式为yuv444和yuv400时，要求输入的宽和高8对齐，如果同时crop，当输入为yuv420格式时，要求crop的宽16对齐，</li>
</ul>
<p>crop的高8对齐，当输入的格式为yuv422和yuv440时，要求crop的宽16对齐，crop的高16对齐，当输入的格式为yuv444和yuv400时，要求crop的宽和高8对齐；</p>
<ul>
<li>JPEG/MJPEG编码同时旋转90/270，当输入格式为yuv422格式时，旋转后的格式会变成yuv440，当输入格式为yuv440格式时，旋转后的格式变成yuv422；</li>
<li>JPEG/MJPEG解码同时旋转或镜像时，要求输出的yuv格式需要和输入的图像格式一致，但是YUV422格式的JPEG/MJPEG旋转90/270解码时，要求输出的格式为YUV440p/YUYV/YVYU/UYVY/VYUY；</li>
<li>JPEG/MJPEG解码时，旋转或镜像不能和Crop同时工作；</li>
<li>JPEG/MJPEG解码时，输出buffer的宽高要求和输入格式的MCU</li>
</ul>
<p>width和height对齐，如果使能了Crop，crop的参数（包括起始坐标和宽高）需要和输入格式的MCU
width和height对齐；（MCU size for 420: 16x16, 422: 16x8, 440: 8x16, 400: 8x8, 444: 8x8.）</p>
<ul>
<li>JPEG/MJPEG解码时，输出格式为Packed
YUV444，要求输入格式为YUV444格式；</li>
<li>JPEG/MJPEG解码只支持MC_FEEDING_MODE_FRAME_SIZE模式；</li>
<li>JPEG编码时，如果用户指定bitstream buffer得size，需要额外分配4k大小。</li>
<li>JPEG编码时，由于编码器内部处理以16x16为单元做编码处理，当待编码数据为非16x16对齐时，编码完的数据最后一部分填 充的部分会存在差异，但是不会影响有效数据，这个是硬件限制；因此做md5比较时需要注意这点。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="api参考">API参考<a href="#api参考" class="hash-link" aria-label="API参考的直接链接" title="API参考的直接链接">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_get_descriptor">hb_mm_mc_get_descriptor<a href="#hb_mm_mc_get_descriptor" class="hash-link" aria-label="hb_mm_mc_get_descriptor的直接链接" title="hb_mm_mc_get_descriptor的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>const
media_codec_descriptor_t*hb_mm_mc_get_descriptor(media_codec_id_t
codec_id);</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_id_t codec_id：表示codec类型</li>
</ul>
<p>【返回值】</p>
<ul>
<li>非空：codec描述信息</li>
<li>NULL：表示查询不到该codec id对应的描述符</li>
</ul>
<p>【功能描述】</p>
<p>根据codec_id获取MediaCodec支持的codec信息，信息包括codec名字，详细描述，MIME类型以及codec支持的profile类型等。</p>
<p>【示例代码】</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &quot;hb_media_codec.h&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &quot;hb_media_error.h&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main(int argc, char *argv[])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const media_codec_descriptor_t *desc = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    desc = hb_mm_mc_get_descriptor(MEDIA_CODEC_ID_H265);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_get_default_context">hb_mm_mc_get_default_context<a href="#hb_mm_mc_get_default_context" class="hash-link" aria-label="hb_mm_mc_get_default_context的直接链接" title="hb_mm_mc_get_default_context的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_get_default_context(media_codec_id_t codec_id,
hb_bool encoder, media_codec_context_t *context)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_id_t codec_id：表示codec类型</li>
<li>[IN] hb_bool encoder：指定codec是编码器还是解码器</li>
<li>[OUT] media_codec_context_t
*context：指定codec类型默认的context</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS： 无效参数</li>
</ul>
<p>【功能描述】</p>
<p>获取指定的codec的默认属性。</p>
<p>【示例代码】</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &quot;hb_media_codec.h&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &quot;hb_media_error.h&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main(int argc, char *argv[])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_context_t context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memset(&amp;context, 0x00, sizeof(context));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_get_default_context(MEDIA_CODEC_ID_H265, 1, &amp;context)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_initialize">hb_mm_mc_initialize<a href="#hb_mm_mc_initialize" class="hash-link" aria-label="hb_mm_mc_initialize的直接链接" title="hb_mm_mc_initialize的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_initialize(media_codec_context_t *context)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INSUFFICIENT_RES：内部内存资源不足</li>
<li>HB_MEDIA_ERR_NO_FREE_INSTANCE：没有可用的instance（Video最多32个，MJPEG/JPEG最多64个，Audio最多32个）</li>
</ul>
<p>【功能描述】</p>
<p>初始化编码或解码器，调用成功后MediaCodec进入MEDIA_CODEC_STATE_INITIALIZED状态。</p>
<p>【示例代码】</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &quot;hb_media_codec.h&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &quot;hb_media_error.h&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static Uint64 osal_gettime(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct timespec tp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    clock_gettime(CLOCK_MONOTONIC, &amp;tp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return ((Uint64)tp.tv_sec*1000 + tp.tv_nsec/1000000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct MediaCodecTestContext {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_context_t *context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char *inputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char *outputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} MediaCodecTestContext;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct AsyncMediaCtx {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_context_t *ctx;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    FILE *inFile;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    FILE *outFile;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int lastStream;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Uint64 startTime;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int32_t duration;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} AsyncMediaCtx;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static void on_encoder_input_buffer_available(hb_ptr userdata,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">media_codec_buffer_t *inputBuffer) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    AsyncMediaCtx *asyncCtx = (AsyncMediaCtx *)userdata;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Int noMoreInput = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Uint64 curTime = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!noMoreInput) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        curTime = osal_gettime();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if ((curTime - asyncCtx-&gt;startTime)/1000 &lt; (uint32_t)asyncCtx-&gt;duration) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ret = fread(inputBuffer-&gt;vframe_buf.vir_ptr[0], 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            inputBuffer-&gt;vframe_buf.size, asyncCtx-&gt;inFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ret &lt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if(fseek(asyncCtx-&gt;inFile, 0, SEEK_SET)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                printf(&quot;Failed to rewind input filen&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ret = fread(inputBuffer-&gt;vframe_buf.vir_ptr[0], 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                inputBuffer-&gt;vframe_buf.size, asyncCtx-&gt;inFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (ret &lt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    printf(&quot;Failed to read input filen&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf(&quot;%s There is no more input data!n&quot;, TAG);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        inputBuffer-&gt;vframe_buf.frame_end = TRUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        noMoreInput = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        inputBuffer-&gt;vframe_buf.frame_end = TRUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        inputBuffer-&gt;vframe_buf.size = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static void on_encoder_output_buffer_available(hb_ptr userdata,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">media_codec_buffer_t *outputBuffer,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">media_codec_output_buffer_info_t *extraInfo) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    AsyncMediaCtx *asyncCtx = (AsyncMediaCtx *)userdata;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_265_output_stream_info_t info = extraInfo-&gt;video_stream_info;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fwrite(outputBuffer-&gt;vstream_buf.vir_ptr,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    outputBuffer-&gt;vstream_buf.size, 1, asyncCtx-&gt;outFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (outputBuffer-&gt;vstream_buf.stream_end) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf(&quot;There is no more output data!n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        asyncCtx-&gt;lastStream = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static void on_encoder_media_codec_message(hb_ptr userdata, hb_s32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       error) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    AsyncMediaCtx *asyncCtx = (AsyncMediaCtx *)userdata;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (error) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        asyncCtx-&gt;lastStream = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf(&quot;ERROR happened!n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static void on_vlc_buffer_message(hb_ptr userdata, hb_s32 * vlc_buf)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MediaCodecTestContext *ctx = (MediaCodecTestContext *)userdata;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    printf(&quot;%s %s VLC Buffer size = %d; Reset to %d.n&quot;, TAG,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    __FUNCTION__,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    *vlc_buf, ctx-&gt;vlc_buf_size);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    *vlc_buf = ctx-&gt;vlc_buf_size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static void do_async_encoding(void *arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    FILE *outFile;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    FILE *inFile;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int step = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    AsyncMediaCtx asyncCtx;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MediaCodecTestContext *ctx = (MediaCodecTestContext *)arg;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_context_t *context = ctx-&gt;context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char *inputFileName = ctx-&gt;inputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char *outputFileName = ctx-&gt;outputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_state_t state = MEDIA_CODEC_STATE_NONE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    inFile = fopen(inputFileName, &quot;rb&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!inFile) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    outFile = fopen(outputFileName, &quot;wb&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!outFile) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memset(&amp;asyncCtx, 0x00, sizeof(AsyncMediaCtx));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    asyncCtx.ctx = context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    asyncCtx.inFile = inFile;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    asyncCtx.outFile = outFile;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    asyncCtx.lastStream = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    asyncCtx.duration = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    asyncCtx.startTime = osal_gettime();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_initialize(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_callback_t callback;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    callback.on_input_buffer_available =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    on_encoder_input_buffer_available;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    callback.on_output_buffer_available =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    on_encoder_output_buffer_available;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    callback.on_media_codec_message = on_encoder_media_codec_message;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_set_callback(context, &amp;callback, &amp;asyncCtx);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_callback_t callback2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    callback2.on_vlc_buffer_message = on_vlc_buffer_message;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;vlc_buf_size &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = hb_mm_mc_set_vlc_buffer_listener(context, &amp;callback2, ctx);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_configure(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_av_codec_startup_params_t startup_params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    startup_params.video_enc_startup_params.receive_frame_number = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_start(context, &amp;startup_params);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while(!asyncCtx.lastStream) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sleep(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_mm_mc_stop(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_mm_mc_release(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    context = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ERR:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_mm_mc_get_state(context, &amp;state);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (context &amp;&amp; state !=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_STATE_UNINITIALIZED) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        hb_mm_mc_stop(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        hb_mm_mc_release(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (inFile)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fclose(inFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (outFile)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fclose(outFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main(int argc, char *argv[])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char outputFileName[MAX_FILE_PATH] = &quot;./tmp.yuv&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char inputFileName[MAX_FILE_PATH] = &quot;./output.h265&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_codec_enc_params_t *params = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_context_t context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memset(&amp;context, 0x00, sizeof(media_codec_context_t));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    context.codec_id = MEDIA_CODEC_ID_H265;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    context.encoder = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params = &amp;context.video_enc_params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;width = 640;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;height = 480;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;pix_fmt = MC_PIXEL_FORMAT_YUV420P;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;frame_buf_count = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;external_frame_buf = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;bitstream_buf_count = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rc_params.mode = MC_AV_RC_MODE_H265CBR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_get_rate_control_config(&amp;context, &amp;params-&gt;rc_params);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rc_params.h265_cbr_params.bit_rate = 5000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rc_params.h265_cbr_params.frame_rate = 30;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rc_params.h265_cbr_params.intra_period = 30;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;gop_params.decoding_refresh_type = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;gop_params.gop_preset_idx = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rot_degree = MC_CCW_0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;mir_direction = MC_DIRECTION_NONE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;frame_cropping_flag = FALSE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MediaCodecTestContext ctx;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memset(&amp;ctx, 0x00, sizeof(ctx));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ctx.context = &amp;context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ctx.inputFileName = inputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ctx.outputFileName = outputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    do_async_encoding(&amp;ctx);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_set_callback">hb_mm_mc_set_callback<a href="#hb_mm_mc_set_callback" class="hash-link" aria-label="hb_mm_mc_set_callback的直接链接" title="hb_mm_mc_set_callback的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_set_callback(media_codec_context_t *context,
const media_codec_callback_t *callback, hb_ptr userdata)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[IN] const media_codec_callback_t *callback：用户回调函数</li>
<li>[IN] hb_ptr
userdata：用户数据指针，该值会在回调函数被调用时作为入参传入</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
</ul>
<p>【功能描述】</p>
<p>设置回调函数指针，调用该函数后MediaCodec会进入异步工作模式。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_initialize">hb_mm_mc_initialize</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_configure">hb_mm_mc_configure<a href="#hb_mm_mc_configure" class="hash-link" aria-label="hb_mm_mc_configure的直接链接" title="hb_mm_mc_configure的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_configure(media_codec_context_t *context)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INSUFFICIENT_RES：内部内存资源不足</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
</ul>
<p>【功能描述】</p>
<p>根据输入信息配置编码或解码器，调用成功后MediaCodec进入MEDIA_CODEC_STATE_CONFIGURED状态。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_initialize">hb_mm_mc_initialize</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_start">hb_mm_mc_start<a href="#hb_mm_mc_start" class="hash-link" aria-label="hb_mm_mc_start的直接链接" title="hb_mm_mc_start的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_start(media_codec_context_t *context, const
mc_av_codec_startup_params_t *info)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[IN] mc_av_codec_startup_params_t
*info：指定音视频编解码时的启动参数</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INSUFFICIENT_RES：内部内存资源不足</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
</ul>
<p>【功能描述】</p>
<p>启动编码/解码流程，MediaCodec将创建编解码实例、设置序列或解析数据流、注册Framebuffer、编码头信息等，调用成功后MediaCodec进入MEDIA_CODEC_STATE_STARTED状态。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_initialize">hb_mm_mc_initialize</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_stop">hb_mm_mc_stop<a href="#hb_mm_mc_stop" class="hash-link" aria-label="hb_mm_mc_stop的直接链接" title="hb_mm_mc_stop的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_stop(media_codec_context_t *context)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
</ul>
<p>【功能描述】</p>
<p>停止  编码/解码流程，退出所有子线程并释放相关资源，调用成功后MediaCodec回到MEDIA_CODEC_STATE_INITIALIZED状态。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_initialize">hb_mm_mc_initialize</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_pause">hb_mm_mc_pause<a href="#hb_mm_mc_pause" class="hash-link" aria-label="hb_mm_mc_pause的直接链接" title="hb_mm_mc_pause的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_pause(media_codec_context_t *context)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
</ul>
<p>【功能描述】</p>
<p>停止编码/解码流程，暂停所有子线程，调用成功后MediaCodec进入到MEDIA_CODEC_STATE_PAUSED状态。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_queue_input_buffer">hb_mm_mc_queue_input_buffer</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_flush">hb_mm_mc_flush<a href="#hb_mm_mc_flush" class="hash-link" aria-label="hb_mm_mc_flush的直接链接" title="hb_mm_mc_flush的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_flush(media_codec_context_t *context)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
</ul>
<p>【功能描述】</p>
<p>刷新输入输出buffer缓冲区，强制编码器/解码器刷新未处理的输入输出buffer，函数调用后MediaCodec进入MEDIA_CODEC_STATE_FLUSHING状态，操作成功后，MediaCodec会再次进入MEDIA_CODEC_STATE_STARTED状  态。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_queue_input_buffer">hb_mm_mc_queue_input_buffer</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_release">hb_mm_mc_release<a href="#hb_mm_mc_release" class="hash-link" aria-label="hb_mm_mc_release的直接链接" title="hb_mm_mc_release的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_release(media_codec_context_t *context)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
</ul>
<p>【功能描述】</p>
<p>释放MediaCodec内部所有资源，用户需要在调用该函数前调用hb_mm_mc_stop来停止编解码，操作成功后MediaCodec进入MEDIA_CODEC_STATE_UNINITIALIZED状态。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_initialize">hb_mm_mc_initialize</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_get_state">hb_mm_mc_get_state<a href="#hb_mm_mc_get_state" class="hash-link" aria-label="hb_mm_mc_get_state的直接链接" title="hb_mm_mc_get_state的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_get_state(media_codec_context_t *context,
media_codec_state_t *state)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[OUT] media_codec_state_t *state：MediaCodec当前状态</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>获取MediaCodec当前的状态。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_initialize">hb_mm_mc_initialize</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_get_status">hb_mm_mc_get_status<a href="#hb_mm_mc_get_status" class="hash-link" aria-label="hb_mm_mc_get_status的直接链接" title="hb_mm_mc_get_status的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_get_status(media_codec_context_t *context,
mc_inter_status_t *status)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[OUT] mc_inter_status_t *status：MediaCodec当前内部状态</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>获取MediaCodec当前内部的状态信息。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_fd">hb_mm_mc_get_fd</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_queue_input_buffer">hb_mm_mc_queue_input_buffer<a href="#hb_mm_mc_queue_input_buffer" class="hash-link" aria-label="hb_mm_mc_queue_input_buffer的直接链接" title="hb_mm_mc_queue_input_buffer的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_queue_input_buffer(media_codec_context_t
*context, media_codec_buffer_t *buffer, hb_s32 timeout)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[IN] media_codec_buffer_t *buffer：输入的buffer信息</li>
<li>[IN] hb_s32 timeout：超时时间</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
<li>HB_MEDIA_ERR_INVALID_BUFFER：无效buffer</li>
<li>HB_MEDIA_ERR_WAIT_TIMEOUT：等待超时</li>
</ul>
<p>【功能描述】</p>
<p>填充需要处理的buffer到MediaCodec中。</p>
<p>【示例代码】</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &quot;hb_media_codec.h&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &quot;hb_media_error.h&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct MediaCodecTestContext {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_context_t *context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char *inputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char *outputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int32_t duration; // s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} MediaCodecTestContext;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Uint64 osal_gettime(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct timespec tp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    clock_gettime(CLOCK_MONOTONIC, &amp;tp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return ((Uint64)tp.tv_sec*1000 + tp.tv_nsec/1000000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static void do_sync_encoding(void *arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    FILE *inFile;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    FILE *outFile;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int noMoreInput = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int lastStream = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Uint64 lastTime = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Uint64 curTime = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int needFlush = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MediaCodecTestContext *ctx = (MediaCodecTestContext *)arg;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_context_t *context = ctx-&gt;context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char *inputFileName = ctx-&gt;inputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char *outputFileName = ctx-&gt;outputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_state_t state = MEDIA_CODEC_STATE_NONE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    inFile = fopen(inputFileName, &quot;rb&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!inFile) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    outFile = fopen(outputFileName, &quot;wb&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!outFile) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //get current time</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    lastTime = osal_gettime();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_initialize(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_configure(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_av_codec_startup_params_t startup_params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    startup_params.video_enc_startup_params.receive_frame_number = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_start(context, &amp;startup_params);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_pause(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    do {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!noMoreInput) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            media_codec_buffer_t inputBuffer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            memset(&amp;inputBuffer, 0x00, sizeof(media_codec_buffer_t));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ret = hb_mm_mc_dequeue_input_buffer(context, &amp;inputBuffer, 100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                curTime = osal_gettime();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if ((curTime - lastTime)/1000 &lt; (uint32_t)ctx-&gt;duration) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ret = fread(inputBuffer.vframe_buf.vir_ptr[0], 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    inputBuffer.vframe_buf.size, inFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (ret &lt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if(fseek(inFile, 0, SEEK_SET)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            printf(&quot;Failed to rewind input filen&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        ret = fread(inputBuffer.vframe_buf.vir_ptr[0], 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        inputBuffer.vframe_buf.size, inFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if (ret &lt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            printf(&quot;Failed to read input filen&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            printf(&quot;Time up(%d)n&quot;,ctx-&gt;duration);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            printf(&quot;There is no more input data!n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            inputBuffer.vframe_buf.frame_end = TRUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            noMoreInput = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = hb_mm_mc_queue_input_buffer(context, &amp;inputBuffer, 100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            printf(&quot;Queue input buffer fail.n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ret != (int32_t)HB_MEDIA_ERR_WAIT_TIMEOUT) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                printf(&quot;Dequeue input buffer fail.n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!lastStream) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            media_codec_buffer_t outputBuffer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            media_codec_output_buffer_info_t info;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            memset(&amp;outputBuffer, 0x00, sizeof(media_codec_buffer_t));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            memset(&amp;info, 0x00, sizeof(media_codec_output_buffer_info_t));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ret = hb_mm_mc_dequeue_output_buffer(context, &amp;outputBuffer, &amp;info,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            3000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!ret &amp;&amp; outFile) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                fwrite(outputBuffer.vstream_buf.vir_ptr,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                outputBuffer.vstream_buf.size, 1, outFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ret = hb_mm_mc_queue_output_buffer(context, &amp;outputBuffer, 100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    printf(&quot;Queue output buffer fail.n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (outputBuffer.vstream_buf.stream_end) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    printf(&quot;There is no more output data!n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    lastStream = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (ret != (int32_t)HB_MEDIA_ERR_WAIT_TIMEOUT) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    printf(&quot;Dequeue output buffer fail.n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (needFlush) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ret = hb_mm_mc_flush(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            needFlush = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }while(TRUE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_mm_mc_stop(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_mm_mc_release(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    context = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ERR:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_mm_mc_get_state(context, &amp;state);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (context &amp;&amp; state !=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        MEDIA_CODEC_STATE_UNINITIALIZED) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        hb_mm_mc_stop(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        hb_mm_mc_release(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (inFile)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fclose(inFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (outFile)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fclose(outFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main(int argc, char *argv[])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char outputFileName[MAX_FILE_PATH] = &quot;./tmp.yuv&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char inputFileName[MAX_FILE_PATH] = &quot;./output.stream&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_codec_enc_params_t *params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_context_t context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memset(&amp;context, 0x00, sizeof(media_codec_context_t));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    context.codec_id = MEDIA_CODEC_ID_H265;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    context.encoder = TRUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params = &amp;context.video_enc_params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;width = 640;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;height = 480;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;pix_fmt = MC_PIXEL_FORMAT_YUV420P;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;frame_buf_count = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;external_frame_buf = FALSE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;bitstream_buf_count = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rc_params.mode = MC_AV_RC_MODE_H265CBR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_get_rate_control_config(&amp;context, &amp;params-&gt;rc_params);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rc_params.h265_cbr_params.bit_rate = 5000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rc_params.h265_cbr_params.frame_rate = 30;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rc_params.h265_cbr_params.intra_period = 30;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;gop_params.decoding_refresh_type = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;gop_params.gop_preset_idx = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rot_degree = MC_CCW_0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;mir_direction = MC_DIRECTION_NONE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;frame_cropping_flag = FALSE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MediaCodecTestContext ctx;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memset(&amp;ctx, 0x00, sizeof(ctx));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ctx.context = &amp;context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ctx.inputFileName = inputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ctx.outputFileName = outputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ctx.duration = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    do_sync_encoding(&amp;ctx);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_dequeue_input_buffer">hb_mm_mc_dequeue_input_buffer<a href="#hb_mm_mc_dequeue_input_buffer" class="hash-link" aria-label="hb_mm_mc_dequeue_input_buffer的直接链接" title="hb_mm_mc_dequeue_input_buffer的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_dequeue_input_buffer(media_codec_context_t
*context, media_codec_buffer_t *buffer, hb_s32 timeout)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[IN] hb_s32 timeout：超时时间</li>
<li>[OUT] media_codec_buffer_t *buffer：输入的buffer信息</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
<li>HB_MEDIA_ERR_INVALID_BUFFER：无效buffer</li>
<li>HB_MEDIA_ERR_WAIT_TIMEOUT：等待超时</li>
</ul>
<p>【功能描述】</p>
<p>获取输入的buffer。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_queue_input_buffer">hb_mm_mc_queue_input_buffer</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_queue_output_buffer">hb_mm_mc_queue_output_buffer<a href="#hb_mm_mc_queue_output_buffer" class="hash-link" aria-label="hb_mm_mc_queue_output_buffer的直接链接" title="hb_mm_mc_queue_output_buffer的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_queue_output_buffer(media_codec_context_t
*context, media_codec_buffer_t *buffer, hb_s32 timeout)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[IN] media_codec_buffer_t *buffer：输出的buffer信息</li>
<li>[IN] hb_s32 timeout：超时时间</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
<li>HB_MEDIA_ERR_INVALID_BUFFER：无效buffer</li>
<li>HB_MEDIA_ERR_WAIT_TIMEOUT：等待超时</li>
</ul>
<p>【功能描述】</p>
<p>返还处理完的output buffer到MediaCodec中。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_queue_input_buffer">hb_mm_mc_queue_input_buffer</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_dequeue_output_buffer">hb_mm_mc_dequeue_output_buffer<a href="#hb_mm_mc_dequeue_output_buffer" class="hash-link" aria-label="hb_mm_mc_dequeue_output_buffer的直接链接" title="hb_mm_mc_dequeue_output_buffer的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_dequeue_output_buffer(media_codec_context_t
*context, media_codec_buffer_t *buffer,
media_codec_output_buffer_info_t *info, hb_s32 timeout)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[IN] hb_s32 timeout：超时时间</li>
<li>[OUT] media_codec_buffer_t *buffer：输出的buffer信息</li>
<li>[IN] media_codec_output_buffer_info_t
*info：输出数据流的信息</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
<li>HB_MEDIA_ERR_INVALID_BUFFER：无效buffer</li>
<li>HB_MEDIA_ERR_WAIT_TIMEOUT：等待超时</li>
</ul>
<p>【功能描述】</p>
<p>获取输出的buffer。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_queue_input_buffer">hb_mm_mc_queue_input_buffer</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_get_longterm_ref_mode">hb_mm_mc_get_longterm_ref_mode<a href="#hb_mm_mc_get_longterm_ref_mode" class="hash-link" aria-label="hb_mm_mc_get_longterm_ref_mode的直接链接" title="hb_mm_mc_get_longterm_ref_mode的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_get_longterm_ref_mode(media_codec_context_t
*context, mc_video_longterm_ref_mode_t *params)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[OUT] mc_video_longterm_ref_mode_t
*params：长期参考帧模式参数</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>获取长期参考帧模式的参数，适用于H264/H265。</p>
<p>【示例代码】</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &quot;hb_media_codec.h&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &quot;hb_media_error.h&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">typedef enum ENC_CONFIG_MESSAGE {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_NONE = (0 &lt;&lt; 0),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_LONGTERM_REF = (1 &lt;&lt; 0),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_INTRA_REFRESH = (1 &lt;&lt; 1),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_RATE_CONTROL = (1 &lt;&lt; 2),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_DEBLK_FILTER = (1 &lt;&lt; 3),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_SAO = (1 &lt;&lt; 4),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_ENTROPY = (1 &lt;&lt; 5),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_VUI_TIMING = (1 &lt;&lt; 6),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_SLICE = (1 &lt;&lt; 7),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_REQUEST_IDR = (1 &lt;&lt; 8),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_SKIP_PIC = (1 &lt;&lt; 9),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_SMART_BG = (1 &lt;&lt; 10),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_MONOCHROMA = (1 &lt;&lt; 11),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_PRED_UNIT = (1 &lt;&lt; 12),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_TRANSFORM = (1 &lt;&lt; 13),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_ROI = (1 &lt;&lt; 14),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_MODE_DECISION = (1 &lt;&lt; 15),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_USER_DATA = (1 &lt;&lt; 16),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_MJPEG = (1 &lt;&lt; 17),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_JPEG = (1 &lt;&lt; 18),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_CAMERA = (1 &lt;&lt; 19),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_INSERT_USERDATA = (1 &lt;&lt; 20),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_VUI = (1 &lt;&lt; 21),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_3DNR = (1 &lt;&lt; 22),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_REQUEST_IDR_HEADER = (1 &lt;&lt; 23),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_ENABLE_IDR = (1 &lt;&lt; 24),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_TOTAL = (1 &lt;&lt; 25),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} ENC_CONFIG_MESSAGE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct MediaCodecTestContext {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_context_t *context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char *inputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char *outputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int32_t duration; // s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_MESSAGE message;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_longterm_ref_mode_t ref_mode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_rate_control_params_t rc_params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_intra_refresh_params_t intra_refr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_deblk_filter_params_t deblk_filter;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_h265_sao_params_t sao;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_h264_entropy_params_t entropy;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_vui_params_t vui;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_vui_timing_params_t vui_timing;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_slice_params_t slice;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_3dnr_enc_params_t noise_reduction;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_smart_bg_enc_params_t smart_bg;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_pred_unit_params_t pred_unit;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_transform_params_t transform;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_roi_params_t roi;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_mode_decision_params_t mode_decision;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} MediaCodecTestContext;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Uint64 osal_gettime(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct timespec tp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    clock_gettime(CLOCK_MONOTONIC, &amp;tp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return ((Uint64)tp.tv_sec*1000 + tp.tv_nsec/1000000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">uint8_t uuid[] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;dc45e9bd-e6d948b7-962cd820-d923eeef+HorizonAI&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static void set_message(MediaCodecTestContext *ctx) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_context_t *context = ctx-&gt;context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_longterm_ref_mode_t *ref_mode = &amp;ctx-&gt;ref_mode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_mm_mc_get_longterm_ref_mode(context, ref_mode);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ref_mode-&gt;use_longterm = TRUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ref_mode-&gt;longterm_pic_using_period = 20;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ref_mode-&gt;longterm_pic_period = 30;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //ctx-&gt;message = ENC_CONFIG_LONGTERM_REF;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;message &amp; ENC_CONFIG_LONGTERM_REF) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = hb_mm_mc_set_longterm_ref_mode(context, &amp;ctx-&gt;ref_mode);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (ctx-&gt;message &amp; ENC_CONFIG_INTRA_REFRESH) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">hb_mm_mc_get_intra_refresh_config(context, &amp;ctx-&gt;intra_refr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = hb_mm_mc_set_intra_refresh_config(context, &amp;ctx-&gt;intra_refr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (ctx-&gt;message &amp; ENC_CONFIG_SAO) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">hb_mm_mc_get_sao_config(context, &amp;ctx-&gt;sao);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = hb_mm_mc_set_sao_config(context, &amp;ctx-&gt;sao);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (ctx-&gt;message &amp; ENC_CONFIG_ENTROPY) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">hb_mm_mc_get_entropy_config(context, &amp;ctx-&gt;entropy);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = hb_mm_mc_set_entropy_config(context, &amp;ctx-&gt;entropy);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (ctx-&gt;message &amp; ENC_CONFIG_VUI) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">hb_mm_mc_get_vui_config(context, &amp;ctx-&gt;vui);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_set_vui_config(context, &amp;ctx-&gt;vui);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (ctx-&gt;message &amp; ENC_CONFIG_VUI_TIMING) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">hb_mm_mc_get_vui_timing_config(context, &amp;ctx-&gt;vui_timing);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = hb_mm_mc_set_vui_timing_config(context, &amp;ctx-&gt;vui_timing);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_rate_control_params_t *rc_params = &amp;ctx-&gt;rc_params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    rc_params-&gt;mode = context-&gt;video_enc_params.rc_params.mode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_mm_mc_get_rate_control_config(context, rc_params);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    switch (rc_params-&gt;mode) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case MC_AV_RC_MODE_H264CBR:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h264_cbr_params.bit_rate = 5000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h264_cbr_params.intra_period = 60;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case MC_AV_RC_MODE_H264VBR:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h264_vbr_params.intra_qp = 20;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h264_vbr_params.intra_period = 30;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case MC_AV_RC_MODE_H264AVBR:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h264_avbr_params.intra_period = 15;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h264_avbr_params.intra_qp = 25;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h264_avbr_params.bit_rate = 2000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h264_avbr_params.vbv_buffer_size = 3000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h264_avbr_params.min_qp_I = 15;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h264_avbr_params.max_qp_I = 50;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h264_avbr_params.min_qp_P = 15;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h264_avbr_params.max_qp_P = 45;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h264_avbr_params.min_qp_B = 15;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h264_avbr_params.max_qp_B = 48;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h264_avbr_params.hvs_qp_enable = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h264_avbr_params.hvs_qp_scale = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h264_avbr_params.max_delta_qp = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h264_avbr_params.qp_map_enable = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case MC_AV_RC_MODE_H264FIXQP:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h264_fixqp_params.force_qp_I = 23;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h264_fixqp_params.force_qp_P = 23;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h264_fixqp_params.force_qp_B = 23;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h264_fixqp_params.intra_period = 23;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case MC_AV_RC_MODE_H264QPMAP:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case MC_AV_RC_MODE_H265CBR:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h265_cbr_params.bit_rate = 5000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h265_cbr_params.intra_period = 60;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case MC_AV_RC_MODE_H265VBR:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h265_vbr_params.intra_qp = 20;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h265_vbr_params.intra_period = 30;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case MC_AV_RC_MODE_H265AVBR:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h265_avbr_params.intra_period = 15;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h265_avbr_params.intra_qp = 25;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h265_avbr_params.bit_rate = 2000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h265_avbr_params.vbv_buffer_size = 3000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h265_avbr_params.min_qp_I = 15;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h265_avbr_params.max_qp_I = 50;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h265_avbr_params.min_qp_P = 15;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h265_avbr_params.max_qp_P = 45;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h265_avbr_params.min_qp_B = 15;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h265_avbr_params.max_qp_B = 48;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h265_avbr_params.hvs_qp_enable = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h265_avbr_params.hvs_qp_scale = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h265_avbr_params.max_delta_qp = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h265_avbr_params.qp_map_enable = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case MC_AV_RC_MODE_H265FIXQP:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h265_fixqp_params.force_qp_I = 23;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h265_fixqp_params.force_qp_P = 23;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h265_fixqp_params.force_qp_B = 23;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rc_params-&gt;h265_fixqp_params.intra_period = 23;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case MC_AV_RC_MODE_H265QPMAP:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    default:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //ctx-&gt;message = ENC_CONFIG_RATE_CONTROL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;message &amp; ENC_CONFIG_RATE_CONTROL) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = hb_mm_mc_set_rate_control_config(context, &amp;ctx-&gt;rc_params);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_deblk_filter_params_t *deblk_filter = &amp;ctx-&gt;deblk_filter;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_mm_mc_get_deblk_filter_config(context, deblk_filter);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (context-&gt;codec_id == MEDIA_CODEC_ID_H264) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        deblk_filter-&gt;h264_deblk.disable_deblocking_filter_idc = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        deblk_filter-&gt;h264_deblk.slice_alpha_c0_offset_div2 = 6;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        deblk_filter-&gt;h264_deblk.slice_beta_offset_div2 = 6;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        deblk_filter-&gt;h265_deblk.slice_deblocking_filter_disabled_flag = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        deblk_filter-&gt;h265_deblk.slice_beta_offset_div2 = 6;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        deblk_filter-&gt;h265_deblk.slice_tc_offset_div2 = 6;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        deblk_filter-&gt;h265_deblk.slice_loop_filter_across_slices_enabled_flag = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //ctx-&gt;message = ENC_CONFIG_DEBLK_FILTER;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;message &amp; ENC_CONFIG_DEBLK_FILTER) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = hb_mm_mc_set_deblk_filter_config(context, &amp;ctx-&gt;deblk_filter);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (context-&gt;codec_id == MEDIA_CODEC_ID_H264) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mc_h264_entropy_params_t *entropy = &amp;ctx-&gt;entropy;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        hb_mm_mc_get_entropy_config(context, entropy);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        entropy-&gt;entropy_coding_mode = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ctx-&gt;message = ENC_CONFIG_ENTROPY;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ctx-&gt;message &amp; ENC_CONFIG_ENTROPY) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ret = hb_mm_mc_set_entropy_config(context, &amp;ctx-&gt;entropy);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //ctx-&gt;message = ENC_CONFIG_SKIP_PIC;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;message &amp; ENC_CONFIG_SKIP_PIC) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = hb_mm_mc_skip_pic(context, 0), (int32_t)0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //ctx-&gt;message = ENC_CONFIG_REQUEST_IDR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;message &amp; ENC_CONFIG_REQUEST_IDR) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = hb_mm_mc_request_idr_frame(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_slice_params_t *slice = &amp;ctx-&gt;slice;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_mm_mc_get_slice_config(context, slice);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (context-&gt;codec_id == MEDIA_CODEC_ID_H264) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        slice-&gt;h264_slice.h264_slice_mode = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        slice-&gt;h264_slice.h264_slice_arg = 60;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        slice-&gt;h265_slice.h265_dependent_slice_mode = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        slice-&gt;h265_slice.h265_dependent_slice_arg = 80;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        slice-&gt;h265_slice.h265_independent_slice_mode = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        slice-&gt;h265_slice.h265_independent_slice_arg = 100;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //ctx-&gt;message = ENC_CONFIG_SLICE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;message &amp; ENC_CONFIG_SLICE) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = hb_mm_mc_set_slice_config(context, &amp;ctx-&gt;slice);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_smart_bg_enc_params_t *smart_bg = &amp;ctx-&gt;smart_bg;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_mm_mc_get_smart_bg_enc_config(context, smart_bg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    smart_bg-&gt;bg_detect_enable = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    smart_bg-&gt;bg_threshold_diff = 8;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    smart_bg-&gt;bg_threshold_mean_diff = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    smart_bg-&gt;bg_lambda_qp = 32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    smart_bg-&gt;bg_delta_qp = 3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    smart_bg-&gt;s2fme_disable = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //ctx-&gt;message = ENC_CONFIG_SMART_BG;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;message &amp; ENC_CONFIG_SMART_BG) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = hb_mm_mc_set_smart_bg_enc_config(context, &amp;ctx-&gt;smart_bg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_pred_unit_params_t *pred_unit = &amp;ctx-&gt;pred_unit;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_mm_mc_get_pred_unit_config(context, pred_unit);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (context-&gt;codec_id == MEDIA_CODEC_ID_H264) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pred_unit-&gt;h264_intra_pred.constrained_intra_pred_flag = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pred_unit-&gt;h265_pred_unit.intra_nxn_enable = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pred_unit-&gt;h265_pred_unit.constrained_intra_pred_flag = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pred_unit-&gt;h265_pred_unit.strong_intra_smoothing_enabled_flag = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pred_unit-&gt;h265_pred_unit.max_num_merge = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //ctx-&gt;message = ENC_CONFIG_PRED_UNIT;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;message &amp; ENC_CONFIG_PRED_UNIT) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = hb_mm_mc_set_pred_unit_config(context, &amp;ctx-&gt;pred_unit);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_transform_params_t *transform = &amp;ctx-&gt;transform;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_mm_mc_get_transform_config(context, transform);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (context-&gt;codec_id == MEDIA_CODEC_ID_H264) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        transform-&gt;h264_transform.transform_8x8_enable = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        transform-&gt;h264_transform.chroma_cb_qp_offset = 4;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        transform-&gt;h264_transform.chroma_cr_qp_offset = 3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        transform-&gt;h264_transform.user_scaling_list_enable = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        transform-&gt;h265_transform.chroma_cb_qp_offset = 6;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        transform-&gt;h265_transform.chroma_cr_qp_offset = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        transform-&gt;h265_transform.user_scaling_list_enable = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //ctx-&gt;message = ENC_CONFIG_TRANSFORM;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;message &amp; ENC_CONFIG_TRANSFORM) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = hb_mm_mc_set_transform_config(context, &amp;ctx-&gt;transform);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_roi_params_t *roi = &amp;ctx-&gt;roi;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_mm_mc_get_roi_config(context, roi);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    roi-&gt;roi_enable = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //ctx-&gt;message = ENC_CONFIG_ROI;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;message &amp; ENC_CONFIG_ROI) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = hb_mm_mc_set_roi_config(context, &amp;ctx-&gt;roi);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_mode_decision_params_t *mode_decision = &amp;ctx-&gt;mode_decision;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_mm_mc_get_mode_decision_config(context, mode_decision);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mode_decision-&gt;mode_decision_enable = FALSE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mode_decision-&gt;pu04_delta_rate = 76;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mode_decision-&gt;pu08_delta_rate = 80;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mode_decision-&gt;pu16_delta_rate = 86;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mode_decision-&gt;pu32_delta_rate = 87;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mode_decision-&gt;pu04_intra_planar_delta_rate = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mode_decision-&gt;pu04_intra_dc_delta_rate = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mode_decision-&gt;pu04_intra_angle_delta_rate = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mode_decision-&gt;pu08_intra_planar_delta_rate = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mode_decision-&gt;pu08_intra_dc_delta_rate = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mode_decision-&gt;pu08_intra_angle_delta_rate = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mode_decision-&gt;pu16_intra_planar_delta_rate = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mode_decision-&gt;pu16_intra_dc_delta_rate = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mode_decision-&gt;pu16_intra_angle_delta_rate = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mode_decision-&gt;pu32_intra_planar_delta_rate = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mode_decision-&gt;pu32_intra_dc_delta_rate = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mode_decision-&gt;pu32_intra_angle_delta_rate = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mode_decision-&gt;cu08_intra_delta_rate = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mode_decision-&gt;cu08_inter_delta_rate = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mode_decision-&gt;cu08_merge_delta_rate = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mode_decision-&gt;cu16_intra_delta_rate = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mode_decision-&gt;cu16_inter_delta_rate = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mode_decision-&gt;cu16_merge_delta_rate = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mode_decision-&gt;cu32_intra_delta_rate = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mode_decision-&gt;cu32_inter_delta_rate = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mode_decision-&gt;cu32_merge_delta_rate = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //ctx-&gt;message = ENC_CONFIG_MODE_DECISION;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;message &amp; ENC_CONFIG_MODE_DECISION) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = hb_mm_mc_set_mode_decision_config(context, &amp;ctx-&gt;mode_decision);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;message &amp; ENC_CONFIG_INSERT_USERDATA) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        hb_u32 length = sizeof(uuid)/sizeof(uuid[0]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = hb_mm_mc_insert_user_data(context, uuid, length);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (ctx-&gt;message &amp; ENC_CONFIG_3DNR) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">hb_mm_mc_get_3dnr_enc_config(context, &amp;ctx-&gt;noise_reduction);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = hb_mm_mc_set_3dnr_enc_config(context, &amp;ctx-&gt;noise_reduction);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;message &amp; ENC_CONFIG_ENABLE_IDR) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // disable idr frame first</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ctx-&gt;enable_idr_num) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ret = hb_mm_mc_enable_idr_frame(context, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;message &amp; ENC_CONFIG_REQUEST_IDR_HEADER) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = hb_mm_mc_request_idr_header(context, ctx-&gt;force_idr_header);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static void do_sync_encoding(void *arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    FILE *inFile;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    FILE *outFile;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int noMoreInput = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int lastStream = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Uint64 lastTime = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Uint64 curTime = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int needFlush = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MediaCodecTestContext *ctx = (MediaCodecTestContext *)arg;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_context_t *context = ctx-&gt;context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char *inputFileName = ctx-&gt;inputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char *outputFileName = ctx-&gt;outputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_state_t state = MEDIA_CODEC_STATE_NONE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    inFile = fopen(inputFileName, &quot;rb&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!inFile) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    outFile = fopen(outputFileName, &quot;wb&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!outFile) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //get current time</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    lastTime = osal_gettime();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_initialize(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_configure(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_av_codec_startup_params_t startup_params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    startup_params.video_enc_startup_params.receive_frame_number = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_start(context, &amp;startup_params);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_pause(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    do {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        set_message(ctx);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!noMoreInput) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            media_codec_buffer_t inputBuffer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            memset(&amp;inputBuffer, 0x00, sizeof(media_codec_buffer_t));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ret = hb_mm_mc_dequeue_input_buffer(context, &amp;inputBuffer, 100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                curTime = osal_gettime();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if ((curTime - lastTime)/1000 &lt; (uint32_t)ctx-&gt;duration) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ret = fread(inputBuffer.vframe_buf.vir_ptr[0], 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        inputBuffer.vframe_buf.size, inFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (ret &lt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if(fseek(inFile, 0, SEEK_SET)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            printf(&quot;Failed to rewind input file\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            ret = fread(inputBuffer.vframe_buf.vir_ptr[0], 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                inputBuffer.vframe_buf.size, inFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            if (ret &lt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                printf(&quot;Failed to read input file\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    printf(&quot;Time up(%d)\n&quot;,ctx-&gt;duration);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (!ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    printf(&quot;There is no more input data!\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    inputBuffer.vframe_buf.frame_end = TRUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    noMoreInput = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ret = hb_mm_mc_queue_input_buffer(context, &amp;inputBuffer, 100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    printf(&quot;Queue input buffer fail.\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (ret != (int32_t)HB_MEDIA_ERR_WAIT_TIMEOUT) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    printf(&quot;Dequeue input buffer fail.\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!lastStream) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            media_codec_buffer_t outputBuffer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            media_codec_output_buffer_info_t info;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            memset(&amp;outputBuffer, 0x00, sizeof(media_codec_buffer_t));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            memset(&amp;info, 0x00, sizeof(media_codec_output_buffer_info_t));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ret = hb_mm_mc_dequeue_output_buffer(context, &amp;outputBuffer, &amp;info, 3000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!ret &amp;&amp; outFile) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                fwrite(outputBuffer.vstream_buf.vir_ptr, outputBuffer.vstream_buf.size, 1, outFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ret = hb_mm_mc_queue_output_buffer(context, &amp;outputBuffer, 100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    printf(&quot;Queue output buffer fail.\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (outputBuffer.vstream_buf.stream_end) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    printf(&quot;There is no more output data!\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    lastStream = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (ret != (int32_t)HB_MEDIA_ERR_WAIT_TIMEOUT) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    printf(&quot;Dequeue output buffer fail.\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (needFlush) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ret = hb_mm_mc_flush(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            needFlush = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }while(TRUE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_mm_mc_stop(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_mm_mc_release(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    context = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ERR:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_mm_mc_get_state(context, &amp;state);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (context &amp;&amp; state != MEDIA_CODEC_STATE_UNINITIALIZED) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        hb_mm_mc_stop(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        hb_mm_mc_release(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (inFile)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fclose(inFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (outFile)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fclose(outFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main(int argc, char *argv[])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char outputFileName[MAX_FILE_PATH] = &quot;./tmp.yuv&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char inputFileName[MAX_FILE_PATH] = &quot;./output.stream&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_codec_enc_params_t *params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_context_t context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memset(&amp;context, 0x00, sizeof(media_codec_context_t));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    context.codec_id = MEDIA_CODEC_ID_H265;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    context.encoder = TRUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params = &amp;context.video_enc_params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;width = 640;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;height = 480;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;pix_fmt = MC_PIXEL_FORMAT_YUV420P;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;frame_buf_count = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;external_frame_buf = FALSE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;bitstream_buf_count = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rc_params.mode = MC_AV_RC_MODE_H265CBR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_get_rate_control_config(&amp;context, &amp;params-&gt;rc_params);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rc_params.h265_cbr_params.bit_rate = 5000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rc_params.h265_cbr_params.frame_rate = 30;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rc_params.h265_cbr_params.intra_period = 30;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;gop_params.decoding_refresh_type = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;gop_params.gop_preset_idx = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rot_degree = MC_CCW_0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;mir_direction = MC_DIRECTION_NONE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;frame_cropping_flag = FALSE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MediaCodecTestContext ctx;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memset(&amp;ctx, 0x00, sizeof(ctx));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ctx.context = &amp;context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ctx.inputFileName = inputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ctx.outputFileName = outputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ctx.duration = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    do_sync_encoding(&amp;ctx);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_set_longterm_ref_mode">hb_mm_mc_set_longterm_ref_mode<a href="#hb_mm_mc_set_longterm_ref_mode" class="hash-link" aria-label="hb_mm_mc_set_longterm_ref_mode的直接链接" title="hb_mm_mc_set_longterm_ref_mode的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_set_longterm_ref_mode(media_codec_context_t
*context, const mc_video_longterm_ref_mode_t *params)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[IN] const mc_video_longterm_ref_mode_t
*params：长期参考帧模式参数</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>设置长期参考帧模式的参数，该参数为动态参数，适用于H264/H265。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_longterm_ref_mode">hb_mm_mc_get_longterm_ref_mode</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_get_intra_refresh_config">hb_mm_mc_get_intra_refresh_config<a href="#hb_mm_mc_get_intra_refresh_config" class="hash-link" aria-label="hb_mm_mc_get_intra_refresh_config的直接链接" title="hb_mm_mc_get_intra_refresh_config的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_get_intra_refresh_config(media_codec_context_t
*context, mc_video_intra_refresh_params_t *params)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[OUT] mc_video_intra_refresh_params_t *params：帧内刷新参数</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>获取帧内刷新参数，适用于H264/H265。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_longterm_ref_mode">hb_mm_mc_get_longterm_ref_mode</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_set_intra_refresh_config">hb_mm_mc_set_intra_refresh_config<a href="#hb_mm_mc_set_intra_refresh_config" class="hash-link" aria-label="hb_mm_mc_set_intra_refresh_config的直接链接" title="hb_mm_mc_set_intra_refresh_config的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_set_intra_refresh_config(media_codec_context_t
*context, const mc_video_intra_refresh_params_t *params)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[IN] const mc_video_intra_refresh_params_t
*params：帧内刷新参数</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>设置帧内刷新模式参数，该参数为静态参数，适用于H264/H265。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_longterm_ref_mode">hb_mm_mc_get_longterm_ref_mode</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_get_rate_control_config">hb_mm_mc_get_rate_control_config<a href="#hb_mm_mc_get_rate_control_config" class="hash-link" aria-label="hb_mm_mc_get_rate_control_config的直接链接" title="hb_mm_mc_get_rate_control_config的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_get_rate_control_config(media_codec_context_t
*context, mc_rate_control_params_t *params)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[OUT] mc_rate_control_params_t *params：码率控制参数</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>获取码率控制参数，该参数为动态参数，适用于H264/H265/MJPEG。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_longterm_ref_mode">hb_mm_mc_get_longterm_ref_mode</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_set_rate_control_config">hb_mm_mc_set_rate_control_config<a href="#hb_mm_mc_set_rate_control_config" class="hash-link" aria-label="hb_mm_mc_set_rate_control_config的直接链接" title="hb_mm_mc_set_rate_control_config的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_set_rate_control_config(media_codec_context_t
*context, const mc_rate_control_params_t *params)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[IN] const mc_rate_control_params_t *params：码率控制参数</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>设置码率控制参数，该参数为动态参数，适用于H264/H265/MJPEG。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_longterm_ref_mode">hb_mm_mc_get_longterm_ref_mode</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_get_deblk_filter_config">hb_mm_mc_get_deblk_filter_config<a href="#hb_mm_mc_get_deblk_filter_config" class="hash-link" aria-label="hb_mm_mc_get_deblk_filter_config的直接链接" title="hb_mm_mc_get_deblk_filter_config的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_get_deblk_filter_config(media_codec_context_t
*context, mc_video_deblk_filter_params_t *params)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[OUT] mc_video_deblk_filter_params_t * params：去块滤波参数</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>获取去块滤波参数，适用于H264/H265。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_longterm_ref_mode">hb_mm_mc_get_longterm_ref_mode</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_set_deblk_filter_config">hb_mm_mc_set_deblk_filter_config<a href="#hb_mm_mc_set_deblk_filter_config" class="hash-link" aria-label="hb_mm_mc_set_deblk_filter_config的直接链接" title="hb_mm_mc_set_deblk_filter_config的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_set_deblk_filter_config(media_codec_context_t
*context, const mc_video_deblk_filter_params_t *params)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[IN] const mc_video_deblk_filter_params_t
*params：去块滤波参数</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>设置去块滤波参数，该参数为动态参数，适用于H264/H265。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_longterm_ref_mode">hb_mm_mc_get_longterm_ref_mode</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_get_sao_config">hb_mm_mc_get_sao_config<a href="#hb_mm_mc_get_sao_config" class="hash-link" aria-label="hb_mm_mc_get_sao_config的直接链接" title="hb_mm_mc_get_sao_config的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_get_sao_config(media_codec_context_t *context,
mc_h265_sao_params_t *params)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[OUT] mc_h265_sao_params_t *params：SAO参数</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>获取SAO参数，适用于H265。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_longterm_ref_mode">hb_mm_mc_get_longterm_ref_mode</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_set_sao_config">hb_mm_mc_set_sao_config<a href="#hb_mm_mc_set_sao_config" class="hash-link" aria-label="hb_mm_mc_set_sao_config的直接链接" title="hb_mm_mc_set_sao_config的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_set_sao_config(media_codec_context_t *context,
const mc_h265_sao_params_t *params)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[IN] const mc_h265_sao_params_t *params：SAO参数</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>设置SAO参数，该参数为静态参数，适用于H265。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_longterm_ref_mode">hb_mm_mc_get_longterm_ref_mode</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_get_entropy_config">hb_mm_mc_get_entropy_config<a href="#hb_mm_mc_get_entropy_config" class="hash-link" aria-label="hb_mm_mc_get_entropy_config的直接链接" title="hb_mm_mc_get_entropy_config的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_get_entropy_config(media_codec_context_t
*context, mc_h264_entropy_params_t *params);</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[IN] mc_h264_entropy_params_t *params：entropy参数</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>获取entropy参数，适用于H264。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_longterm_ref_mode">hb_mm_mc_get_longterm_ref_mode</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_set_entropy_config">hb_mm_mc_set_entropy_config<a href="#hb_mm_mc_set_entropy_config" class="hash-link" aria-label="hb_mm_mc_set_entropy_config的直接链接" title="hb_mm_mc_set_entropy_config的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>extern hb_s32 hb_mm_mc_set_entropy_config(media_codec_context_t
*context, const mc_h264_entropy_params_t *params);</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[IN] const mc_h264_entropy_params_t *params：entropy数</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>设置entropy参数，适用于H264。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_longterm_ref_mode">hb_mm_mc_get_longterm_ref_mode</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_get_vui_timing_config">hb_mm_mc_get_vui_timing_config<a href="#hb_mm_mc_get_vui_timing_config" class="hash-link" aria-label="hb_mm_mc_get_vui_timing_config的直接链接" title="hb_mm_mc_get_vui_timing_config的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_get_vui_timing_config(media_codec_context_t
*context, mc_video_vui_timing_params_t *params)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[OUT] mc_video_vui_timing_params_t *params：VUI Timing参数</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>获取VUI Timing参数，适用于H264/H265。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_longterm_ref_mode">hb_mm_mc_get_longterm_ref_mode</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_set_vui_timing_config">hb_mm_mc_set_vui_timing_config<a href="#hb_mm_mc_set_vui_timing_config" class="hash-link" aria-label="hb_mm_mc_set_vui_timing_config的直接链接" title="hb_mm_mc_set_vui_timing_config的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_set_vui_timing_config(media_codec_context_t
*context, const mc_video_vui_timing_params_t *params)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[IN] const mc_video_vui_timing_params_t *params：VUI
Timing参数</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>设置VUI Timing参数，该参数为静态参数，适用于H264/H265。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_longterm_ref_mode">hb_mm_mc_get_longterm_ref_mode</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_get_slice_config">hb_mm_mc_get_slice_config<a href="#hb_mm_mc_get_slice_config" class="hash-link" aria-label="hb_mm_mc_get_slice_config的直接链接" title="hb_mm_mc_get_slice_config的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_get_slice_config(media_codec_context_t
*context, mc_video_slice_params_t *params)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[OUT] mc_video_slice_params_t *params：slice编码参数</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>获取slice编码参数，适用于H264/H265。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_longterm_ref_mode">hb_mm_mc_get_longterm_ref_mode</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_set_slice_config">hb_mm_mc_set_slice_config<a href="#hb_mm_mc_set_slice_config" class="hash-link" aria-label="hb_mm_mc_set_slice_config的直接链接" title="hb_mm_mc_set_slice_config的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_set_slice_config(media_codec_context_t
*context, const mc_video_slice_params_t *params)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[IN] const mc_video_slice_params_t *params：slice编码参数</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>设置slice编码参数，该参数为动态参数，适用于H264/H265。限制每帧slice个数小于等于1500。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_longterm_ref_mode">hb_mm_mc_get_longterm_ref_mode</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_insert_user_data">hb_mm_mc_insert_user_data<a href="#hb_mm_mc_insert_user_data" class="hash-link" aria-label="hb_mm_mc_insert_user_data的直接链接" title="hb_mm_mc_insert_user_data的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_insert_user_data(media_codec_context_t *
context, hb_u8 *data, hb_u32 length)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[IN] hb_u8 *data：用户数据</li>
<li>[IN] hb_u32 length：用户数据长度</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>在编码流中插入用户数据，该参数为动态参数，适用于H264/H265/MJPG/JPG。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_longterm_ref_mode">hb_mm_mc_get_longterm_ref_mode</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_request_idr_frame">hb_mm_mc_request_idr_frame<a href="#hb_mm_mc_request_idr_frame" class="hash-link" aria-label="hb_mm_mc_request_idr_frame的直接链接" title="hb_mm_mc_request_idr_frame的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_request_idr_frame(media_codec_context_t
*context)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
</ul>
<p>【功能描述】</p>
<p>请求IDR帧，该接口可动态设置，适用于H264/H265。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_longterm_ref_mode">hb_mm_mc_get_longterm_ref_mode</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_skip_pic">hb_mm_mc_skip_pic<a href="#hb_mm_mc_skip_pic" class="hash-link" aria-label="hb_mm_mc_skip_pic的直接链接" title="hb_mm_mc_skip_pic的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_skip_pic(media_codec_context_t
*context，hb_s32 src_idx)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[IN] hb_s32 src_idx：source buffer索引值</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>使能指定的图像的skip模式编码，该接口可动态设置，适用于H264/H265。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_longterm_ref_mode">hb_mm_mc_get_longterm_ref_mode</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_get_smart_bg_enc_config">hb_mm_mc_get_smart_bg_enc_config<a href="#hb_mm_mc_get_smart_bg_enc_config" class="hash-link" aria-label="hb_mm_mc_get_smart_bg_enc_config的直接链接" title="hb_mm_mc_get_smart_bg_enc_config的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>extern hb_s32
hb_mm_mc_get_smart_bg_enc_config(media_codec_context_t
*context, mc_video_smart_bg_enc_params_t *params);</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[OUT] mc_video_smart_bg_enc_params_t
*params：智能背景编码模式参数</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>获取智能背景编码参数，适用于H264/H265。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_longterm_ref_mode">hb_mm_mc_get_longterm_ref_mode</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_set_smart_bg_enc_config">hb_mm_mc_set_smart_bg_enc_config<a href="#hb_mm_mc_set_smart_bg_enc_config" class="hash-link" aria-label="hb_mm_mc_set_smart_bg_enc_config的直接链接" title="hb_mm_mc_set_smart_bg_enc_config的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_set_smart_bg_enc_config(media_codec_context_t
*context, const mc_video_smart_bg_enc_params_t *params);</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[IN] const mc_video_smart_bg_enc_params_t
*params：智能背景编码模式参数</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>设置智能背景编码参数，该参数为动态参数，适用于H264/H265。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_longterm_ref_mode">hb_mm_mc_get_longterm_ref_mode</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_get_pred_unit_config">hb_mm_mc_get_pred_unit_config<a href="#hb_mm_mc_get_pred_unit_config" class="hash-link" aria-label="hb_mm_mc_get_pred_unit_config的直接链接" title="hb_mm_mc_get_pred_unit_config的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_get_pred_unit_config(media_codec_context_t
*context, mc_video_pred_unit_params_t *params)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[OUT] mc_video_pred_unit_params_t *params：预测单元参数</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>获取预测单元参数，适用于H264/H265。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_longterm_ref_mode">hb_mm_mc_get_longterm_ref_mode</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_set_pred_unit_config">hb_mm_mc_set_pred_unit_config<a href="#hb_mm_mc_set_pred_unit_config" class="hash-link" aria-label="hb_mm_mc_set_pred_unit_config的直接链接" title="hb_mm_mc_set_pred_unit_config的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_set_pred_unit_config(media_codec_context_t
*context, const mc_video_pred_unit_params_t *params)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[IN] const mc_video_pred_unit_params_t *params：预测单元参数</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>设置预测单元参数，该参数为动态参数，适用于H264/H265。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_longterm_ref_mode">hb_mm_mc_get_longterm_ref_mode</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_get_transform_config">hb_mm_mc_get_transform_config<a href="#hb_mm_mc_get_transform_config" class="hash-link" aria-label="hb_mm_mc_get_transform_config的直接链接" title="hb_mm_mc_get_transform_config的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_get_transform_config(media_codec_context_t
*context, mc_video_transform_params_t *params)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[OUT] mc_video_transform_params_t *params：Transform参数</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>获取Transform参数，适用于H264/H265。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_longterm_ref_mode">hb_mm_mc_get_longterm_ref_mode</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_set_transform_config">hb_mm_mc_set_transform_config<a href="#hb_mm_mc_set_transform_config" class="hash-link" aria-label="hb_mm_mc_set_transform_config的直接链接" title="hb_mm_mc_set_transform_config的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_set_transform_config(media_codec_context_t
*context, const mc_video_transform_params_t *params)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[IN] const mc_video_transform_params_t *params：
Transform参数</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>设置Transform参数，该参数为动态参数，适用于H264/H265。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_longterm_ref_mode">hb_mm_mc_get_longterm_ref_mode</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_get_roi_config">hb_mm_mc_get_roi_config<a href="#hb_mm_mc_get_roi_config" class="hash-link" aria-label="hb_mm_mc_get_roi_config的直接链接" title="hb_mm_mc_get_roi_config的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_get_roi_config(media_codec_context_t *context,
mc_video_roi_params_t *params)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[OUT] mc_video_roi_params_t *params：ROI编码参数</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述  】</p>
<p>获取ROI编码参数，适用于H264/H265。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_longterm_ref_mode">hb_mm_mc_get_longterm_ref_mode</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_set_roi_config">hb_mm_mc_set_roi_config<a href="#hb_mm_mc_set_roi_config" class="hash-link" aria-label="hb_mm_mc_set_roi_config的直接链接" title="hb_mm_mc_set_roi_config的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_set_roi_config(media_codec_context_t *context,
const mc_video_roi_params_t *params)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[IN] const mc_video_roi_params_t *params：ROI编码参数</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>设置ROI编码参数，该参数为动态参数，适用于H264/H265。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_longterm_ref_mode">hb_mm_mc_get_longterm_ref_mode</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_get_mode_decision_config">hb_mm_mc_get_mode_decision_config<a href="#hb_mm_mc_get_mode_decision_config" class="hash-link" aria-label="hb_mm_mc_get_mode_decision_config的直接链接" title="hb_mm_mc_get_mode_decision_config的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_get_mode_decision_config(media_codec_context_t
*context, mc_video_mode_decision_params_t *params);</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[OUT] mc_video_mode_decision_params_t *params：模式决策参数</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实 例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>获取mode decision参数，适用于H265。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_longterm_ref_mode">hb_mm_mc_get_longterm_ref_mode</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_set_mode_decision_config">hb_mm_mc_set_mode_decision_config<a href="#hb_mm_mc_set_mode_decision_config" class="hash-link" aria-label="hb_mm_mc_set_mode_decision_config的直接链接" title="hb_mm_mc_set_mode_decision_config的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_set_mode_decision_config(media_codec_context_t
*context, const mc_video_mode_decision_params_t *params);</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[IN] const mc_video_mode_decision_params_t
*params：模式决策参数</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>设置模式决策参数，该参数为动态参数，适用于H265。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_longterm_ref_mode">hb_mm_mc_get_longterm_ref_mode</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_get_user_data">hb_mm_mc_get_user_data<a href="#hb_mm_mc_get_user_data" class="hash-link" aria-label="hb_mm_mc_get_user_data的直接链接" title="hb_mm_mc_get_user_data的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_get_user_data(media_codec_context_t *context,
mc_user_data_buffer_t *params , hb_s32 timeout)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[OUT] mc_user_data_buffer_t *params：用户数据</li>
<li>[IN] timeout：超时时间</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>获取解码流中的用户数据，适用于H264/H265。</p>
<p>【示例代码】</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &quot;hb_media_codec.h&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &quot;hb_media_error.h&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static int check_and_init_test(MediaCodecTestContext *ctx) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int32_t ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char *inputFileName, *outputFileName, *inputMd5FileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EXPECT_NE(ctx, nullptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EXPECT_NE(ctx-&gt;context, nullptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx == NULL || ctx-&gt;context == NULL) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    inputFileName = ctx-&gt;inputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    outputFileName = ctx-&gt;outputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    inputMd5FileName = ctx-&gt;inputMd5FileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    printf(&quot;%s[%d:%d] Thread work in %s mode\n&quot;, TAG, getpid(), gettid(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ctx-&gt;workMode == THREAD_WORK_MODE_SYNC ? &quot;sync&quot; :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (ctx-&gt;workMode == THREAD_WORK_MODE_ASYNC ? &quot;async&quot; : &quot;poll&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    printf(&quot;%s[%d:%d] InputFileName = %s\n&quot;, TAG, getpid(), gettid(), inputFileName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    printf(&quot;%s[%d:%d] OutputFileName = %s\n&quot;, TAG, getpid(), gettid(), outputFileName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    printf(&quot;%s[%d:%d] InputMd5File = %s\n&quot;, TAG, getpid(), gettid(), inputMd5FileName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EXPECT_NE(inputFileName, nullptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EXPECT_NE(outputFileName, nullptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (inputFileName == NULL || outputFileName == NULL) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ctx-&gt;inFile = fopen(inputFileName, &quot;rb&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EXPECT_NE(ctx-&gt;inFile, nullptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ctx-&gt;outFile = fopen(outputFileName, &quot;wb+&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EXPECT_NE(ctx-&gt;outFile, nullptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;inFile == NULL || ctx-&gt;outFile == NULL) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;md5Test == TRUE) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (inputMd5FileName) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ctx-&gt;inMd5File = fopen(inputMd5FileName, &quot;rb&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        EXPECT_NE(ctx-&gt;inMd5File, nullptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ctx-&gt;inMd5File == NULL) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // allocate ion buffers</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ctx-&gt;ionFd = ion_open();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EXPECT_GT(ctx-&gt;ionFd, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;ionFd &lt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;context-&gt;encoder == TRUE) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf(&quot;%s[%d:%d] Thread use %s buffer mode, %d rc mode\n&quot;, TAG, getpid(), gettid(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ctx-&gt;context-&gt;video_enc_params.external_frame_buf ?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;external&quot; : &quot;internal&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ctx-&gt;context-&gt;video_enc_params.rc_params.mode);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ctx-&gt;context-&gt;video_enc_params.external_frame_buf) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ctx-&gt;exFb = (ExternalFrameBuffer *) malloc(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ctx-&gt;context-&gt;video_enc_params.frame_buf_count * sizeof(ExternalFrameBuffer));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            EXPECT_NE(ctx-&gt;exFb, nullptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ctx-&gt;exFb == NULL) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (Uint32 i=0; i&lt;ctx-&gt;context-&gt;video_enc_params.frame_buf_count; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ctx-&gt;exFb[i].buf.size = ctx-&gt;context-&gt;video_enc_params.width</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                * ctx-&gt;context-&gt;video_enc_params.height * 3/2; // only for yuv420;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ret = allocate_ion_mem(ctx-&gt;ionFd, &amp;ctx-&gt;exFb[i].buf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                EXPECT_EQ(ret, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (ret != 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ctx-&gt;exFb[i].valid = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ctx-&gt;exFb[i].src_idx = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf(&quot;%s[%d:%d] Thread use %s buffer mode, %d feed mode.\n&quot;, TAG, getpid(), gettid(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ctx-&gt;context-&gt;video_dec_params.external_bitstream_buf ?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;external&quot; : &quot;internal&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ctx-&gt;context-&gt;video_dec_params.feed_mode);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ctx-&gt;context-&gt;video_dec_params.external_bitstream_buf) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ctx-&gt;exBs = (ExternalStreamBuffer *) malloc(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ctx-&gt;context-&gt;video_dec_params.bitstream_buf_count * sizeof(ExternalStreamBuffer));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            EXPECT_NE(ctx-&gt;exBs, nullptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ctx-&gt;exBs == NULL) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (Uint32 i=0; i&lt;ctx-&gt;context-&gt;video_dec_params.bitstream_buf_count; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ctx-&gt;exBs[i].buf.size = ctx-&gt;context-&gt;video_dec_params.bitstream_buf_size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ret = allocate_ion_mem(ctx-&gt;ionFd, &amp;ctx-&gt;exBs[i].buf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                EXPECT_EQ(ret, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (ret != 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ctx-&gt;exBs[i].valid = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ctx-&gt;exBs[i].src_idx = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// open decode files</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;context-&gt;encoder != TRUE) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;context-&gt;video_dec_params.feed_mode == MC_FEEDING_MODE_FRAME_SIZE) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = avformat_open_input(&amp;ctx-&gt;avContext, ctx-&gt;inputFileName, 0, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        EXPECT_GE(ret, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ret &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = avformat_find_stream_info(ctx-&gt;avContext, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        EXPECT_GE(ret, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ret &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ctx-&gt;videoIndex = av_find_best_stream(ctx-&gt;avContext, AVMEDIA_TYPE_VIDEO, -1, -1, NULL, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        EXPECT_GE(ctx-&gt;videoIndex, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ctx-&gt;videoIndex &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        av_init_packet(&amp;ctx-&gt;avpacket);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ctx-&gt;feedingSize == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            uint32_t KB = 1024;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int32_t probability10;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            srand((uint32_t)time(NULL));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ctx-&gt;feedingSize = rand() % MAX_FEEDING_SIZE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            probability10 = (ctx-&gt;feedingSize % 100) &lt; 10;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ctx-&gt;feedingSize &lt; KB) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (probability10 == FALSE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ctx-&gt;feedingSize *= 100;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            printf(&quot;%s[%d:%d] Feeding size = %d\n&quot;, TAG,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            getpid(), gettid(), ctx-&gt;feedingSize);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ctx-&gt;firstPacket = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static int check_and_release_test(MediaCodecTestContext *ctx) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int32_t ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int md5Match, wholeFileSize = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    uint8_t *md5Buffer = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EXPECT_NE(ctx, nullptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EXPECT_NE(ctx-&gt;context, nullptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EXPECT_NE(ctx-&gt;inFile, nullptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EXPECT_NE(ctx-&gt;outFile, nullptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx == NULL || ctx-&gt;context == NULL || ctx-&gt;inFile == NULL ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ctx-&gt;outFile == NULL) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;context-&gt;encoder != TRUE) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ctx-&gt;context-&gt;video_dec_params.feed_mode == MC_FEEDING_MODE_FRAME_SIZE) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ctx-&gt;avContext) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                avformat_close_input(&amp;ctx-&gt;avContext);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;context-&gt;encoder == TRUE) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ctx-&gt;context-&gt;video_enc_params.external_frame_buf) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ctx-&gt;exFb) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for (Uint32 i=0; i&lt;ctx-&gt;context-&gt;video_enc_params.frame_buf_count; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ret = release_ion_mem(ctx-&gt;ionFd, &amp;ctx-&gt;exFb[i].buf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    EXPECT_EQ(ret, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                free(ctx-&gt;exFb);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ctx-&gt;context-&gt;video_dec_params.external_bitstream_buf) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ctx-&gt;exBs) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for (Uint32 i=0; i&lt;ctx-&gt;context-&gt;video_dec_params.bitstream_buf_count; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ret = release_ion_mem(ctx-&gt;ionFd, &amp;ctx-&gt;exBs[i].buf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    EXPECT_EQ(ret, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                free(ctx-&gt;exBs);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;ionFd)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ion_close(ctx-&gt;ionFd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;md5Test &amp;&amp; ctx-&gt;inMd5File) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fseek(ctx-&gt;outFile, 0, SEEK_END);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        wholeFileSize = ftell(ctx-&gt;outFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fseek(ctx-&gt;outFile, 0, SEEK_SET);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        md5Buffer = (uint8_t *)malloc(wholeFileSize);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        EXPECT_NE(md5Buffer, nullptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (md5Buffer == NULL) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fread(md5Buffer, wholeFileSize, 1, ctx-&gt;outFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        md5Match = compare_md5_value(MD5_SIZE, ctx-&gt;inMd5File,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        md5Buffer, wholeFileSize);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        free(md5Buffer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fclose(ctx-&gt;inMd5File);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        EXPECT_EQ(md5Match, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (md5Match != 1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;outFile)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fclose(ctx-&gt;outFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;inFile)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fclose(ctx-&gt;inFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static void on_vlc_buffer_message(hb_ptr userdata, hb_s32 * vlc_buf) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MediaCodecTestContext *ctx = (MediaCodecTestContext *)userdata;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ASSERT_NE(vlc_buf, nullptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ASSERT_NE(ctx, nullptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ASSERT_GE(ctx-&gt;vlc_buf_size, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;testLog) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf(&quot;%s %s VLC Buffer size = %d; Reset to %d.\n&quot;, TAG, __FUNCTION__,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        *vlc_buf, ctx-&gt;vlc_buf_size);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    *vlc_buf = ctx-&gt;vlc_buf_size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static int read_input_streams(MediaCodecTestContext *ctx,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_buffer_t *inputBuffer) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Uint64 curTime = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int ret = 0, ret2 = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Uint32 bufIdx = 0, srcIdx = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Int32 doRead = TRUE, doRewind = FALSE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    uint8_t *seqHeader = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int seqHeaderSize = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void *bufPtr = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int avalBufSize = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EXPECT_NE(ctx, nullptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EXPECT_NE(ctx-&gt;context, nullptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EXPECT_NE(ctx-&gt;inFile, nullptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EXPECT_NE(ctx-&gt;outFile, nullptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EXPECT_NE(inputBuffer, nullptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx == NULL || ctx-&gt;context == NULL || ctx-&gt;inFile == NULL ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ctx-&gt;outFile == NULL || inputBuffer == NULL) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf(&quot;%s[%d:%d] Invalid parameters(%s).\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        TAG, getpid(), gettid(), __FUNCTION__);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;stabilityTest || ctx-&gt;pfTest) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        doRewind = TRUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        curTime = osal_gettime();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if ((curTime - ctx-&gt;testStartTime)/1000 &lt; (uint32_t)ctx-&gt;duration) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            doRead = TRUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            printf(&quot;%s[%d:%d] Time up(%d)\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            TAG, getpid(), gettid(), ctx-&gt;duration);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            doRead = FALSE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;context-&gt;video_dec_params.external_bitstream_buf) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // release input buffer and take it as the new input buffer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (bufIdx = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            bufIdx &lt; ctx-&gt;context-&gt;video_dec_params.bitstream_buf_count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            bufIdx++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ctx-&gt;exBs[bufIdx].valid &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ctx-&gt;exBs[bufIdx].src_idx == inputBuffer-&gt;vstream_buf.src_idx) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                srcIdx = inputBuffer-&gt;vstream_buf.src_idx;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        EXPECT_NE(bufIdx, ctx-&gt;context-&gt;video_dec_params.bitstream_buf_count);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (bufIdx == ctx-&gt;context-&gt;video_dec_params.bitstream_buf_count) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bufPtr = (void *)ctx-&gt;exBs[srcIdx].buf.virt_addr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ctx-&gt;context-&gt;video_dec_params.feed_mode ==</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            MC_FEEDING_MODE_FRAME_SIZE) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            avalBufSize = ctx-&gt;exBs[srcIdx].buf.size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            avalBufSize = (ctx-&gt;exBs[srcIdx].buf.size &lt; (int)ctx-&gt;feedingSize) ?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ctx-&gt;exBs[srcIdx].buf.size : ctx-&gt;feedingSize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        inputBuffer-&gt;vstream_buf.fd = ctx-&gt;exBs[srcIdx].buf.fd;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        inputBuffer-&gt;vstream_buf.phy_ptr =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ctx-&gt;exBs[srcIdx].buf.phys_addr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        inputBuffer-&gt;vstream_buf.vir_ptr =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (hb_u8 *)ctx-&gt;exBs[srcIdx].buf.virt_addr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bufPtr = (void *)inputBuffer-&gt;vstream_buf.vir_ptr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ctx-&gt;context-&gt;video_dec_params.feed_mode ==</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            MC_FEEDING_MODE_FRAME_SIZE) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            avalBufSize = inputBuffer-&gt;vstream_buf.size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            avalBufSize = (inputBuffer-&gt;vstream_buf.size &lt; ctx-&gt;feedingSize) ?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            inputBuffer-&gt;vstream_buf.size : ctx-&gt;feedingSize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (doRead == FALSE) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // MC_FEEDING_MODE_FRAME_SIZE mode</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;context-&gt;video_dec_params.feed_mode == MC_FEEDING_MODE_FRAME_SIZE) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        do {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ctx-&gt;avpacket.size == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ret = av_read_frame(ctx-&gt;avContext, &amp;ctx-&gt;avpacket);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (ret &lt; 0 &amp;&amp; doRewind == FALSE) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    printf(&quot;%s[%d:%d] Failed to read input file (error=0x%x)\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        TAG, getpid(), gettid(), ret);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (ret &lt; 0 &amp;&amp; doRewind == TRUE) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    avformat_close_input(&amp;ctx-&gt;avContext);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ret2 = avformat_open_input(&amp;ctx-&gt;avContext, ctx-&gt;inputFileName, 0, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    EXPECT_GE(ret2, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (ret2 &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        ret = ret2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    /*ret = avformat_find_stream_info(ctx-&gt;avContext, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    EXPECT_GE(ret, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (ret &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ctx-&gt;videoIndex = av_find_best_stream(ctx-&gt;avContext, AVMEDIA_TYPE_VIDEO, -1, -1, NULL, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    EXPECT_GE(ctx-&gt;videoIndex, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (ctx-&gt;videoIndex &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        ret = -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    av_init_packet(&amp;ctx-&gt;avpacket);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (ctx-&gt;testLog) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    printf(&quot;%s[%d:%d] Reuse previous stream packet size %d\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    TAG, getpid(), gettid(), ctx-&gt;avpacket.size);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } while (ret &lt; 0 &amp;&amp; doRewind == TRUE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ret &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ret == AVERROR_EOF || ctx-&gt;avContext-&gt;pb-&gt;eof_reached == TRUE) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                printf(&quot;%s[%d:%d] End of file!\n&quot;, TAG, getpid(), gettid());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                printf(&quot;%s[%d:%d] Failed to av_read_frame error(0x%08x)\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                TAG, getpid(), gettid(), ret);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ctx-&gt;testLog) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            printf(&quot;%s[%d:%d] Read packet size %d\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                TAG, getpid(), gettid(), ctx-&gt;avpacket.size);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        seqHeaderSize = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ctx-&gt;firstPacket) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            AVCodecParameters* codec;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int retSize = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            codec = ctx-&gt;avContext-&gt;streams[ctx-&gt;videoIndex]-&gt;codecpar;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            seqHeader = (uint8_t*)malloc(codec-&gt;extradata_size + 1024);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (seqHeader == NULL) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                printf(&quot;%s[%d:%d] Failed to mallock seqHeader\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                TAG, getpid(), gettid());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ret = -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            memset((void*)seqHeader, 0x00, codec-&gt;extradata_size + 1024);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            seqHeaderSize = build_dec_seq_header(seqHeader,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ctx-&gt;context-&gt;codec_id,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ctx-&gt;avContext-&gt;streams[ctx-&gt;videoIndex], &amp;retSize);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (seqHeaderSize &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                printf(&quot;%s[%d:%d] Failed to build seqHeader\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                TAG, getpid(), gettid());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ret = -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ctx-&gt;firstPacket = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if ((ctx-&gt;avpacket.size &lt;= avalBufSize)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &amp;&amp; (seqHeaderSize &lt;= avalBufSize)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int bufSize = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (seqHeaderSize) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                memcpy(bufPtr, seqHeader, seqHeaderSize);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                bufSize = seqHeaderSize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                /*memcpy((char *)bufPtr+bufSize,ctx-&gt;avpacket.data, ctx-&gt;avpacket.size);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                bufSize += ctx-&gt;avpacket.size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                av_packet_unref(&amp;ctx-&gt;avpacket);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ctx-&gt;avpacket.size = 0;*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                memcpy(bufPtr,ctx-&gt;avpacket.data, ctx-&gt;avpacket.size);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                bufSize = ctx-&gt;avpacket.size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                av_packet_unref(&amp;ctx-&gt;avpacket);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ctx-&gt;avpacket.size = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            inputBuffer-&gt;vstream_buf.size = bufSize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            printf(&quot;%s[%d:%d] The stream buffer is too &quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;small!\n&quot;, TAG, getpid(), gettid());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (seqHeader) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            free(seqHeader);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            seqHeader = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // MC_FEEDING_MODE_STREAM_SIZE mode</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    do {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = fread(bufPtr, 1, avalBufSize, ctx-&gt;inFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ret &lt;= 0 &amp;&amp; doRewind == FALSE) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            printf(&quot;%s[%d:%d] Failed to read input file (error=0x%x)\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                TAG, getpid(), gettid(), ret);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ret &lt;= 0 &amp;&amp; doRewind == TRUE) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(fseek(ctx-&gt;inFile, 0, SEEK_SET)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                printf(&quot;%s Failed to rewind input file (pid=%d, tid=%d)\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    TAG, getpid(), gettid());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } while (ret == 0 &amp;&amp; doRewind == TRUE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    inputBuffer-&gt;vstream_buf.size = ret &gt; 0 ? ret : 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static int write_output_frames(MediaCodecTestContext *ctx,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_buffer_t *outputBuffer) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int32_t ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EXPECT_NE(ctx, nullptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EXPECT_NE(ctx-&gt;context, nullptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EXPECT_NE(ctx-&gt;inFile, nullptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EXPECT_NE(ctx-&gt;outFile, nullptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EXPECT_NE(outputBuffer, nullptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx == NULL || ctx-&gt;context == NULL || ctx-&gt;inFile == NULL ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ctx-&gt;outFile == NULL || outputBuffer == NULL) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf(&quot;%s[%d:%d] Invalid parameters(%s).\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        TAG, getpid(), gettid(), __FUNCTION__);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!ctx-&gt;stabilityTest &amp;&amp; !ctx-&gt;pfTest) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fwrite(outputBuffer-&gt;vframe_buf.vir_ptr[0], outputBuffer-&gt;vframe_buf.size,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            1, ctx-&gt;outFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static int do_decode_params_checking(MediaCodecTestContext *ctx,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_buffer_t *outputBuffer) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_context_t *context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int32_t ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EXPECT_NE(ctx, nullptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EXPECT_NE(ctx-&gt;context, nullptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx == NULL || ctx-&gt;context == NULL || ctx-&gt;inFile == NULL ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ctx-&gt;outFile == NULL || outputBuffer == NULL) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf(&quot;%s[%d:%d] Invalid parameters(%s).\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        TAG, getpid(), gettid(), __FUNCTION__);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    context = ctx-&gt;context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;enable_get_userdata) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mc_user_data_buffer_t userdata = {0};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = hb_mm_mc_get_user_data(context, &amp;userdata, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            printf(&quot;%s[%d:%d] Get userdata %d:\n&quot;, TAG, getpid(), gettid(), userdata.size);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (uint32_t i = 0; i &lt; userdata.size; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (i &lt; 16) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    printf(&quot;%s[%d:%d] userdata[i]:%x\n&quot;, TAG, getpid(), gettid(), userdata.virt_addr[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    printf(&quot;%s[%d:%d] userdata[i]:%c\n&quot;, TAG, getpid(), gettid(), userdata.virt_addr[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ret = hb_mm_mc_release_user_data(context, &amp;userdata);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static void do_sync_decoding(void *arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int step = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MediaCodecTestContext *ctx = (MediaCodecTestContext *)arg;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_context_t *context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_callback_t callback;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_buffer_t inputBuffer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_buffer_t outputBuffer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_output_buffer_info_t info;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int32_t decStartTime = 0, decFinishTime = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ctx-&gt;workMode = THREAD_WORK_MODE_SYNC;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ASSERT_EQ(check_and_init_test(ctx), 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    context = ctx-&gt;context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //get current time</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ctx-&gt;testStartTime = osal_gettime();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;testLog) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf(&quot;%s[%d:%d] Step %d initialize (outFile=%s, FileFd=%p)\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            TAG, getpid(), gettid(), step++, ctx-&gt;outputFileName, ctx-&gt;outFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_initialize(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ASSERT_EQ(ret, (int32_t)0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    callback.on_vlc_buffer_message = on_vlc_buffer_message;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;vlc_buf_size &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = hb_mm_mc_set_vlc_buffer_listener(context, &amp;callback, ctx);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ASSERT_EQ(ret, (int32_t)0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;testLog) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf(&quot;%s[%d:%d] Step %d configure\n&quot;, TAG, getpid(), gettid(), step++);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_configure(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EXPECT_EQ(ret, (int32_t)0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;testLog) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf(&quot;%s[%d:%d] Step %d start\n&quot;, TAG, getpid(), gettid(), step++);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_av_codec_startup_params_t startup_params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memset(&amp;startup_params, 0x00, sizeof(mc_av_codec_startup_params_t));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_start(context, &amp;startup_params);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EXPECT_EQ(ret, (int32_t)0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    do {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!ctx-&gt;lastStream) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ctx-&gt;testLog) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                printf(&quot;%s[%d:%d] Step %d dequeue input\n&quot;, TAG, getpid(), gettid(), step++);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // process input buffers</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ret = hb_mm_mc_dequeue_input_buffer(context, &amp;inputBuffer, 3000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //EXPECT_EQ(ret, (int32_t)0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (ctx-&gt;testLog) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    printf(&quot;%s[%d:%d] input buffer viraddr %p phy addr %x, size = %d\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    TAG, getpid(), gettid(), inputBuffer.vstream_buf.vir_ptr,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    inputBuffer.vstream_buf.phy_ptr,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    inputBuffer.vstream_buf.size);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (ctx-&gt;testLog) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    printf(&quot;%s[%d:%d] Step %d feed input (pid=%d, tid=%d)\n&quot;, TAG, getpid(), gettid(), step++);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ret = read_input_streams(ctx, &amp;inputBuffer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (ret &lt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    printf(&quot;%s[%d:%d] There is no more input data(ret=%d)!\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    TAG, getpid(), gettid(), ret);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    inputBuffer.vstream_buf.stream_end = TRUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    inputBuffer.vstream_buf.size = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ctx-&gt;lastStream = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //EXPECT_EQ(ret, (int32_t)TRUE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (ctx-&gt;testLog) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    printf(&quot;%s[%d:%d] Step %d queue input(size=%d)\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    TAG, getpid(), gettid(), step++, inputBuffer.vstream_buf.size);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ret = hb_mm_mc_queue_input_buffer(context, &amp;inputBuffer, 100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                EXPECT_EQ(ret, (int32_t)0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (ret != 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (ctx-&gt;delaytest) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    decStartTime = osal_gettime();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (ret != (int32_t)HB_MEDIA_ERR_WAIT_TIMEOUT) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    EXPECT_EQ(ret, (int32_t)0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    char info[256];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    hb_mm_strerror(ret, info, 256);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    printf(&quot;%s[%d:%d] dequeue input buffer fail.(%s)\n&quot;, TAG, getpid(), gettid(), info);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!ctx-&gt;lastFrame) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ctx-&gt;testLog) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            printf(&quot;%s[%d:%d] Step %d dequeue output\n&quot;, TAG, getpid(), gettid(), step++);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // process output buffers</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            memset(&amp;outputBuffer, 0x00, sizeof(media_codec_buffer_t));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            memset(&amp;info, 0x00, sizeof(media_codec_output_buffer_info_t));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ret = hb_mm_mc_dequeue_output_buffer(context, &amp;outputBuffer, &amp;info, 100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //EXPECT_EQ(ret, (int32_t)0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (ctx-&gt;testLog) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    printf(&quot;%s[%d:%d] output bufferviraddr %p phy addr %x, size = %d, outFile = %p\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    TAG, getpid(), gettid(), outputBuffer.vframe_buf.vir_ptr[0],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    outputBuffer.vframe_buf.phy_ptr[0],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    outputBuffer.vframe_buf.size, ctx-&gt;outFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (ctx-&gt;testLog) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    printf(&quot;%s[%d:%d] Step %d write output file\n&quot;, TAG, getpid(), gettid(), step++);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (ctx-&gt;delaytest) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    decFinishTime = osal_gettime();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if ((decFinishTime - decStartTime) &gt;= ctx-&gt;delaytime) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        printf(&quot;%s[%d:%d] Decoding time is %d, more than %dms\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        TAG, getpid(), gettid(), (decFinishTime - decStartTime), ctx-&gt;delaytime);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        ASSERT_LE((decFinishTime - decStartTime), ctx-&gt;delaytime);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ASSERT_EQ(write_output_frames(ctx, &amp;outputBuffer), 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (ctx-&gt;testLog) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    printf(&quot;%s[%d:%d] Step %d queue output\n&quot;, TAG, getpid(), gettid(), step++);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ASSERT_EQ(do_decode_params_checking(ctx, &amp;outputBuffer), 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ret = hb_mm_mc_queue_output_buffer(context, &amp;outputBuffer, 100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                EXPECT_EQ(ret, (int32_t)0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (outputBuffer.vframe_buf.frame_end) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    printf(&quot;%s[%d:%d] There is no more output data!\n&quot;, TAG, getpid(), gettid());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ctx-&gt;lastFrame = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                char info[256];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                hb_mm_strerror(ret, info, 256);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                printf(&quot;%s[%d:%d] dequeue output buffer fail.(%s)\n&quot;, TAG, getpid(), gettid(), info);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (ret != (int32_t)HB_MEDIA_ERR_WAIT_TIMEOUT) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    EXPECT_EQ(ret, (int32_t)0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (ctx-&gt;stabilityTest &amp;&amp; ctx-&gt;lastStream ==1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }while(TRUE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_stop(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EXPECT_EQ(ret, (int32_t)0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_release(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EXPECT_EQ(ret, (int32_t)0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ASSERT_EQ(check_and_release_test(ctx), 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main(int argc, char *argv[])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char outputFileName[MAX_FILE_PATH] = &quot;input.h265&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char inputFileName[MAX_FILE_PATH] = &quot;output.yuv&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mTestWidth = 640;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mTestHeight = 480;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mTestFeedMode = MC_FEEDING_MODE_FRAME_SIZE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mTestCodec = TEST_CODEC_ID_H265;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_codec_dec_params_t *params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ASSERT_NE(context, nullptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memset(context, 0x00, sizeof(media_codec_context_t));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    context-&gt;codec_id = get_codec_id(mTestCodec);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    context-&gt;encoder = FALSE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params = &amp;context-&gt;video_dec_params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;feed_mode = mTestFeedMode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;pix_fmt = mTestPixFmt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;bitstream_buf_count = 6;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;frame_buf_count = 8;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (context-&gt;codec_id == MEDIA_CODEC_ID_H265) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        params-&gt;h265_dec_config.bandwidth_Opt = TRUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        params-&gt;h265_dec_config.reorder_enable = TRUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        params-&gt;h265_dec_config.skip_mode = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        params-&gt;h265_dec_config.cra_as_bla = FALSE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        params-&gt;h265_dec_config.dec_temporal_id_mode = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        params-&gt;h265_dec_config.target_dec_temporal_id_plus1 = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MediaCodecTestContext ctx;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memset(&amp;ctx, 0x00, sizeof(ctx));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ctx.context = context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ctx.inputFileName = inputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ctx.outputFileName = outputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char inputMd5FileName[MAX_FILE_PATH];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx.md5Test) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        char inputMd5Suffix[MAX_FILE_PATH] = &quot;.md5&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        snprintf(dedicatedSuffix, MAX_FILE_PATH, &quot;%s&quot;, &quot;dec&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        snprintf(inputMd5FileName, MAX_FILE_PATH, &quot;%s%s_%s_%s%s&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ctx.inputMd5FileName = inputMd5FileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    do_sync_decoding(&amp;ctx);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (context != NULL) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        free(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_release_user_data">hb_mm_mc_release_user_data<a href="#hb_mm_mc_release_user_data" class="hash-link" aria-label="hb_mm_mc_release_user_data的直接链接" title="hb_mm_mc_release_user_data的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_release_user_data(media_codec_context_t *
context, const mc_user_data_buffer_t * params)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[IN] const mc_user_data_buffer_t * params： 用户数据</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>释放解码流中的用户数据，适用于H264/H265。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_user_data">hb_mm_mc_get_user_data</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_get_mjpeg_config">hb_mm_mc_get_mjpeg_config<a href="#hb_mm_mc_get_mjpeg_config" class="hash-link" aria-label="hb_mm_mc_get_mjpeg_config的直接链接" title="hb_mm_mc_get_mjpeg_config的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_get_mjpeg_config(media_codec_context_t
*context, mc_mjpeg_enc_params_t *params)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[OUT] mc_mjpeg_enc_params_t *params：MJPEG编码参数</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>获取MJPEG编码参数，适用于MJPEG。</p>
<p>【示例代码】</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &quot;hb_media_codec.h&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &quot;hb_media_error.h&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main(int argc, char *argv[])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char outputFileName[MAX_FILE_PATH];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char inputFileName[MAX_FILE_PATH];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mTestCodec = TEST_CODEC_ID_MJPEG;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mTestPixFmt = MC_PIXEL_FORMAT_NV12;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char dedicatedSuffix[MAX_FILE_PATH] = &quot;_test&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char inputSuffix[MAX_FILE_PATH] = &quot;.yuv&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char outputSuffixJpeg[MAX_FILE_PATH] = &quot;.jpg&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char outputSuffixMjpg[MAX_FILE_PATH] = &quot;.mjpg&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    snprintf(inputFileName, MAX_FILE_PATH, &quot;%s%s%s&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mInputSpecPrefix, mTest12Bit ? mGlobal12BPixFmtName[mTestPixFmt]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        : mGlobalPixFmtName[mTestPixFmt], inputSuffix);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    snprintf(outputFileName, MAX_FILE_PATH, &quot;%s%s%s%s&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mOutputSpecPrefix, mTest12Bit ? mGlobal12BPixFmtName[mTestPixFmt]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        : mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mTestCodec == TEST_CODEC_ID_JPEG ? outputSuffixJpeg : outputSuffixMjpg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_codec_enc_params_t *params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ASSERT_NE(context, nullptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memset(context, 0x00, sizeof(media_codec_context_t));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    context-&gt;codec_id = mTestCodec == TEST_CODEC_ID_JPEG ?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        MEDIA_CODEC_ID_JPEG : MEDIA_CODEC_ID_MJPEG;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    context-&gt;encoder = TRUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params = &amp;context-&gt;video_enc_params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;width = mTestWidth;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;height = mTestHeight;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;pix_fmt = mTestPixFmt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;frame_buf_count = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;bitstream_buf_count = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rot_degree = MC_CCW_0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;mir_direction = MC_DIRECTION_NONE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;frame_cropping_flag = FALSE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;external_frame_buf = FALSE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (context-&gt;codec_id == MEDIA_CODEC_ID_MJPEG) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        params-&gt;rc_params.mode = MC_AV_RC_MODE_MJPEGFIXQP;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = hb_mm_mc_get_rate_control_config(context, &amp;params-&gt;rc_params);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ASSERT_EQ(ret, (int32_t)0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        params-&gt;mjpeg_enc_config.restart_interval = mTestWidth/16;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        params-&gt;mjpeg_enc_config.extended_sequential = mTest12Bit;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        params-&gt;jpeg_enc_config.restart_interval = mTestWidth/16;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        params-&gt;jpeg_enc_config.extended_sequential = mTest12Bit;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_mjpeg_enc_params_t mjpeg_params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memset(&amp;mjpeg_params, 0x00, sizeof(mjpeg_params));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_get_mjpeg_config(context, &amp;mjpeg_params);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ASSERT_EQ(ret, (int32_t)0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_initialize(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ASSERT_EQ(ret, (int32_t)0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_set_mjpeg_config(context, &amp;mjpeg_params);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ASSERT_EQ(ret, (int32_t)0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_stop(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ASSERT_EQ(ret, (int32_t)0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_release(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ASSERT_EQ(ret, (int32_t)0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (context != NULL) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        free(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_set_mjpeg_config">hb_mm_mc_set_mjpeg_config<a href="#hb_mm_mc_set_mjpeg_config" class="hash-link" aria-label="hb_mm_mc_set_mjpeg_config的直接链接" title="hb_mm_mc_set_mjpeg_config的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_set_mjpeg_config(media_codec_context_t
*context, const mc_mjpeg_enc_params_t *params)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[IN] const mc_mjpeg_enc_params_t *params：MJPEG编码参数</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>设置MJPEG编码参数，该参数为动态参数，适用于MJPEG。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_mjpeg_config">hb_mm_mc_get_mjpeg_config</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_get_jpeg_config">hb_mm_mc_get_jpeg_config<a href="#hb_mm_mc_get_jpeg_config" class="hash-link" aria-label="hb_mm_mc_get_jpeg_config的直接链接" title="hb_mm_mc_get_jpeg_config的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_get_jpeg_config(media_codec_context_t
*context, mc_jpeg_enc_params_t *params)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[OUT] mc_jpeg_enc_params_t *params：JPEG编码参数</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>获取JPEG编码参数，适用于JPEG。</p>
<p>【示例代码】</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &quot;hb_media_codec.h&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &quot;hb_media_error.h&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main(int argc, char *argv[])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char outputFileName[MAX_FILE_PATH];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char inputFileName[MAX_FILE_PATH];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mTestCodec = TEST_CODEC_ID_JPEG;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mTestPixFmt = MC_PIXEL_FORMAT_NV12;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char dedicatedSuffix[MAX_FILE_PATH] = &quot;_test&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char inputSuffix[MAX_FILE_PATH] = &quot;.yuv&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char outputSuffixJpeg[MAX_FILE_PATH] = &quot;.jpg&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char outputSuffixMjpg[MAX_FILE_PATH] = &quot;.mjpg&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    snprintf(inputFileName, MAX_FILE_PATH, &quot;%s%s%s&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mInputSpecPrefix, mTest12Bit ? mGlobal12BPixFmtName[mTestPixFmt]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        : mGlobalPixFmtName[mTestPixFmt], inputSuffix);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    snprintf(outputFileName, MAX_FILE_PATH, &quot;%s%s%s%s&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mOutputSpecPrefix, mTest12Bit ? mGlobal12BPixFmtName[mTestPixFmt]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        : mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mTestCodec == TEST_CODEC_ID_JPEG ? outputSuffixJpeg : outputSuffixMjpg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_codec_enc_params_t *params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ASSERT_NE(context, nullptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memset(context, 0x00, sizeof(media_codec_context_t));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    context-&gt;codec_id = mTestCodec == TEST_CODEC_ID_JPEG ?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_JPEG : MEDIA_CODEC_ID_MJPEG;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    context-&gt;encoder = TRUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params = &amp;context-&gt;video_enc_params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;width = mTestWidth;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;height = mTestHeight;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;pix_fmt = mTestPixFmt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;frame_buf_count = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;bitstream_buf_count = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rot_degree = MC_CCW_0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;mir_direction = MC_DIRECTION_NONE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;frame_cropping_flag = FALSE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;external_frame_buf = FALSE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (context-&gt;codec_id == MEDIA_CODEC_ID_MJPEG) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        params-&gt;rc_params.mode = MC_AV_RC_MODE_MJPEGFIXQP;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = hb_mm_mc_get_rate_control_config(context, &amp;params-&gt;rc_params);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ASSERT_EQ(ret, (int32_t)0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        params-&gt;mjpeg_enc_config.restart_interval = mTestWidth/16;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        params-&gt;mjpeg_enc_config.extended_sequential = mTest12Bit;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        params-&gt;jpeg_enc_config.restart_interval = mTestWidth/16;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        params-&gt;jpeg_enc_config.extended_sequential = mTest12Bit;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_jpeg_enc_params_t jpeg_params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memset(&amp;jpeg_params, 0x00, sizeof(jpeg_params));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_get_jpeg_config(context, &amp;jpeg_params);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ASSERT_EQ(ret, (int32_t)0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_initialize(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ASSERT_EQ(ret, (int32_t)0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    jpeg_params.quality_factor = 30;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    jpeg_params.restart_interval = (((params-&gt;width+15)&gt;&gt;4) *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ((params-&gt;height+15)&gt;&gt;4) * 2) + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    jpeg_params.crop_en = FALSE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_set_jpeg_config(context, &amp;jpeg_params);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ASSERT_EQ(ret, (int32_t)HB_MEDIA_ERR_INVALID_PARAMS);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    jpeg_params.restart_interval = 70;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_set_jpeg_config(context, &amp;jpeg_params);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ASSERT_EQ(ret, (int32_t)0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_stop(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ASSERT_EQ(ret, (int32_t)0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_release(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ASSERT_EQ(ret, (int32_t)0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (context != NULL) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        free(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_set_jpeg_config">hb_mm_mc_set_jpeg_config<a href="#hb_mm_mc_set_jpeg_config" class="hash-link" aria-label="hb_mm_mc_set_jpeg_config的直接链接" title="hb_mm_mc_set_jpeg_config的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_set_jpeg_config(media_codec_context_t
*context, const mc_jpeg_enc_params_t *params)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[IN] const mc_jpeg_enc_params_t *params：JPEG编码参数</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>设置JPEG编码参数，该参数为动态参数，适用于JPEG。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_jpeg_config">hb_mm_mc_get_jpeg_config</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_get_fd">hb_mm_mc_get_fd<a href="#hb_mm_mc_get_fd" class="hash-link" aria-label="hb_mm_mc_get_fd的直接链接" title="hb_mm_mc_get_fd的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_get_fd(media_codec_context_t * context, hb_s32
*fd)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[OUT] hb_s32 *fd：设备节点fd</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>获取设备节点fd，可用于select操作，监听编解码结果。</p>
<p>【示例代码】</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &quot;hb_media_codec.h&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &quot;hb_media_error.h&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct MediaCodecTestContext {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_context_t *context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char *inputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char *outputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int abnormal;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int32_t duration; // s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} MediaCodecTestContext;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Uint64 osal_gettime(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct timespec tp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    clock_gettime(CLOCK_MONOTONIC, &amp;tp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return ((Uint64)tp.tv_sec*1000 + tp.tv_nsec/1000000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static void do_poll_encoding_select(void *arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int pollFd = -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    FILE *outFile;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int lastStream = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fd_set readFds;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MediaCodecTestContext *ctx = (MediaCodecTestContext *)arg;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_context_t *context = ctx-&gt;context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char *outputFileName = ctx-&gt;outputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_inter_status_t status;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    outFile = fopen(outputFileName, &quot;wb&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!outFile) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_get_fd(context, &amp;pollFd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    do {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        FD_ZERO(&amp;readFds);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        FD_SET(pollFd, &amp;readFds);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = select(pollFd+1, &amp;readFds, NULL, NULL, NULL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ret &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            printf(&quot;Failed to select fd = %d.(err %s)\n&quot;, pollFd, strerror(errno));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ctx-&gt;abnormal = TRUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else if (ret == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            printf(&quot;Time out to select fd = %d.\n&quot;, pollFd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ctx-&gt;abnormal = TRUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (FD_ISSET(pollFd, &amp;readFds)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ASSERT_EQ(hb_mm_mc_get_status(context, &amp;status), (int32_t)0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (ctx-&gt;testLog) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    printf(&quot;%s[%d:%d] output count %d input count %d\n&quot;, TAG, getpid(), gettid(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    status.cur_output_buf_cnt, status.cur_input_buf_cnt);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                media_codec_buffer_t outputBuffer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                media_codec_output_buffer_info_t info;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                memset(&amp;outputBuffer, 0x00, sizeof(media_codec_buffer_t));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                memset(&amp;info, 0x00, sizeof(media_codec_output_buffer_info_t));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ret = hb_mm_mc_dequeue_output_buffer(context, &amp;outputBuffer, &amp;info, 100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (!ret &amp;&amp; outFile) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    fwrite(outputBuffer.vstream_buf.vir_ptr, outputBuffer.vstream_buf.size, 1, outFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ret = hb_mm_mc_queue_output_buffer(context, &amp;outputBuffer, 100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (outputBuffer.vstream_buf.stream_end) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        printf(&quot;%There is no more output data!\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        lastStream = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        ctx-&gt;abnormal = TRUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (ret != (int32_t)HB_MEDIA_ERR_WAIT_TIMEOUT) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        printf(&quot;Dequeue output buffer fail.\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } while (!lastStream &amp;&amp; !ctx-&gt;abnormal);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ERR:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (pollFd) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        hb_mm_mc_close_fd(context, pollFd)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (outFile)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fclose(outFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static void do_poll_encoding(void *arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pthread_t thread_id;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void* retVal;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    FILE *inFile;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int noMoreInput = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MediaCodecTestContext *ctx = (MediaCodecTestContext *)arg;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_context_t *context = ctx-&gt;context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char *inputFileName = ctx-&gt;inputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char *outputFileName = ctx-&gt;outputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_state_t state = MEDIA_CODEC_STATE_NONE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    inFile = fopen(inputFileName, &quot;rb&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!inFile) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_initialize(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_configure(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_av_codec_startup_params_t startup_params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    startup_params.video_enc_startup_params.receive_frame_number = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_start(context, &amp;startup_params);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pthread_create(&amp;thread_id, NULL, (void* (*)(void*))do_poll_encoding_select, ctx);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    do {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        media_codec_buffer_t inputBuffer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        memset(&amp;inputBuffer, 0x00, sizeof(media_codec_buffer_t));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = hb_mm_mc_dequeue_input_buffer(context, &amp;inputBuffer, 100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ret = fread(inputBuffer.vframe_buf.vir_ptr[0], 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                inputBuffer.vframe_buf.size, inFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                printf(&quot;There is no more input data!\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                inputBuffer.vframe_buf.frame_end = TRUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                noMoreInput = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ret = hb_mm_mc_queue_input_buffer(context, &amp;inputBuffer, 100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                printf(&quot;Queue input buffer fail.\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ret != (int32_t)HB_MEDIA_ERR_WAIT_TIMEOUT) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                printf(&quot;Dequeue input buffer fail.\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }while(!noMoreInput &amp;&amp; !ctx-&gt;abnormal);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pthread_join(thread_id, &amp;retVal);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_mm_mc_stop(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_mm_mc_release(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    context = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ERR:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_mm_mc_get_state(context, &amp;state);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (context &amp;&amp; state != MEDIA_CODEC_STATE_UNINITIALIZED) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        hb_mm_mc_stop(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        hb_mm_mc_release(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (inFile)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fclose(inFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main(int argc, char *argv[])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char outputFileName[MAX_FILE_PATH] = &quot;./tmp.yuv&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char inputFileName[MAX_FILE_PATH] = &quot;./output.stream&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_codec_enc_params_t *params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_context_t context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memset(&amp;context, 0x00, sizeof(media_codec_context_t));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    context.codec_id = MEDIA_CODEC_ID_H265;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    context.encoder = TRUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params = &amp;context.video_enc_params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;width = 640;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;height = 480;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;pix_fmt = MC_PIXEL_FORMAT_YUV420P;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;frame_buf_count = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;external_frame_buf = FALSE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;bitstream_buf_count = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rc_params.mode = MC_AV_RC_MODE_H265CBR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_get_rate_control_config(&amp;context, &amp;params-&gt;rc_params);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rc_params.h265_cbr_params.bit_rate = 5000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rc_params.h265_cbr_params.frame_rate = 30;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rc_params.h265_cbr_params.intra_period = 30;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;gop_params.decoding_refresh_type = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;gop_params.gop_preset_idx = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rot_degree = MC_CCW_0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;mir_direction = MC_DIRECTION_NONE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;frame_cropping_flag = FALSE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MediaCodecTestContext ctx;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memset(&amp;ctx, 0x00, sizeof(ctx));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ctx.context = &amp;context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ctx.inputFileName = inputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ctx.outputFileName = outputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ctx.duration = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    do_poll_encoding(&amp;ctx);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_close_fd">hb_mm_mc_close_fd<a href="#hb_mm_mc_close_fd" class="hash-link" aria-label="hb_mm_mc_close_fd的直接链接" title="hb_mm_mc_close_fd的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_close_fd(media_codec_context_t * context,
hb_s32 fd)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[IN] hb_s32 fd：设备节点fd</li>
</ul>
<p>【 返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>关闭设备节点。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_fd">hb_mm_mc_get_fd</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_set_camera">hb_mm_mc_set_camera<a href="#hb_mm_mc_set_camera" class="hash-link" aria-label="hb_mm_mc_set_camera的直接链接" title="hb_mm_mc_set_camera的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_set_camera(media_codec_context_t *context,
hb_s32 pipeline, hb_s32 channel_port_id)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[IN] hb_s32 pipeline：pipeline</li>
<li>[IN] hb_s32 channel_port_id：通道端口号</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>设置VIO的camera信息，该参数为静态参数，适用于H264/H265。</p>
<p>【示例代码】</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &quot;hb_media_codec.h&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &quot;hb_media_error.h&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct _media_codec_context {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_id_t codec_id;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_bool encoder;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 instance_index;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    union {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mc_video_codec_enc_params_t video_enc_params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mc_video_codec_dec_params_t video_dec_params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mc_audio_codec_enc_params_t audio_enc_params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mc_audio_codec_dec_params_t audio_dec_params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} media_codec_context_t;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void MediaCodecAPITest::init_params_H265() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memset(&amp;context, 0x00, sizeof(media_codec_context_t));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    context.codec_id = MEDIA_CODEC_ID_H265;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    context.encoder = TRUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params = &amp;context.video_enc_params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;width = mGlobalWidth;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;height = mGlobalHeight;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;pix_fmt = mGlobalPixFmt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;frame_buf_count = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;external_frame_buf = FALSE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;bitstream_buf_count = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rc_params.mode = MC_AV_RC_MODE_H265CBR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EXPECT_EQ(hb_mm_mc_get_rate_control_config(&amp;context, &amp;params-&gt;rc_params), (int32_t)0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rc_params.h265_cbr_params.bit_rate = 5000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rc_params.h265_cbr_params.frame_rate = 30;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rc_params.h265_cbr_params.intra_period = 6;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;gop_params.decoding_refresh_type = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;gop_params.gop_preset_idx = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rot_degree = MC_CCW_0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;mir_direction = MC_DIRECTION_NONE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;frame_cropping_flag = FALSE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main(int argc, char *argv[])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    init_params_H265();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EXPECT_EQ(hb_mm_mc_initialize(&amp;context), (int32_t)0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EXPECT_EQ(hb_mm_mc_set_camera(&amp;context, 1, 1), (int32_t)0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EXPECT_EQ(hb_mm_mc_release(&amp;context), (int32_t)0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_get_vui_config">hb_mm_mc_get_vui_config<a href="#hb_mm_mc_get_vui_config" class="hash-link" aria-label="hb_mm_mc_get_vui_config的直接链接" title="hb_mm_mc_get_vui_config的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_get_vui_config(media_codec_context_t *context,
mc_video_vui_params_t *params)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[OUT] mc_video_vui_ params_t *params：VUI参数</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>获取VUI参数。</p>
<p>【其他说明】</p>
<p>目前video编码时设置头  信息中的默认color range为full
range模式，如果设置limit
range需要显式调用hb_mm_mc_set_vui_config接口。</p>
<p>【示例代码】</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &quot;hb_media_codec.h&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &quot;hb_media_error.h&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">typedef enum ENC_CONFIG_MESSAGE {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_NONE = (0 &lt;&lt; 0),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_LONGTERM_REF = (1 &lt;&lt; 0),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_INTRA_REFRESH = (1 &lt;&lt; 1),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_RATE_CONTROL = (1 &lt;&lt; 2),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_DEBLK_FILTER = (1 &lt;&lt; 3),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_SAO = (1 &lt;&lt; 4),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_ENTROPY = (1 &lt;&lt; 5),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_VUI_TIMING = (1 &lt;&lt; 6),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_SLICE = (1 &lt;&lt; 7),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_REQUEST_IDR = (1 &lt;&lt; 8),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_SKIP_PIC = (1 &lt;&lt; 9),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_SMART_BG = (1 &lt;&lt; 10),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_MONOCHROMA = (1 &lt;&lt; 11),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_PRED_UNIT = (1 &lt;&lt; 12),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_TRANSFORM = (1 &lt;&lt; 13),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_ROI = (1 &lt;&lt; 14),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_MODE_DECISION = (1 &lt;&lt; 15),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_USER_DATA = (1 &lt;&lt; 16),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_MJPEG = (1 &lt;&lt; 17),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_JPEG = (1 &lt;&lt; 18),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_CAMERA = (1 &lt;&lt; 19),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_INSERT_USERDATA = (1 &lt;&lt; 20),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_VUI = (1 &lt;&lt; 21),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_3DNR = (1 &lt;&lt; 22),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_REQUEST_IDR_HEADER = (1 &lt;&lt; 23),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_ENABLE_IDR = (1 &lt;&lt; 24),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_TOTAL = (1 &lt;&lt; 25),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} ENC_CONFIG_MESSAGE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct MediaCodecTestContext {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_context_t *context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char *inputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char *outputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int32_t duration; // s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_MESSAGE message;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_longterm_ref_mode_t ref_mode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_rate_control_params_t rc_params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_intra_refresh_params_t intra_refr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_deblk_filter_params_t deblk_filter;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_h265_sao_params_t sao;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_h264_entropy_params_t entropy;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_vui_params_t vui;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_vui_timing_params_t vui_timing;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_slice_params_t slice;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_3dnr_enc_params_t noise_reduction;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_smart_bg_enc_params_t smart_bg;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_pred_unit_params_t pred_unit;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_transform_params_t transform;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_roi_params_t roi;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_mode_decision_params_t mode_decision;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} MediaCodecTestContext;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Uint64 osal_gettime(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct timespec tp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    clock_gettime(CLOCK_MONOTONIC, &amp;tp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return ((Uint64)tp.tv_sec*1000 + tp.tv_nsec/1000000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">uint8_t uuid[] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&quot;dc45e9bd-e6d948b7-962cd820-d923eeef+HorizonAI&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static void set_message(MediaCodecTestContext *ctx) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_context_t *context = ctx-&gt;context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;message &amp; ENC_CONFIG_VUI) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        hb_mm_mc_get_vui_config(context, &amp;ctx-&gt;vui);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = hb_mm_mc_set_vui_config(context, &amp;ctx-&gt;vui);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static void do_sync_encoding(void *arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    FILE *inFile;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    FILE *outFile;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int noMoreInput = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int lastStream = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Uint64 lastTime = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Uint64 curTime = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int needFlush = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MediaCodecTestContext *ctx = (MediaCodecTestContext *)arg;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_context_t *context = ctx-&gt;context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char *inputFileName = ctx-&gt;inputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char *outputFileName = ctx-&gt;outputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_state_t state = MEDIA_CODEC_STATE_NONE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    inFile = fopen(inputFileName, &quot;rb&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!inFile) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    outFile = fopen(outputFileName, &quot;wb&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!outFile) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //get current time</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    lastTime = osal_gettime();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_initialize(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_configure(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_av_codec_startup_params_t startup_params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    startup_params.video_enc_startup_params.receive_frame_number = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_start(context, &amp;startup_params);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_pause(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    do {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    set_message(ctx);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!noMoreInput) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        media_codec_buffer_t inputBuffer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        memset(&amp;inputBuffer, 0x00, sizeof(media_codec_buffer_t));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = hb_mm_mc_dequeue_input_buffer(context, &amp;inputBuffer, 100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            curTime = osal_gettime();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if ((curTime - lastTime)/1000 &lt; (uint32_t)ctx-&gt;duration) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ret = fread(inputBuffer.vframe_buf.vir_ptr[0], 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                inputBuffer.vframe_buf.size, inFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (ret &lt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if(fseek(inFile, 0, SEEK_SET)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        printf(&quot;Failed to rewind input filen&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        ret = fread(inputBuffer.vframe_buf.vir_ptr[0], 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        inputBuffer.vframe_buf.size, inFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if (ret &lt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            printf(&quot;Failed to read input filen&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                printf(&quot;Time up(%d)n&quot;,ctx-&gt;duration);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                printf(&quot;There is no more input data!n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                inputBuffer.vframe_buf.frame_end = TRUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                noMoreInput = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ret = hb_mm_mc_queue_input_buffer(context, &amp;inputBuffer, 100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                printf(&quot;Queue input buffer fail.n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ret != (int32_t)HB_MEDIA_ERR_WAIT_TIMEOUT) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                printf(&quot;Dequeue input buffer fail.n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!lastStream) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        media_codec_buffer_t outputBuffer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        media_codec_output_buffer_info_t info;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        memset(&amp;outputBuffer, 0x00, sizeof(media_codec_buffer_t));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        memset(&amp;info, 0x00, sizeof(media_codec_output_buffer_info_t));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = hb_mm_mc_dequeue_output_buffer(context, &amp;outputBuffer, &amp;info,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        3000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!ret &amp;&amp; outFile) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            fwrite(outputBuffer.vstream_buf.vir_ptr,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                outputBuffer.vstream_buf.size, 1, outFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ret = hb_mm_mc_queue_output_buffer(context, &amp;outputBuffer, 100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                printf(&quot;Queue output buffer fail.n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (outputBuffer.vstream_buf.stream_end) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                printf(&quot;There is no more output data!n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                lastStream = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ret != (int32_t)HB_MEDIA_ERR_WAIT_TIMEOUT) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                printf(&quot;Dequeue output buffer fail.n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (needFlush) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = hb_mm_mc_flush(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        needFlush = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}while(TRUE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">hb_mm_mc_stop(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">hb_mm_mc_release(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">context = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ERR:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">hb_mm_mc_get_state(context, &amp;state);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (context &amp;&amp; state!=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_STATE_UNINITIALIZED) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_mm_mc_stop(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_mm_mc_release(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (inFile)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fclose(inFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (outFile)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fclose(outFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main(int argc, char *argv[])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char outputFileName[MAX_FILE_PATH] = &quot;./tmp.yuv&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char inputFileName[MAX_FILE_PATH] = &quot;./output.stream&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_codec_enc_params_t *params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_context_t context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memset(&amp;context, 0x00, sizeof(media_codec_context_t));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    context.codec_id = MEDIA_CODEC_ID_H265;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    context.encoder = TRUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params = &amp;context.video_enc_params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;width = 640;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;height = 480;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;pix_fmt = MC_PIXEL_FORMAT_YUV420P;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;frame_buf_count = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;external_frame_buf = FALSE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;bitstream_buf_count = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rc_params.mode = MC_AV_RC_MODE_H265CBR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_get_rate_control_config(&amp;context, &amp;params-&gt;rc_params);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rc_params.h265_cbr_params.bit_rate = 5000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rc_params.h265_cbr_params.frame_rate = 30;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rc_params.h265_cbr_params.intra_period = 30;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;gop_params.decoding_refresh_type = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;gop_params.gop_preset_idx = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rot_degree = MC_CCW_0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;mir_direction = MC_DIRECTION_NONE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;frame_cropping_flag = FALSE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MediaCodecTestContext ctx;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memset(&amp;ctx, 0x00, sizeof(ctx));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ctx.context = &amp;context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ctx.inputFileName = inputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ctx.outputFileName = outputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_vui_params_t *vui = &amp;ctx.vui;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_get_vui_config(context, vui);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret != 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vui-&gt;h265_vui.video_signal_type_present_flag = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vui-&gt;h265_vui.video_format = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vui-&gt;h265_vui.video_full_range_flag = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ctx.message = ENC_CONFIG_VUI;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    do_sync_encoding(&amp;ctx);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_set_vui_config">hb_mm_mc_set_vui_config<a href="#hb_mm_mc_set_vui_config" class="hash-link" aria-label="hb_mm_mc_set_vui_config的直接链接" title="hb_mm_mc_set_vui_config的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_set_vui_config(media_codec_context_t *context,
const mc_video_vui_params_t *params)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[IN] const mc_video_vui_params_t *params：VUI参数</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>设置VUI 参数，该参数为静态参数。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_vui_config">hb_mm_mc_get_vui_config</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_get_3dnr_enc_config">hb_mm_mc_get_3dnr_enc_config<a href="#hb_mm_mc_get_3dnr_enc_config" class="hash-link" aria-label="hb_mm_mc_get_3dnr_enc_config的直接链接" title="hb_mm_mc_get_3dnr_enc_config的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_get_3dnr_enc_config(media_codec_context_t
*context, mc_video_3dnr_enc_params_t *params);</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[IN] mc_video_3dnr_enc_params_t *params：3DNR参数</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>获取3DNR参数，该参数为动态参数，适用于H265.</p>
<p>【示例代码】</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &quot;hb_media_codec.h&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &quot;hb_media_error.h&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">typedef enum ENC_CONFIG_MESSAGE {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_NONE = (0 &lt;&lt; 0),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_LONGTERM_REF = (1 &lt;&lt; 0),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_INTRA_REFRESH = (1 &lt;&lt; 1),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_RATE_CONTROL = (1 &lt;&lt; 2),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_DEBLK_FILTER = (1 &lt;&lt; 3),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_SAO = (1 &lt;&lt; 4),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_ENTROPY = (1 &lt;&lt; 5),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_VUI_TIMING = (1 &lt;&lt; 6),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_SLICE = (1 &lt;&lt; 7),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_REQUEST_IDR = (1 &lt;&lt; 8),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_SKIP_PIC = (1 &lt;&lt; 9),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_SMART_BG = (1 &lt;&lt; 10),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_MONOCHROMA = (1 &lt;&lt; 11),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_PRED_UNIT = (1 &lt;&lt; 12),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_TRANSFORM = (1 &lt;&lt; 13),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_ROI = (1 &lt;&lt; 14),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_MODE_DECISION = (1 &lt;&lt; 15),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_USER_DATA = (1 &lt;&lt; 16),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_MJPEG = (1 &lt;&lt; 17),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_JPEG = (1 &lt;&lt; 18),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_CAMERA = (1 &lt;&lt; 19),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_INSERT_USERDATA = (1 &lt;&lt; 20),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_VUI = (1 &lt;&lt; 21),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_3DNR = (1 &lt;&lt; 22),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_REQUEST_IDR_HEADER = (1 &lt;&lt; 23),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_ENABLE_IDR = (1 &lt;&lt; 24),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_TOTAL = (1 &lt;&lt; 25),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} ENC_CONFIG_MESSAGE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct MediaCodecTestContext {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_context_t *context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char *inputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char *outputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int32_t duration; // s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENC_CONFIG_MESSAGE message;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_longterm_ref_mode_t ref_mode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_rate_control_params_t rc_params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_intra_refresh_params_t intra_refr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_deblk_filter_params_t deblk_filter;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_h265_sao_params_t sao;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_h264_entropy_params_t entropy;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_vui_params_t vui;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_vui_timing_params_t vui_timing;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_slice_params_t slice;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_3dnr_enc_params_t noise_reduction;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_smart_bg_enc_params_t smart_bg;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_pred_unit_params_t pred_unit;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_transform_params_t transform;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_roi_params_t roi;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_mode_decision_params_t mode_decision;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} MediaCodecTestContext;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Uint64 osal_gettime(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct timespec tp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    clock_gettime(CLOCK_MONOTONIC, &amp;tp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return ((Uint64)tp.tv_sec*1000 + tp.tv_nsec/1000000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">uint8_t uuid[] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&quot;dc45e9bd-e6d948b7-962cd820-d923eeef+HorizonAI&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static void set_message(MediaCodecTestContext *ctx) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_context_t *context = ctx-&gt;context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ctx-&gt;message &amp; ENC_CONFIG_VUI) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        hb_mm_mc_get_vui_config(context, &amp;ctx-&gt;vui);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = hb_mm_mc_set_vui_config(context, &amp;ctx-&gt;vui);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static void do_sync_encoding(void *arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    FILE *inFile;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    FILE *outFile;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int noMoreInput = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int lastStream = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Uint64 lastTime = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Uint64 curTime = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int needFlush = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MediaCodecTestContext *ctx = (MediaCodecTestContext *)arg;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_context_t *context = ctx-&gt;context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char *inputFileName = ctx-&gt;inputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char *outputFileName = ctx-&gt;outputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_state_t state = MEDIA_CODEC_STATE_NONE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    inFile = fopen(inputFileName, &quot;rb&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!inFile) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    outFile = fopen(outputFileName, &quot;wb&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!outFile) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //get current time</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    lastTime = osal_gettime();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_initialize(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_configure(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_av_codec_startup_params_t startup_params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    startup_params.video_enc_startup_params.receive_frame_number = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_start(context, &amp;startup_params);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_pause(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto ERR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    do {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    set_message(ctx);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!noMoreInput) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        media_codec_buffer_t inputBuffer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        memset(&amp;inputBuffer, 0x00, sizeof(media_codec_buffer_t));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = hb_mm_mc_dequeue_input_buffer(context, &amp;inputBuffer, 100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            curTime = osal_gettime();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if ((curTime - lastTime)/1000 &lt; (uint32_t)ctx-&gt;duration) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ret = fread(inputBuffer.vframe_buf.vir_ptr[0], 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                inputBuffer.vframe_buf.size, inFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (ret &lt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if(fseek(inFile, 0, SEEK_SET)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        printf(&quot;Failed to rewind input filen&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        ret = fread(inputBuffer.vframe_buf.vir_ptr[0], 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        inputBuffer.vframe_buf.size, inFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if (ret &lt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            printf(&quot;Failed to read input filen&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                printf(&quot;Time up(%d)n&quot;,ctx-&gt;duration);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                printf(&quot;There is no more input data!n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                inputBuffer.vframe_buf.frame_end = TRUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                noMoreInput = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ret = hb_mm_mc_queue_input_buffer(context, &amp;inputBuffer, 100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                printf(&quot;Queue input buffer fail.n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ret != (int32_t)HB_MEDIA_ERR_WAIT_TIMEOUT) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                printf(&quot;Dequeue input buffer fail.n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!lastStream) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        media_codec_buffer_t outputBuffer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        media_codec_output_buffer_info_t info;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        memset(&amp;outputBuffer, 0x00, sizeof(media_codec_buffer_t));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        memset(&amp;info, 0x00, sizeof(media_codec_output_buffer_info_t));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = hb_mm_mc_dequeue_output_buffer(context, &amp;outputBuffer, &amp;info,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        3000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!ret &amp;&amp; outFile) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            fwrite(outputBuffer.vstream_buf.vir_ptr,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                outputBuffer.vstream_buf.size, 1, outFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ret = hb_mm_mc_queue_output_buffer(context, &amp;outputBuffer, 100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                printf(&quot;Queue output buffer fail.n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (outputBuffer.vstream_buf.stream_end) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                printf(&quot;There is no more output data!n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                lastStream = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ret != (int32_t)HB_MEDIA_ERR_WAIT_TIMEOUT) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                printf(&quot;Dequeue output buffer fail.n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (needFlush) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = hb_mm_mc_flush(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        needFlush = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}while(TRUE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">hb_mm_mc_stop(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">hb_mm_mc_release(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">context = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ERR:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">hb_mm_mc_get_state(context, &amp;state);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (context &amp;&amp; state!=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_STATE_UNINITIALIZED) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_mm_mc_stop(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_mm_mc_release(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (inFile)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fclose(inFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (outFile)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fclose(outFile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main(int argc, char *argv[])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char outputFileName[MAX_FILE_PATH] = &quot;./tmp.yuv&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char inputFileName[MAX_FILE_PATH] = &quot;./output.stream&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_codec_enc_params_t *params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_context_t context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memset(&amp;context, 0x00, sizeof(media_codec_context_t));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    context.codec_id = MEDIA_CODEC_ID_H265;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    context.encoder = TRUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params = &amp;context.video_enc_params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;width = 640;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;height = 480;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;pix_fmt = MC_PIXEL_FORMAT_YUV420P;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;frame_buf_count = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;external_frame_buf = FALSE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;bitstream_buf_count = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rc_params.mode = MC_AV_RC_MODE_H265CBR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_get_rate_control_config(&amp;context, &amp;params-&gt;rc_params);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rc_params.h265_cbr_params.bit_rate = 5000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rc_params.h265_cbr_params.frame_rate = 30;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rc_params.h265_cbr_params.intra_period = 30;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;gop_params.decoding_refresh_type = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;gop_params.gop_preset_idx = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;rot_degree = MC_CCW_0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;mir_direction = MC_DIRECTION_NONE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;frame_cropping_flag = FALSE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MediaCodecTestContext ctx;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memset(&amp;ctx, 0x00, sizeof(ctx));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ctx.context = &amp;context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ctx.inputFileName = inputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ctx.outputFileName = outputFileName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_3dnr_enc_params_t *noise_rd = &amp;ctx.noise_reduction;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_get_3dnr_enc_config(context, noise_rd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    noise_rd-&gt;nr_y_enable = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    noise_rd-&gt;nr_cb_enable = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    noise_rd-&gt;nr_cr_enable = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    noise_rd-&gt;nr_est_enable = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ctx.message = ENC_CONFIG_3DNR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    do_sync_encoding(&amp;ctx);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_set_3dnr_enc_config">hb_mm_mc_set_3dnr_enc_config<a href="#hb_mm_mc_set_3dnr_enc_config" class="hash-link" aria-label="hb_mm_mc_set_3dnr_enc_config的直接链接" title="hb_mm_mc_set_3dnr_enc_config的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_set_3dnr_enc_config(media_codec_context_t
*context, const mc_video_3dnr_enc_params_t *params);</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[IN] const mc_video_3dnr_enc_params_t *params：3DNR参数</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>设置3DNR参数，该参数为动态参数，适用于H265。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_3dnr_enc_config">hb_mm_mc_get_3dnr_enc_config</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_request_idr_header">hb_mm_mc_request_idr_header<a href="#hb_mm_mc_request_idr_header" class="hash-link" aria-label="hb_mm_mc_request_idr_header的直接链接" title="hb_mm_mc_request_idr_header的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_request_idr_header(media_codec_context_t
*context, hb_u32 force_header)</p>
<p>【参数描述 】</p>
<ul>
<li>
<p>[IN] media_codec_context_t *context：指定codec类型的context</p>
</li>
<li>
<p>[IN] hb_u32 force_header：</p>
<blockquote>
<p>0 : No froced header(VPS/SPS/PPS)</p>
<p>1 : Forced header before IDR frame</p>
<p>2 : Forced header before I frame for H264 or forced header before
CRA and IDR frame for H265</p>
</blockquote>
</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>请求帧头IDR帧头信息，适用于H264/H265。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_longterm_ref_mode">hb_mm_mc_get_longterm_ref_mode</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_enable_idr_frame">hb_mm_mc_enable_idr_frame<a href="#hb_mm_mc_enable_idr_frame" class="hash-link" aria-label="hb_mm_mc_enable_idr_frame的直接链接" title="hb_mm_mc_enable_idr_frame的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_enable_idr_frame(media_codec_context_t
*context, hb_bool enable)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[IN] hb_bool enable：0：不使能；1：使能；</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>使能IDR帧，适用于H264/H265。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_longterm_ref_mode">hb_mm_mc_get_longterm_ref_mode</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_register_audio_encoder">hb_mm_mc_register_audio_encoder<a href="#hb_mm_mc_register_audio_encoder" class="hash-link" aria-label="hb_mm_mc_register_audio_encoder的直接链接" title="hb_mm_mc_register_audio_encoder的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_register_audio_encoder(hb_s32 *handle,
mc_audio_encode_param_t *encoder)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] hb_s32 *handle：编码器句柄</li>
<li>[IN] mc_audio_encode_param_t *encoder：audio编码器描述符；</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>注册audio编码器，适用于Audio。</p>
<p>【示例代码】</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &quot;hb_media_codec.h&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &quot;hb_media_error.h&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &quot;include/aac.h&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main(int argc, char *argv[])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_audio_codec_enc_params_t *params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_context_t context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memset(&amp;context, 0x00, sizeof(media_codec_context_t));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    context.codec_id = MEDIA_CODEC_ID_AAC;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    context.encoder = TRUE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params = &amp;context.audio_enc_params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;bit_rate = 128000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;frame_buf_count = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;packet_count = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;sample_fmt = MC_AV_SAMPLE_FMT_S16;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;sample_rate = MC_AV_SAMPLE_RATE_16000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;channel_layout = MC_AV_CHANNEL_LAYOUT_STEREO;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;channels = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_aac_enc_config_t config;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    config.profile = MC_AAC_PROFILE_LOW;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    config.type = MC_AAC_DATA_TYPE_ADTS;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;enc_config = &amp;config;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int handle;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_audio_encode_param_t encoder;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    encoder.ff_type = MEDIA_CODEC_ID_AAC;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    snprintf(encoder.ff_codec_name, sizeof(encoder.ff_codec_name), &quot;aacenc&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    encoder.ff_audio_open_encoder = ff_audio_aac_open_encoder;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    encoder.ff_audio_encode_frame = ff_audio_aac_encode_frm;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    encoder.ff_audio_close_encoder = ff_audio_aac_close_encoder;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_register_audio_encoder(&amp;handle, &amp;encoder);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    printf(&quot;handle = %d\n&quot;, handle);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ASSERT_EQ(ret, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_unregister_audio_encoder(handle);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ASSERT_EQ(ret, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_unregister_audio_encoder">hb_mm_mc_unregister_audio_encoder<a href="#hb_mm_mc_unregister_audio_encoder" class="hash-link" aria-label="hb_mm_mc_unregister_audio_encoder的直接链接" title="hb_mm_mc_unregister_audio_encoder的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_unregister_audio_encoder(hb_s32 handle)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] hb_s32 *handle：编码器句柄</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>注销audio编码器，适用于Audio。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_register_audio_encoder">hb_mm_mc_register_audio_encoder</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_register_audio_decoder">hb_mm_mc_register_audio_decoder<a href="#hb_mm_mc_register_audio_decoder" class="hash-link" aria-label="hb_mm_mc_register_audio_decoder的直接链接" title="hb_mm_mc_register_audio_decoder的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_register_audio_decoder(hb_s32 *handle,
mc_audio_decode_param_t *decoder)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] hb_s32 *handle：解码器句柄</li>
<li>[IN] mc_audio_decode_param_t *decoder：audio解码器描述符；</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>注册audio解码器，适用于Audio。</p>
<p>【示例代码】</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &quot;hb_media_codec.h&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &quot;hb_media_error.h&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &quot;include/aac.h&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main(int argc, char *argv[])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_audio_codec_dec_params_t *params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_context_t context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memset(&amp;context, 0x00, sizeof(media_codec_context_t));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    context.codec_id = MEDIA_CODEC_ID_AAC;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    context.encoder = FALSE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params = &amp;context.audio_dec_params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;feed_mode = MC_FEEDING_MODE_FRAME_SIZE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;packet_buf_size = 1024;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;packet_count = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;frame_cache_size = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;frame_buf_count = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_aac_dec_config_t config;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    config.sample_rate = MC_AV_SAMPLE_RATE_8000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    config.channels = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    config.sample_fmt = MC_AV_SAMPLE_FMT_S16;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    params-&gt;dec_config = &amp;config;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_audio_decode_param_t decoder;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    decoder.ff_type = MEDIA_CODEC_ID_AAC;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    snprintf(decoder.ff_codec_name, sizeof(decoder.ff_codec_name), &quot;aacdec&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    decoder.ff_audio_open_decoder = ff_audio_aac_open_decoder;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    decoder.ff_audio_decode_frame = ff_audio_aac_decode_frm;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    decoder.ff_audio_close_decoder = ff_audio_aac_close_decoder;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_register_audio_decoder(&amp;handle, &amp;decoder);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ASSERT_EQ(ret, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = hb_mm_mc_unregister_audio_decoder(handle);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ASSERT_EQ(ret, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_unregister_audio_decoder">hb_mm_mc_unregister_audio_decoder<a href="#hb_mm_mc_unregister_audio_decoder" class="hash-link" aria-label="hb_mm_mc_unregister_audio_decoder的直接链接" title="hb_mm_mc_unregister_audio_decoder的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_unregister_audio_decoder(hb_s32 handle)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] hb_s32 *handle：解码器句柄；</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>注销audio解码器，适用于Audio。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_register_audio_decoder">hb_mm_mc_register_audio_decoder</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_get_explicit_header_config">hb_mm_mc_get_explicit_header_config<a href="#hb_mm_mc_get_explicit_header_config" class="hash-link" aria-label="hb_mm_mc_get_explicit_header_config的直接链接" title="hb_mm_mc_get_explicit_header_config的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_get_explicit_header_config
(media_codec_context_t *context, hb_s32 *status)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[OUT] hb_s32 *status：使能/不使能头信息和IDR帧编码成一帧</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>获取头信息和IDR帧是否编码成一帧的配置，0：IDR和头信息独立，1：IDR和头信息合成一帧，适用于H264/H265。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_longterm_ref_mode">hb_mm_mc_get_longterm_ref_mode</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_set_explicit_header_config">hb_mm_mc_set_explicit_header_config<a href="#hb_mm_mc_set_explicit_header_config" class="hash-link" aria-label="hb_mm_mc_set_explicit_header_config的直接链接" title="hb_mm_mc_set_explicit_header_config的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_set_explicit_header_config
(media_codec_context_t *context, hb_s32 status)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[IN] hb_s32 status：使能/不使能头信息和IDR帧编码成一帧</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>使能/不使能头信息和I帧编码成一帧，该参数为静态参数，0：IDR和头信息独立，1：IDR和头信息合成一帧，适用于H264/H265。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_longterm_ref_mode">hb_mm_mc_get_longterm_ref_mode</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_get_roi_avg_qp">hb_mm_mc_get_roi_avg_qp<a href="#hb_mm_mc_get_roi_avg_qp" class="hash-link" aria-label="hb_mm_mc_get_roi_avg_qp的直接链接" title="hb_mm_mc_get_roi_avg_qp的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_get_roi_avg_qp(media_codec_context_t *
context, hb_u32 * params)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[OUT] hb_u32 *params：ROI 平均QP</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>获取ROI 平均QP值，0：代表该值由用户设定得QPMAP决定，适用于H264/H265。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_longterm_ref_mode">hb_mm_mc_get_longterm_ref_mode</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="hb_mm_mc_set_roi_avg_qp">hb_mm_mc_set_roi_avg_qp<a href="#hb_mm_mc_set_roi_avg_qp" class="hash-link" aria-label="hb_mm_mc_set_roi_avg_qp的直接链接" title="hb_mm_mc_set_roi_avg_qp的直接链接">​</a></h4>
<p>【函数声明】</p>
<p>hb_s32 hb_mm_mc_set_roi_avg_qp(media_codec_context_t *
context, hb_u32 params)</p>
<p>【参数描述】</p>
<ul>
<li>[IN] media_codec_context_t *context：指定codec类型的context</li>
<li>[IN] hb_u32 params：ROI平均QP值</li>
</ul>
<p>【返回值】</p>
<ul>
<li>0：操作成功</li>
<li>HB_MEDIA_ERR_UNKNOWN： 未知错误</li>
<li>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED：操作不允许</li>
<li>HB_MEDIA_ERR_INVALID_INSTANCE：无效实例</li>
<li>HB_MEDIA_ERR_INVALID_PARAMS：无效参数</li>
</ul>
<p>【功能描述】</p>
<p>设置ROI编码平均QP值，该参数为动态参数，0：表示使用设置的QP
Map中所有值得平均值，该值在RC模式为CBR或者AVBR时才能使编码效果生效，适用于H264/H265。</p>
<p>【示例代码】</p>
<p>参考 <a href="#hb_mm_mc_get_longterm_ref_mode">hb_mm_mc_get_longterm_ref_mode</a></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="主要参数说明">主要参数说明<a href="#主要参数说明" class="hash-link" aria-label="主要参数说明的直接链接" title="主要参数说明的直接链接">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="media_codec_state_t">media_codec_state_t<a href="#media_codec_state_t" class="hash-link" aria-label="media_codec_state_t的直接链接" title="media_codec_state_t的直接链接">​</a></h4>
<p>【描述】</p>
<p>定义Media codec的内部工作状态。</p>
<p>【定义】</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">typedef enum _media_codec_state {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_STATE_NONE = -1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_STATE_UNINITIALIZED,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_STATE_INITIALIZED,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_STATE_CONFIGURED,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_STATE_STARTED,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_STATE_PAUSED,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_STATE_FLUSHING,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_STATE_ERROR,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_STATE_TOTAL,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} media_codec_state_t;</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="media_codec_id_t">media_codec_id_t<a href="#media_codec_id_t" class="hash-link" aria-label="media_codec_id_t的直接链接" title="media_codec_id_t的直接链接">​</a></h4>
<p>【描述】</p>
<p>定义MediaCodec支持的codec id。</p>
<p>【定义】</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">typedef enum _media_codec_id {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_NONE = -1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* Video Codecs */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_H264,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_H265,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_MJPEG,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_JPEG,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* Audio Codecs */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_FLAC,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_PCM_MULAW,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_PCM_ALAW,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_ADPCM_G726,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_ADPCM,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_AAC,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_MP3,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_MP2,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_TAK,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_AC3,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_WMA,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_AMR,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_APE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_G729,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_G723,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_G722,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_IAC,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_RALF,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_QDMC,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_DTS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_GSM,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_TTA,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_QCELP,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_MLP,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_ATRAC1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_IMC,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_EAC,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_MP1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_SIPR,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_OPUS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_CELT,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_MOV_TEXT,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MEDIA_CODEC_ID_TOTAL,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} media_codec_id_t;</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="mc_video_rate_control_mode_t">mc_video_rate_control_mode_t<a href="#mc_video_rate_control_mode_t" class="hash-link" aria-label="mc_video_rate_control_mode_t的直接链接" title="mc_video_rate_control_mode_t的直接链接">​</a></h4>
<p>【描述】</p>
<p>定义视频的码率控制方式，目前只支持H264/H265和MJPEG编码通道的码率控制。</p>
<p>【定义】</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">typedef enum _mc_video_rate_control_mode {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MC_AV_RC_MODE_NONE = -1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MC_AV_RC_MODE_H264CBR,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MC_AV_RC_MODE_H264VBR,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MC_AV_RC_MODE_H264AVBR,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MC_AV_RC_MODE_H264FIXQP,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MC_AV_RC_MODE_H264QPMAP,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MC_AV_RC_MODE_H265CBR,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MC_AV_RC_MODE_H265VBR,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MC_AV_RC_MODE_H265AVBR,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MC_AV_RC_MODE_H265FIXQP,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MC_AV_RC_MODE_H265QPMAP,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MC_AV_RC_MODE_MJPEGFIXQP,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MC_AV_RC_MODE_TOTAL,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} mc_video_rate_control_mode_t;</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="mc_h264_cbr_params_t">mc_h264_cbr_params_t<a href="#mc_h264_cbr_params_t" class="hash-link" aria-label="mc_h264_cbr_params_t的直接链接" title="mc_h264_cbr_params_t的直接链接">​</a></h4>
<p>【描述】</p>
<p>定义H264的CBR控制方式下的可调节的参数集。</p>
<p>【定义】</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct _mc_h264_cbr_params {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 intra_period;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 intra_qp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 bit_rate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 frame_rate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 initial_rc_qp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 vbv_buffer_size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 mb_level_rc_enalbe;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 min_qp_I;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 max_qp_I;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 min_qp_P;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 max_qp_P;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 min_qp_B;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 max_qp_B;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 hvs_qp_enable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 hvs_qp_scale;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 max_delta_qp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_bool qp_map_enable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} mc_h264_cbr_params_t;</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="mc_h264_vbr_params_t">mc_h264_vbr_params_t<a href="#mc_h264_vbr_params_t" class="hash-link" aria-label="mc_h264_vbr_params_t的直接链接" title="mc_h264_vbr_params_t的直接链接">​</a></h4>
<p>【描述】</p>
<p>定义H264的VBR控制方式下的可调节的参数集。</p>
<p>【定义】</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct _mc_h264_vbr_params {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 intra_period;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 intra_qp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 frame_rate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_bool qp_map_enable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} mc_h264_vbr_params_t;</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="mc_h264_avbr_params_t">mc_h264_avbr_params_t<a href="#mc_h264_avbr_params_t" class="hash-link" aria-label="mc_h264_avbr_params_t的直接链接" title="mc_h264_avbr_params_t的直接链接">​</a></h4>
<p>【描述】</p>
<p>定义H264的AVBR控制方式下的可调节的参数集。</p>
<p>【定义】</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct _mc_h264_avbr_params {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 intra_period;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 intra_qp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 bit_rate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 frame_rate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 initial_rc_qp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 vbv_buffer_size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 mb_level_rc_enalbe;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 min_qp_I;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 max_qp_I;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 min_qp_P;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 max_qp_P;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 min_qp_B;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 max_qp_B;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 hvs_qp_enable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 hvs_qp_scale;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 max_delta_qp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_bool qp_map_enable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} mc_h264_avbr_params_t;</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="mc_h264_fix_qp_params_t">mc_h264_fix_qp_params_t<a href="#mc_h264_fix_qp_params_t" class="hash-link" aria-label="mc_h264_fix_qp_params_t的直接链接" title="mc_h264_fix_qp_params_t的直接链接">​</a></h4>
<p>【描述】</p>
<p>定义H264的FixQP控制方式下的可调节的参数集。</p>
<p>【定义】</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct _mc_h264_fix_qp_params {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 intra_period;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 frame_rate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 force_qp_I;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 force_qp_P;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 force_qp_B;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} mc_h264_fix_qp_params_t;</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="mc_h264_qp_map_params_t">mc_h264_qp_map_params_t<a href="#mc_h264_qp_map_params_t" class="hash-link" aria-label="mc_h264_qp_map_params_t的直接链接" title="mc_h264_qp_map_params_t的直接链接">​</a></h4>
<p>【描述】</p>
<p>定义H264的QPMAP控制方式下的可调节的参数集。</p>
<p>【定义】</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct _mc_h264_qp_map_params {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 intra_period;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 frame_rate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_byte qp_map_array;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 qp_map_array_count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} mc_h264_qp_map_params_t;</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="mc_h265_cbr_params_t">mc_h265_cbr_params_t<a href="#mc_h265_cbr_params_t" class="hash-link" aria-label="mc_h265_cbr_params_t的直接链接" title="mc_h265_cbr_params_t的直接链接">​</a></h4>
<p>【描述】</p>
<p>定义H265的CBR控制方式下的可调节的参数集。</p>
<p>【定义】</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct _mc_h265_cbr_params {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 intra_period;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 intra_qp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 bit_rate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 frame_rate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 initial_rc_qp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 vbv_buffer_size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 ctu_level_rc_enalbe;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 min_qp_I;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 max_qp_I;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 min_qp_P;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 max_qp_P;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 min_qp_B;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 max_qp_B;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 hvs_qp_enable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 hvs_qp_scale;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 max_delta_qp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_bool qp_map_enable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} mc_h265_cbr_params_t;</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="mc_h265_vbr_params_t">mc_h265_vbr_params_t<a href="#mc_h265_vbr_params_t" class="hash-link" aria-label="mc_h265_vbr_params_t的直接链接" title="mc_h265_vbr_params_t的直接链接">​</a></h4>
<p>【描述】</p>
<p>定义H265的VBR控制方式下的可调节的参数集。</p>
<p>【定义】</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct _mc_h265_vbr_params {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 intra_period;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 intra_qp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 frame_rate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_bool qp_map_enable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} mc_h265_vbr_params_t;</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="mc_h265_avbr_params_t">mc_h265_avbr_params_t<a href="#mc_h265_avbr_params_t" class="hash-link" aria-label="mc_h265_avbr_params_t的直接链接" title="mc_h265_avbr_params_t 的直接链接">​</a></h4>
<p>【描述】</p>
<p>定义H265的AVBR控制方式下的可调节的参数集。</p>
<p>【定义】</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct _mc_h265_avbr_params {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 intra_period;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 intra_qp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 bit_rate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 frame_rate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 initial_rc_qp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 vbv_buffer_size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 ctu_level_rc_enalbe;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 min_qp_I;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 max_qp_I;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 min_qp_P;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 max_qp_P;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 min_qp_B;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 max_qp_B;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 hvs_qp_enable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 hvs_qp_scale;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 max_delta_qp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_bool qp_map_enable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} mc_h265_avbr_params_t;</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="mc_h265_fix_qp_params_t">mc_h265_fix_qp_params_t<a href="#mc_h265_fix_qp_params_t" class="hash-link" aria-label="mc_h265_fix_qp_params_t的直接链接" title="mc_h265_fix_qp_params_t的直接链接">​</a></h4>
<p>【描述】</p>
<p>定义H265的FixQP控制方式下的可调节的参数集。</p>
<p>【定义】</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct _mc_h265_fix_qp_params {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 intra_period;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 frame_rate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 force_qp_I;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 force_qp_P;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 force_qp_B;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} mc_h265_fix_qp_params_t;</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="mc_h265_qp_map_params_t">mc_h265_qp_map_params_t<a href="#mc_h265_qp_map_params_t" class="hash-link" aria-label="mc_h265_qp_map_params_t的直接链接" title="mc_h265_qp_map_params_t的直接链接">​</a></h4>
<p>【描述】</p>
<p>定义H265的QPMAP控制方式下的可调节的参数集。</p>
<p>【定义】</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct _mc_h265_qp_map_params {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 intra_period;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 frame_rate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_byte qp_map_array;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 qp_map_array_count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} mc_h265_qp_map_params_t;</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="mc_mjpeg_fix_qp_params_t">mc_mjpeg_fix_qp_params_t<a href="#mc_mjpeg_fix_qp_params_t" class="hash-link" aria-label="mc_mjpeg_fix_qp_params_t的直接链接" title="mc_mjpeg_fix_qp_params_t的直接链接">​</a></h4>
<p>【描述】</p>
<p>定义MJPEG的FixQP控制方式下的可调节的参数集。</p>
<p>【定义】</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct _mc_mjpeg_fix_qp_params {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 frame_rate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 quality_factor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} mc_mjpeg_fix_qp_params_t;</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="mc_video_custom_gop_pic_params_t">mc_video_custom_gop_pic_params_t<a href="#mc_video_custom_gop_pic_params_t" class="hash-link" aria-label="mc_video_custom_gop_pic_params_t的直接链接" title="mc_video_custom_gop_pic_params_t的直接链接">​</a></h4>
<p>【描述】</p>
<p>定义自定义的GOP结构表的数据结构。</p>
<p>【定义】</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct _mc_video_custom_gop_pic_params {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 pic_type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 poc_offset;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 pic_qp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 num_ref_picL0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 ref_pocL0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 ref_pocL1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 temporal_id;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} mc_video_custom_gop_pic_params_t;</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="mc_inter_status_t">mc_inter_status_t<a href="#mc_inter_status_t" class="hash-link" aria-label="mc_inter_status_t的直接链接" title="mc_inter_status_t的直接链接">​</a></h4>
<p>【描述】</p>
<p>定义media codec内部状态信息</p>
<p>【定义】</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct _mc_inter_status {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 cur_input_buf_cnt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u64 cur_input_buf_size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 cur_output_buf_cnt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u64 cur_output_buf_size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 left_recv_frame;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 left_enc_frame;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 total_input_buf_cnt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 total_output_buf_cnt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 pipeline;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 channel_port_id;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} mc_inter_status_t;</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="media_codec_context_t">media_codec_context_t<a href="#media_codec_context_t" class="hash-link" aria-label="media_codec_context_t的直接链接" title="media_codec_context_t的直接链接">​</a></h4>
<p>【描述】</p>
<p>定义Media codec的上下文。</p>
<p>【定义】</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct _media_codec_context {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    media_codec_id_t codec_id;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_bool encoder;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 instance_index;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    union {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mc_video_codec_enc_params_t video_enc_params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mc_video_codec_dec_params_t video_dec_params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mc_audio_codec_enc_params_t audio_enc_params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mc_audio_codec_dec_params_t audio_dec_params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_ptr vpf_context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_cmd_prio_t priority;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} media_codec_context_t;</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="mc_video_codec_enc_params_t">mc_video_codec_enc_params_t<a href="#mc_video_codec_enc_params_t" class="hash-link" aria-label="mc_video_codec_enc_params_t的直接链接" title="mc_video_codec_enc_params_t的直接链接">​</a></h4>
<p>【描述】</p>
<p>定义视频编码器的编码参数，视频编码器类型包括H264，H265，MJPEG和JPEG。</p>
<p>【定义】</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct _mc_video_codec_enc_params {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 width, height;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_pixel_format_t pix_fmt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 frame_buf_count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_bool external_frame_buf;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 bitstream_buf_count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 bitstream_buf_size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_rate_control_params_t rc_params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_video_gop_params_t gop_params;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_rotate_degree_t rot_degree;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_mirror_direction_t mir_direction;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 frame_cropping_flag;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_av_codec_rect_t crop_rect;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_bool enable_user_pts;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    union {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mc_h264_enc_config_t h264_enc_config;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mc_h265_enc_config_t h265_enc_config;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mc_mjpeg_enc_config_t mjpeg_enc_config;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mc_jpeg_enc_config_t jpeg_enc_config;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} mc_video_codec_enc_params_t;</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="mc_video_codec_dec_params_t">mc_video_codec_dec_params_t<a href="#mc_video_codec_dec_params_t" class="hash-link" aria-label="mc_video_codec_dec_params_t的直接链接" title="mc_video_codec_dec_params_t的直接链接">​</a></h4>
<p>【描述】</p>
<p>定义视频解码器的解码参数，视频解码器类型包括H264，H265，MJPEG和JPEG。</p>
<p>【定义】</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct _mc_video_codec_dec_params {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_av_stream_feeding_mode_t feed_mode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_pixel_format_t pix_fmt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 bitstream_buf_size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 bitstream_buf_count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_bool external_bitstream_buf;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 frame_buf_count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    union {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mc_h264_dec_config_t h264_dec_config;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mc_h265_dec_config_t h265_dec_config;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mc_mjpeg_dec_config_t mjpeg_dec_config;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mc_jpeg_dec_config_t jpeg_dec_config;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} mc_video_codec_dec_params_t;</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="mc_audio_codec_enc_params_t">mc_audio_codec_enc_params_t<a href="#mc_audio_codec_enc_params_t" class="hash-link" aria-label="mc_audio_codec_enc_params_t的直接链接" title="mc_audio_codec_enc_params_t的直接链接">​</a></h4>
<p>【描述】</p>
<p>定义audio codec的编码参数。</p>
<p>【定义】</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct _mc_audio_codec_enc_params {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_u32 bit_rate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 frame_size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 frame_buf_count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 packet_count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_audio_sample_format_t sample_fmt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_audio_sample_rate_t sample_rate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_audio_channel_layout_t channel_layout;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 channels;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_ptr enc_config;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} mc_audio_codec_enc_params_t;</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="mc_audio_codec_dec_params_t">mc_audio_codec_dec_params_t<a href="#mc_audio_codec_dec_params_t" class="hash-link" aria-label="mc_audio_codec_dec_params_t的直接链接" title="mc_audio_codec_dec_params_t的直接链接">​</a></h4>
<p>【描述】</p>
<p>定义audio codec的解码参数。</p>
<p>【定义】</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct _mc_audio_codec_dec_params {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mc_av_stream_feeding_mode_t feed_mode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 packet_buf_size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 packet_count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 frame_cache_size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 internal_frame_size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_s32 frame_buf_count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hb_ptr dec_config;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} mc_audio_codec_dec_params_t;</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="返回值说明">返回值说明<a href="#返回值说明" class="hash-link" aria-label="返回值说明的直接链接" title="返回值说明的直接链接">​</a></h3>
<table><thead><tr><th>错误码</th><th>宏定义</th><th>描述</th></tr></thead><tbody><tr><td>0xF0000001</td><td>HB_MEDIA_ERR_UNKNOWN</td><td>未知的错误</td></tr><tr><td>0xF0000002</td><td>HB_MEDIA_ERR_CODEC_NOT_FOUND</td><td>找不到对应的codec</td></tr><tr><td>0xF0000003</td><td>HB_MEDIA_ERR_CODEC_OPEN_FAIL</td><td>无法打开codec设备</td></tr><tr><td>0xF0000004</td><td>HB_MEDIA_ERR_CODEC_RESPONSE_TIMEOUT</td><td>codec响应超时</td></tr><tr><td>0xF0000005</td><td>HB_MEDIA_ERR_CODEC_INIT_FAIL</td><td>codec初始化失败</td></tr><tr><td>0xF0000006</td><td>HB_MEDIA_ERR_OPERATION_NOT_ALLOWED</td><td>操作不允许</td></tr><tr><td>0xF0000007</td><td>HB_MEDIA_ERR_INSUFFICIENT_RES</td><td>内部内存资源不足</td></tr><tr><td>0xF0000008</td><td>HB_MEDIA_ERR_NO_FREE_INSTANCE</td><td>没有可用的insta nce（VPU最多32个，JPU最 多64个，Audio最多32个）</td></tr><tr><td>0xF0000009</td><td>HB_MEDIA_ERR_INVALID_PARAMS</td><td>无效的参数</td></tr><tr><td>0xF000000A</td><td>HB_MEDIA_ERR_INVALID_INSTANCE</td><td>无效的实例</td></tr><tr><td>0xF000000B</td><td>HB_MEDIA_ERR_INVALID_BUFFER</td><td>无效的buffer</td></tr><tr><td>0xF000000C</td><td>HB_MEDIA_ERR_INVALID_COMMAND</td><td>无效的指令</td></tr><tr><td>0xF000000D</td><td>HB_MEDIA_ERR_WAIT_TIMEOUT</td><td>等待超时</td></tr><tr><td>0xF000000E</td><td>HB_MEDIA_ERR_FILE_OPERATION_FAILURE</td><td>文件操作失败</td></tr><tr><td>0xF000000F</td><td>HB_MEDIA_ERR_PARAMS_SET_FAILURE</td><td>参数设置失败</td></tr><tr><td>0xF0000010</td><td>HB_MEDIA_ERR_PARAMS_GET_FAILURE</td><td>参数获取失败</td></tr><tr><td>0xF0000011</td><td>HB_MEDIA_ERR_CODING_FAILED</td><td>编解码失败</td></tr><tr><td>0xF0000012</td><td>HB_MEDIA_ERR_OUTPUT_BUF_FULL</td><td>输出buffer满</td></tr><tr><td>0xF0000013</td><td>HB_MEDIA_ERR_UNSUPPORTED_FEATURE</td><td>不支持的功能</td></tr><tr><td>0xF0000014</td><td>HB_MEDIA_ERR_INVALID_PRIORITY</td><td>不支持的优先级</td></tr></tbody></table>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="codec-sample">Codec sample<a href="#codec-sample" class="hash-link" aria-label="Codec sample的直接链接" title="Codec sample的直接链接">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="编码示例">编码示例<a href="#编码示例" class="hash-link" aria-label="编码示例的直接链接" title="编码示例的直接链接">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="功能概述">功能概述<a href="#功能概述" class="hash-link" aria-label="功能概述的直接链接" title="功能概述的直接链接">​</a></h4>
<p>编码 yuv 图像, 生成 h264/h265 视频或 jpg 图片。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="软件架构说明">软件架构说明<a href="#软件架构说明" class="hash-link" aria-label="软件架构说明的直接链接" title="软件架构说明的直接链接">​</a></h5>
<p>采用MediaCodec的poll模式来解耦输入和输出，可使编码帧率性能达到最优。
在主线程中灌YUV数据：取出一个空的input
buffer，配置YUV数据的地址信息（如phys addr），再queue input
buffer并通知编码器处理该帧数据；
另一个线程取输出码流：通过select接收硬件编码完成通知，取出一个硬件填满输出码流的output
buffer，将编码结果写到文件中后归还output buffer。</p>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/encoder2.png" alt="image" class="img_ev3q"></p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="硬件数据流说明">硬件数据流说明<a href="#硬件数据流说明" class="hash-link" aria-label="硬件数据流说明的直接链接" title="硬件数据流说明的直接链接">​</a></h5>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/encoder1.png" alt="image" class="img_ev3q"></p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="代码位置及目录结构">代码位置及目录结构<a href="#代码位置及目录结构" class="hash-link" aria-label="代码位置及目录结构的直接链接" title="代码位置及目录结构的直接链接">​</a></h5>
<p>sample代码位置在工程目录source/hobot-sp-samples/debian/app/multimedia_demo/codec_demo。</p>
<p>目录结构如下：</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">├── README.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">└── sample_venc_vdec</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ├── input_3840x2160_yuv420p.h264</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ├── input_3840x2160_yuv420p.yuv</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ├── Makefile</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ├── sample.c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ├── sample_common.c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ├── sample.h</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ├── sample_vdec.c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    └── sample_venc.c</span><br></span></code></pre></div></div>
<p>根目录包含README.md，简要介绍编译命令，运行帮助信息及命令。</p>
<p>sample_venc_devc下的Makefile用于该目录下的编译。其中，sample.c是main入口的所在文件，sample_common包含了一些共用的api，sample_venc.c包含编码相关函数，sample_vdec.c包含解码相关函数。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="编译">编译<a href="#编译" class="hash-link" aria-label="编译的直接链接" title="编译的直接链接">​</a></h4>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="编译环境">编译环境<a href="#编译环境" class="hash-link" aria-label="编译环境的直接链接" title="编译环境的直接链接">​</a></h5>
<p>板端在安装hobot-sp-samples_*.deb包后，会包含codec_demo源码内容。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="编译说明">编译说明<a href="#编译说明" class="hash-link" aria-label="编译说明的直接链接" title="编译说明的直接链接">​</a></h5>
<p>本sample主要依赖libmm提供的API头文件：</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &quot;hb_media_codec.h&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &quot;hb_media_error.h&quot;</span><br></span></code></pre></div></div>
<p>编译依赖的库有如下：</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">LIBS += -lpthread -ldl -lhbmem -lalog  -lmultimedia</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LIBS += -lavformat -lavcodec -lavutil -lswresample</span><br></span></code></pre></div></div>
<p>编译命令:</p>
<p>板端进入/app/multimedia_demo/codec_demo/sample_venc_vdec目录。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">make</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="运行">运行<a href="#运行" class="hash-link" aria-label="运行的直接链接" title="运行的直接链接">​</a></h4>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="支持平台">支持平台<a href="#支持平台" class="hash-link" aria-label="支持平台的直接链接" title="支持平台的直接链接">​</a></h5>
<p>RDKS100。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="板端部署及配置">板端部署及配置<a href="#板端部署及配置" class="hash-link" aria-label="板端部署及配置的直接链接" title="板端 部署及配置的直接链接">​</a></h5>
<p>刷写系统软件镜像后，本sample的源码位于板端路径：<code>/app/multimedia_demo/codec_demo/sample_venc_vdec</code>；</p>
<p>可能需要用到的资源：</p>
<ul>
<li>输入YUV图像默认包含4K格式的YUV裸流及H264文件，如果测试其他测试请用户自行上传；</li>
</ul>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="运行指南">运行指南<a href="#运行指南" class="hash-link" aria-label="运行指南的直接链接" title="运行指南的直接链接">​</a></h5>
<h6 class="anchor anchorWithStickyNavbar_LWe7" id="运行参数说明">运行参数说明<a href="#运行参数说明" class="hash-link" aria-label="运行参数说明的直接链接" title="运行参数说明的直接链接">​</a></h6>
<p><code>sample_codec</code> ： 应用程序名字</p>
<p>-m：编码或解码，默认编码， 0： encoder 1： decoder</p>
<p>-c：编解码器类型，默认H264， 0：H264 1：H265 2：mjpg 3：jpg</p>
<p>-w：图像宽度，默认3840</p>
<p>-h：图像高度，默认2160</p>
<p>-p：编解码图像格式，默认nv12， 0：yuv420p 1：nv12 2：nv21</p>
<p>-n：测试线程数量，默认1个</p>
<p>-i：输入文件的路径，默认<code>./input_${w}x${h}_${pixfmt}&lt;_thread_idx&gt;.yuv</code></p>
<p>-o：输出文件的路径，默认<code>./output_${w}x${h}_${pixfmt}&lt;_thread_idx&gt;.{code_type}</code></p>
<p>-H：打印帮助信息</p>
<h6 class="anchor anchorWithStickyNavbar_LWe7" id="帮助菜单">帮助菜单<a href="#帮助菜单" class="hash-link" aria-label="帮助菜单的直接链接" title="帮助菜单的直接链接">​</a></h6>
<p>使用<code>./sample_codec --help</code>可以获取帮助菜单，如下所示：</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Usage: ./sample_codec</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        -m --samplemode sample mode, default encoder, {0-encoder, 1-decoder}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        -c --codecid codec id, default h264, {0-h264, 1-h265, 2-mjpeg, 3-jpeg}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        -w --width width, default 3840</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        -h --height height, default 2160</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        -p --pixfmt pix fmt, default nv12, {0-yuv420p, 1-nv12, ..}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        -n --threadnum test thread number, default 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        -i --inputfile input file name, default ./input_${w}x${h}_${pixfmt}&lt;_thread_idx&gt;.yuv</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        -o --outputfile output file name, default ./output_${w}x${h}_${pixfmt}&lt;_thread_idx&gt;.{code_type}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        -H --help print usage</span><br></span></code></pre></div></div>
<h6 class="anchor anchorWithStickyNavbar_LWe7" id="运行方法">运行方法<a href="#运行方法" class="hash-link" aria-label="运行方法的直接链接" title="运行方法的直接链接">​</a></h6>
<p>输入源准备：将测试文件(如input_3840x2160_nv12.yuv)到当前目录 或
用-i指定文件路径；</p>
<p>编码一路 3840x2160 的YUV图像序列，生成 H264 视频码流</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/app/multimedia_demo/codec_demo/sample_venc_vdec/sample_codec</span><br></span></code></pre></div></div>
<p>编码一路 1920x1080 的YUV图像序列，生成 H265 视频码流</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/app/multimedia_demo/codec_demo/sample_venc_vdec/sample_codec -c 1 -w 1920 -h 1080</span><br></span></code></pre></div></div>
<p>编码一张 1920x1088 的YUV图像，生成 jpg 图片</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/app/multimedia_demo/codec_demo/sample_venc_vdec/sample_codec -c 3 -w 1920 -h 1088</span><br></span></code></pre></div></div>
<p>编码两路 3840x2160 的YUV图像序列，生成 H265 视频</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/app/multimedia_demo/codec_demo/sample_venc_vdec/sample_codec -c 1 -n 2</span><br></span></code></pre></div></div>
<p>编码四路 1920x1080 的YUV图像序列，生成 H265 视频</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/app/multimedia_demo/codec_demo/sample_venc_vdec/sample_codec -c 1 -w 1920 -h 1080 -n 4</span><br></span></code></pre></div></div>
<p>VPU CROP读入并编码：将1920x1300（图像尺寸不满足对齐要求）输入按<code>{x=200, y=300, w=1280, h=720}</code>大小读入数据并编码生成 H265 视频</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/app/multimedia_demo/codec_demo/sample_venc_vdec/sample_codec -c 1 -w 1920 -h 1300</span><br></span></code></pre></div></div>
<h6 class="anchor anchorWithStickyNavbar_LWe7" id="运行结果说明">运行结果说明<a href="#运行结果说明" class="hash-link" aria-label="运行结果说明的直接链接" title="运行结果说明的直接链接">​</a></h6>
<p>如下图所示为运行成功</p>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/encoder3.png" alt="image" class="img_ev3q"></p>
<p>查看生成的h264/h265/jpg是否正常</p>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/encoder4.png" alt="image" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="解码示例">解码示例<a href="#解码示例" class="hash-link" aria-label="解码示例的直接链接" title="解码示例的直接链接">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="功能概述-1">功能概述<a href="#功能概述-1" class="hash-link" aria-label="功能概述的直接链接" title="功能概述的直接链接">​</a></h4>
<p>解码h264/h265视频或jpg图片，生成yuv图像。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="软件架构">软件架构<a href="#软件架构" class="hash-link" aria-label="软件架构的直接链接" title="软件架构的直接链接">​</a></h5>
<p>采用MediaCodec的poll模式来解耦输入和输出，可使解码帧率性能达到最优。
在主线程中灌码流数据：取出一个空的input
buffer，配置码流数据的地址信息（如phys addr），再queue input
buffer并通知解码器处理该帧数据；
另一个线程取输出YUV图像：通过select接收硬件解码完成通知，取出一个硬件填满输出图像的output
buffer，将解码结果写到文件中后归还output buffer。</p>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/decoder2.png" alt="image" class="img_ev3q"></p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="硬件数据流说明-1">硬件数据流说明<a href="#硬件数据流说明-1" class="hash-link" aria-label="硬件数据流说明的直接链接" title="硬件数据流说明的直接链接">​</a></h5>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/decoder1.png" alt="image" class="img_ev3q"></p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="代码位置及目录结构-1">代码位置及目录结构<a href="#代码位置及目录结构-1" class="hash-link" aria-label="代码位置及目录结构的直接链接" title="代码位置及目录结构的直接链接">​</a></h5>
<p>sample代码位置在工程目录source/hobot-sp-samples/debian/app/multimedia_demo/codec_demo。</p>
<p>目录结构如下：</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">├── README.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">└── sample_venc_vdec</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ├── input_3840x2160_yuv420p.h264</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ├── input_3840x2160_yuv420p.yuv</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ├── Makefile</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ├── sample.c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ├── sample_common.c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ├── sample.h</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ├── sample_vdec.c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    └── sample_venc.c</span><br></span></code></pre></div></div>
<p>根目录包含README.md，简要介绍编译命令，运行帮助信息及命令。</p>
<p>sample_venc_devc下的Makefile用于该目录下的编译。其中，sample.c是main入口的所在文件，sample_common包含了一些共用的api，sample_venc.c包含编码相关函数，sample_vdec.c包含解码相关函数。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="编译-1">编译<a href="#编译-1" class="hash-link" aria-label="编译的直接链接" title="编译的直接链接">​</a></h4>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="编译环境-1">编译环境<a href="#编译环境-1" class="hash-link" aria-label="编译环境的直接链接" title="编译环境的直接链接">​</a></h5>
<p>板端在安装hobot-sp-samples_*.deb包后，会包含codec_demo源码内容。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="编译说明-1">编译说明<a href="#编译说明-1" class="hash-link" aria-label="编译说明的直接链接" title="编译说明的直接链接">​</a></h5>
<p>本sample主要依赖libmm提供的API头文件：</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &quot;hb_media_codec.h&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &quot;hb_media_error.h&quot;</span><br></span></code></pre></div></div>
<p>编译依赖的库有如下：</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">LIBS += -lpthread -ldl -lhbmem -lalog  -lmultimedia</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LIBS += -lavformat -lavcodec -lavutil -lswresample</span><br></span></code></pre></div></div>
<p>编译命令:</p>
<p>板端进入/app/multimedia_demo/codec_demo/sample_venc_vdec目录。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">make</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="运行-1">运行<a href="#运行-1" class="hash-link" aria-label="运行的直接链接" title="运行的直接链接">​</a></h4>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="支持平台-1">支持平台<a href="#支持平台-1" class="hash-link" aria-label="支持平台的直接链接" title="支持平台的直接链接">​</a></h5>
<p>RDKS100。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="板端部署及配置-1">板端部署及配置<a href="#板端部署及配置-1" class="hash-link" aria-label="板端部署及配置的直接链接" title="板端部署及配置的直接链接">​</a></h5>
<p>刷写系统软件镜像后，本sample的源码位于板端路径：<code>/app/multimedia_demo/codec_demo/sample_venc_vdec</code>；</p>
<p>可能需要用到的资源：</p>
<ul>
<li>输入YUV图像默认包含4K格式的YUV裸流及H264文件，如果测试其他测试请用户自行上传；</li>
</ul>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="运行指南-1">运行指南<a href="#运行指南-1" class="hash-link" aria-label="运行指南的直接链接" title="运行指南的直接链接">​</a></h5>
<h6 class="anchor anchorWithStickyNavbar_LWe7" id=" 运行参数说明-1">运行参数说明<a href="#运行参数说明-1" class="hash-link" aria-label="运行参数说明的直接链接" title="运行参数说明的直接链接">​</a></h6>
<p><code>sample_codec</code> ： 应用程序名字</p>
<p>-m：编码或解码，默认编码， 0： encoder 1： decoder</p>
<p>-c：编解码器类型，默认H264， 0：H264 1：H265 2：mjpg 3：jpg</p>
<p>-w：图像宽度，默认3840</p>
<p>-h：图像高度，默认2160</p>
<p>-p：编解码图像格式，默认nv12， 0：yuv420p 1：nv12 2：nv21</p>
<p>-n：测试线程数量，默认1个</p>
<p>-i：输入文件的路径，默认<code>./input_${w}x${h}_${pixfmt}&lt;_thread_idx&gt;.yuv</code></p>
<p>-o：输出文件的路径，默认<code>./output_${w}x${h}_${pixfmt}&lt;_thread_idx&gt;.{code_type}</code></p>
<p>-H：打印帮助信息</p>
<h6 class="anchor anchorWithStickyNavbar_LWe7" id="帮助菜单-1">帮助菜单<a href="#帮助菜单-1" class="hash-link" aria-label="帮助菜单的直接链接" title="帮助菜单的直接链接">​</a></h6>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Usage: ./sample_codec</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        -m --samplemode sample mode, default encoder, {0-encoder, 1-decoder}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        -c --codecid codec id, default h264, {0-h264, 1-h265, 2-mjpeg, 3-jpeg}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        -w --width width, default 3840</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        -h --height height, default 2160</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        -p --pixfmt pix fmt, default nv12, {0-yuv420p, 1-nv12, ..}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        -n --threadnum test thread number, default 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        -i --inputfile input file name, default ./input_${w}x${h}_${pixfmt}&lt;_thread_idx&gt;.yuv</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        -o --outputfile output file name, default ./output_${w}x${h}_${pixfmt}&lt;_thread_idx&gt;.{code_type}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        -H --help print usage</span><br></span></code></pre></div></div>
<h6 class="anchor anchorWithStickyNavbar_LWe7" id="运行方法-1">运行方法<a href="#运行方法-1" class="hash-link" aria-label="运行方法的直接链接" title="运行方法的直接链接">​</a></h6>
<p>输入源准备：将测试文件(如input_3840x2160_nv12.h264)到当前目录 或
用-i指定文件路径；</p>
<p>解码一路 3840x2160 的 h264 视频, 生成 yuv 图像</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/app/multimedia_demo/codec_demo/sample_venc_vdec/sample_codec -m 1</span><br></span></code></pre></div></div>
<p>解码一路 1920x1080 的 h265 视频, 生成 yuv 图像</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/app/multimedia_demo/codec_demo/sample_venc_vdec/sample_codec -m 1 -c 1 -w 1920 -h 1080</span><br></span></code></pre></div></div>
<p>解码一张 1920x1088 的 jpg 图片, 生成 yuv 图像</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/app/multimedia_demo/codec_demo/sample_venc_vdec/sample_codec -m 1 -c 3 -w 1920 -h 1088</span><br></span></code></pre></div></div>
<p>解码两路 3840x2160 的 h264 视频, 生成 yuv 图像</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/app/multimedia_demo/codec_demo/sample_venc_vdec/sample_codec -m 1 -n 2</span><br></span></code></pre></div></div>
<p>解码四路 1920x1080 的 h265 视频, 生成 yuv 图像</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/app/multimedia_demo/codec_demo/sample_venc_vdec/sample_codec -m 1 -c 1 -n 4 -w 1920 -h 1080</span><br></span></code></pre></div></div>
<h6 class="anchor anchorWithStickyNavbar_LWe7" id="运行结果说明-1">运行结果说明<a href="#运行结果说明-1" class="hash-link" aria-label="运行结果说明的直接链接" title="运行结果说明的直接链接">​</a></h6>
<p>如下图所示为运行成功</p>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/decoder3.png" alt="image" class="img_ev3q"></p>
<p>使用yuvplayer查看生成的yuv图像文件是否正常</p>
<p><img decoding="async" loading="lazy" src="https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/03_multimedia_development/02_S100/codec/decoder4.png" alt="image" class="img_ev3q"></p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"></div><div class="col lastUpdated_JAkA"><span class="theme-last-updated">最后<!-- -->于 <b><time datetime="2025-12-17T16:45:34.000Z" itemprop="dateModified">2025年12月17日</time></b> <!-- -->更新</span></div></div></footer></article><nav class="pagination-nav" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/rdk_doc/rdk_s/Advanced_development/multimedia_development/S100/camera_bringup"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">Camera点亮</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/rdk_doc/rdk_s/Advanced_development/multimedia_development/S100/display"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">显示子系统</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#系统概述" class="table-of-contents__link toc-highlight">系 统概述</a><ul><li><a href="#概述" class="table-of-contents__link toc-highlight">概述</a><ul><li><a href="#jpu硬件特性" class="table-of-contents__link toc-highlight">JPU硬件特性</a></li><li><a href="#vpu硬件特性" class="table-of-contents__link toc-highlight">VPU硬件特性</a></li></ul></li><li><a href="#软件功能" class="table-of-contents__link toc-highlight">软件功能</a><ul><li><a href="#整体框架" class="table-of-contents__link toc-highlight">整体框架</a></li><li><a href="#码率控制模式" class="table-of-contents__link toc-highlight">码率控制模式</a><ul><li><a href="#cbr说明" class="table-of-contents__link toc-highlight">CBR说明</a></li><li><a href="#vbr说明" class="table-of-contents__link toc-highlight">VBR说明</a></li><li><a href="#avbr说明" class="table-of-contents__link toc-highlight">AVBR说明</a></li><li><a href="#fixqp说明" class="table-of-contents__link toc-highlight">FixQp说明</a></li><li><a href="#qpmap说明" class="table-of-contents__link toc-highlight">QPMAP说明</a></li></ul></li></ul></li><li><a href="#调试方法" class="table-of-contents__link toc-highlight">调试方法</a><ul><li><a href="#编码效果调优" class="table-of-contents__link toc-highlight">编码效果调优</a></li><li><a href="#gop结构说明" class="table-of-contents__link toc-highlight">GOP结构说明</a><ul><li><a href="#gop预置结构" class="table-of-contents__link toc-highlight">GOP预置结构</a></li></ul></li><li><a href="#vpu调试方式" class="table-of-contents__link toc-highlight">VPU调试方式</a><ul><li><a href="#编码状态" class="table-of-contents__link toc-highlight">编码状态</a></li><li><a href="#解码状态" class="table-of-contents__link toc-highlight">解码状态</a></li></ul></li><li><a href="#jpu-调试方式" class="table-of-contents__link toc-highlight">JPU 调试方式</a><ul><li><a href="#编码状态-1" class="table-of-contents__link toc-highlight">编码状态</a></li><li><a href="#解码状态-1" class="table-of-contents__link toc-highlight">解码状态</a></li></ul></li></ul></li><li><a href="#典型场景" class="table-of-contents__link toc-highlight">典型场景</a><ul><li><a href="#单路编码" class="table-of-contents__link toc-highlight">单路编码</a></li><li><a href="#单路解码" class="table-of-contents__link toc-highlight">单路解码</a></li><li><a href="#多路编码" class="table-of-contents__link toc-highlight">多路编码</a></li><li><a href="#多路解码" class="table-of-contents__link toc-highlight">多路解码</a></li></ul></li></ul></li><li><a href="#codec-api" class="table-of-contents__link toc-highlight">Codec API</a><ul><li><a href="#mediacodec接口说明" class="table-of-contents__link toc-highlight">MediaCodec接口说明</a><ul><li><a href="#gop" class="table-of-contents__link toc-highlight">GOP</a><ul><li><a href="#gop结构表" class="table-of-contents__link toc-highlight">GOP结构表</a></li><li><a href="#gop预置结构-1" class="table-of-contents__link toc-highlight">GOP预置结构</a></li></ul></li><li><a href="#长期参考帧" class="table-of-contents__link toc-highlight">长期参考帧</a></li><li><a href="#intra-refresh" class="table-of-contents__link toc-highlight">Intra Refresh</a></li><li><a href="#码率控制" class="table-of-contents__link toc-highlight">码率控制</a></li><li><a href="#roi" class="table-of-contents__link toc-highlight">ROI</a></li><li><a href="#输入输出buffer管理" class="table-of-contents__link toc-highlight">输入输出buffer管理</a></li><li><a href="#帧率控制" class="table-of-contents__link toc-highlight">帧率控制</a></li><li><a href="#帧skip设置" class="table-of-contents__link toc-highlight">帧Skip设置</a></li><li><a href="#jpeg编解码限制" class="table-of-contents__link toc-highlight">JPEG编解码限制</a></li></ul></li><li><a href="#api参考" class="table-of-contents__link toc-highlight">API参考</a><ul><li><a href="#hb_mm_mc_get_descriptor" class="table-of-contents__link toc-highlight">hb_mm_mc_get_descriptor</a></li><li><a href="#hb_mm_mc_get_default_context" class="table-of-contents__link toc-highlight">hb_mm_mc_get_default_context</a></li><li><a href="#hb_mm_mc_initialize" class="table-of-contents__link toc-highlight">hb_mm_mc_initialize</a></li><li><a href="#hb_mm_mc_set_callback" class="table-of-contents__link toc-highlight">hb_mm_mc_set_callback</a></li><li><a href="#hb_mm_mc_configure" class="table-of-contents__link toc-highlight">hb_mm_mc_configure</a></li><li><a href="#hb_mm_mc_start" class="table-of-contents__link toc-highlight">hb_mm_mc_start</a></li><li><a href="#hb_mm_mc_stop" class="table-of-contents__link toc-highlight">hb_mm_mc_stop</a></li><li><a href="#hb_mm_mc_pause" class="table-of-contents__link toc-highlight">hb_mm_mc_pause</a></li><li><a href="#hb_mm_mc_flush" class="table-of-contents__link toc-highlight">hb_mm_mc_flush</a></li><li><a href="#hb_mm_mc_release" class="table-of-contents__link toc-highlight">hb_mm_mc_release</a></li><li><a href="#hb_mm_mc_get_state" class="table-of-contents__link toc-highlight">hb_mm_mc_get_state</a></li><li><a href="#hb_mm_mc_get_status" class="table-of-contents__link toc-highlight">hb_mm_mc_get_status</a></li><li><a href="#hb_mm_mc_queue_input_buffer" class="table-of-contents__link toc-highlight">hb_mm_mc_queue_input_buffer</a></li><li><a href="#hb_mm_mc_dequeue_input_buffer" class="table-of-contents__link toc-highlight">hb_mm_mc_dequeue_input_buffer</a></li><li><a href="#hb_mm_mc_queue_output_buffer" class="table-of-contents__link toc-highlight">hb_mm_mc_queue_output_buffer</a></li><li><a href="#hb_mm_mc_dequeue_output_buffer" class="table-of-contents__link toc-highlight">hb_mm_mc_dequeue_output_buffer</a></li><li><a href="#hb_mm_mc_get_longterm_ref_mode" class="table-of-contents__link toc-highlight">hb_mm_mc_get_longterm_ref_mode</a></li><li><a href="#hb_mm_mc_set_longterm_ref_mode" class="table-of-contents__link toc-highlight">hb_mm_mc_set_longterm_ref_mode</a></li><li><a href="#hb_mm_mc_get_intra_refresh_config" class="table-of-contents__link toc-highlight">hb_mm_mc_get_intra_refresh_config</a></li><li><a href="#hb_mm_mc_set_intra_refresh_config" class="table-of-contents__link toc-highlight">hb_mm_mc_set_intra_refresh_config</a></li><li><a href="#hb_mm_mc_get_rate_control_config" class="table-of-contents__link toc-highlight">hb_mm_mc_get_rate_control_config</a></li><li><a href="#hb_mm_mc_set_rate_control_config" class="table-of-contents__link toc-highlight">hb_mm_mc_set_rate_control_config</a></li><li><a href="#hb_mm_mc_get_deblk_filter_config" class="table-of-contents__link toc-highlight">hb_mm_mc_get_deblk_filter_config</a></li><li><a href="#hb_mm_mc_set_deblk_filter_config" class="table-of-contents__link toc-highlight">hb_mm_mc_set_deblk_filter_config</a></li><li><a href="#hb_mm_mc_get_sao_config" class="table-of-contents__link toc-highlight">hb_mm_mc_get_sao_config</a></li><li><a href="#hb_mm_mc_set_sao_config" class="table-of-contents__link toc-highlight">hb_mm_mc_set_sao_config</a></li><li><a href="#hb_mm_mc_get_entropy_config" class="table-of-contents__link toc-highlight">hb_mm_mc_get_entropy_config</a></li><li><a href="#hb_mm_mc_set_entropy_config" class="table-of-contents__link toc-highlight">hb_mm_mc_set_entropy_config</a></li><li><a href="#hb_mm_mc_get_vui_timing_config" class="table-of-contents__link toc-highlight">hb_mm_mc_get_vui_timing_config</a></li><li><a href="#hb_mm_mc_set_vui_timing_config" class="table-of-contents__link toc-highlight">hb_mm_mc_set_vui_timing_config</a></li><li><a href="#hb_mm_mc_get_slice_config" class="table-of-contents__link toc-highlight">hb_mm_mc_get_slice_config</a></li><li><a href="#hb_mm_mc_set_slice_config" class="table-of-contents__link toc-highlight">hb_mm_mc_set_slice_config</a></li><li><a href="#hb_mm_mc_insert_user_data" class="table-of-contents__link toc-highlight">hb_mm_mc_insert_user_data</a></li><li><a href="#hb_mm_mc_request_idr_frame" class="table-of-contents__link toc-highlight">hb_mm_mc_request_idr_frame</a></li><li><a href="#hb_mm_mc_skip_pic" class="table-of-contents__link toc-highlight">hb_mm_mc_skip_pic</a></li><li><a href="#hb_mm_mc_get_smart_bg_enc_config" class="table-of-contents__link toc-highlight">hb_mm_mc_get_smart_bg_enc_config</a></li><li><a href="#hb_mm_mc_set_smart_bg_enc_config" class="table-of-contents__link toc-highlight">hb_mm_mc_set_smart_bg_enc_config</a></li><li><a href="#hb_mm_mc_get_pred_unit_config" class="table-of-contents__link toc-highlight">hb_mm_mc_get_pred_unit_config</a></li><li><a href="#hb_mm_mc_set_pred_unit_config" class="table-of-contents__link toc-highlight">hb_mm_mc_set_pred_unit_config</a></li><li><a href="#hb_mm_mc_get_transform_config" class="table-of-contents__link toc-highlight">hb_mm_mc_get_transform_config</a></li><li><a href="#hb_mm_mc_set_transform_config" class="table-of-contents__link toc-highlight">hb_mm_mc_set_transform_config</a></li><li><a href="#hb_mm_mc_get_roi_config" class="table-of-contents__link toc-highlight">hb_mm_mc_get_roi_config</a></li><li><a href="#hb_mm_mc_set_roi_config" class="table-of-contents__link toc-highlight">hb_mm_mc_set_roi_config</a></li><li><a href="#hb_mm_mc_get_mode_decision_config" class="table-of-contents__link toc-highlight">hb_mm_mc_get_mode_decision_config</a></li><li><a href="#hb_mm_mc_set_mode_decision_config" class="table-of-contents__link toc-highlight">hb_mm_mc_set_mode_decision_config</a></li><li><a href="#hb_mm_mc_get_user_data" class="table-of-contents__link toc-highlight">hb_mm_mc_get_user_data</a></li><li><a href="#hb_mm_mc_release_user_data" class="table-of-contents__link toc-highlight">hb_mm_mc_release_user_data</a></li><li><a href="#hb_mm_mc_get_mjpeg_config" class="table-of-contents__link toc-highlight">hb_mm_mc_get_mjpeg_config</a></li><li><a href="#hb_mm_mc_set_mjpeg_config" class="table-of-contents__link toc-highlight">hb_mm_mc_set_mjpeg_config</a></li><li><a href="#hb_mm_mc_get_jpeg_config" class="table-of-contents__link toc-highlight">hb_mm_mc_get_jpeg_config</a></li><li><a href="#hb_mm_mc_set_jpeg_config" class="table-of-contents__link toc-highlight">hb_mm_mc_set_jpeg_config</a></li><li><a href="#hb_mm_mc_get_fd" class="table-of-contents__link toc-highlight">hb_mm_mc_get_fd</a></li><li><a href="#hb_mm_mc_close_fd" class="table-of-contents__link toc-highlight">hb_mm_mc_close_fd</a></li><li><a href="#hb_mm_mc_set_camera" class="table-of-contents__link toc-highlight">hb_mm_mc_set_camera</a></li><li><a href="#hb_mm_mc_get_vui_config" class="table-of-contents__link toc-highlight">hb_mm_mc_get_vui_config</a></li><li><a href="#hb_mm_mc_set_vui_config" class="table-of-contents__link toc-highlight">hb_mm_mc_set_vui_config</a></li><li><a href="#hb_mm_mc_get_3dnr_enc_config" class="table-of-contents__link toc-highlight">hb_mm_mc_get_3dnr_enc_config</a></li><li><a href="#hb_mm_mc_set_3dnr_enc_config" class="table-of-contents__link toc-highlight">hb_mm_mc_set_3dnr_enc_config</a></li><li><a href="#hb_mm_mc_request_idr_header" class="table-of-contents__link toc-highlight">hb_mm_mc_request_idr_header</a></li><li><a href="#hb_mm_mc_enable_idr_frame" class="table-of-contents__link toc-highlight">hb_mm_mc_enable_idr_frame</a></li><li><a href="#hb_mm_mc_register_audio_encoder" class="table-of-contents__link toc-highlight">hb_mm_mc_register_audio_encoder</a></li><li><a href="#hb_mm_mc_unregister_audio_encoder" class="table-of-contents__link toc-highlight">hb_mm_mc_unregister_audio_encoder</a></li><li><a href="#hb_mm_mc_register_audio_decoder" class="table-of-contents__link toc-highlight">hb_mm_mc_register_audio_decoder</a></li><li><a href="#hb_mm_mc_unregister_audio_decoder" class="table-of-contents__link toc-highlight">hb_mm_mc_unregister_audio_decoder</a></li><li><a href="#hb_mm_mc_get_explicit_header_config" class="table-of-contents__link toc-highlight">hb_mm_mc_get_explicit_header_config</a></li><li><a href="#hb_mm_mc_set_explicit_header_config" class="table-of-contents__link toc-highlight">hb_mm_mc_set_explicit_header_config</a></li><li><a href="#hb_mm_mc_get_roi_avg_qp" class="table-of-contents__link toc-highlight">hb_mm_mc_get_roi_avg_qp</a></li><li><a href="#hb_mm_mc_set_roi_avg_qp" class="table-of-contents__link toc-highlight">hb_mm_mc_set_roi_avg_qp</a></li></ul></li><li><a href="#主要参数说明" class="table-of-contents__link toc-highlight">主要参数说明</a><ul><li><a href="#media_codec_state_t" class="table-of-contents__link toc-highlight">media_codec_state_t</a></li><li><a href="#media_codec_id_t" class="table-of-contents__link toc-highlight">media_codec_id_t</a></li><li><a href="#mc_video_rate_control_mode_t" class="table-of-contents__link toc-highlight">mc_video_rate_control_mode_t</a></li><li><a href="#mc_h264_cbr_params_t" class="table-of-contents__link toc-highlight">mc_h264_cbr_params_t</a></li><li><a href="#mc_h264_vbr_params_t" class="table-of-contents__link toc-highlight">mc_h264_vbr_params_t</a></li><li><a href="#mc_h264_avbr_params_t" class="table-of-contents__link toc-highlight">mc_h264_avbr_params_t</a></li><li><a href="#mc_h264_fix_qp_params_t" class="table-of-contents__link toc-highlight">mc_h264_fix_qp_params_t</a></li><li><a href="#mc_h264_qp_map_params_t" class="table-of-contents__link toc-highlight">mc_h264_qp_map_params_t</a></li><li><a href="#mc_h265_cbr_params_t" class="table-of-contents__link toc-highlight">mc_h265_cbr_params_t</a></li><li><a href="#mc_h265_vbr_params_t" class="table-of-contents__link toc-highlight">mc_h265_vbr_params_t</a></li><li><a href="#mc_h265_avbr_params_t" class="table-of-contents__link toc-highlight">mc_h265_avbr_params_t</a></li><li><a href="#mc_h265_fix_qp_params_t" class="table-of-contents__link toc-highlight">mc_h265_fix_qp_params_t</a></li><li><a href="#mc_h265_qp_map_params_t" class="table-of-contents__link toc-highlight">mc_h265_qp_map_params_t</a></li><li><a href="#mc_mjpeg_fix_qp_params_t" class="table-of-contents__link toc-highlight">mc_mjpeg_fix_qp_params_t</a></li><li><a href="#mc_video_custom_gop_pic_params_t" class="table-of-contents__link toc-highlight">mc_video_custom_gop_pic_params_t</a></li><li><a href="#mc_inter_status_t" class="table-of-contents__link toc-highlight">mc_inter_status_t</a></li><li><a href="#media_codec_context_t" class="table-of-contents__link toc-highlight">media_codec_context_t</a></li><li><a href="#mc_video_codec_enc_params_t" class="table-of-contents__link toc-highlight">mc_video_codec_enc_params_t</a></li><li><a href="#mc_video_codec_dec_params_t" class="table-of-contents__link toc-highlight">mc_video_codec_dec_params_t</a></li><li><a href="#mc_audio_codec_enc_params_t" class="table-of-contents__link toc-highlight">mc_audio_codec_enc_params_t</a></li><li><a href="#mc_audio_codec_dec_params_t" class="table-of-contents__link toc-highlight">mc_audio_codec_dec_params_t</a></li></ul></li><li><a href="#返回值说明" class="table-of-contents__link toc-highlight">返回值说明</a></li></ul></li><li><a href="#codec-sample" class="table-of-contents__link toc-highlight">Codec sample</a><ul><li><a href="#编码示例" class="table-of-contents__link toc-highlight">编码示例</a><ul><li><a href="#功能概述" class="table-of-contents__link toc-highlight">功能概述</a><ul><li><a href="#软件架构说明" class="table-of-contents__link toc-highlight">软件架构说明</a></li><li><a href="#硬件数据流说明" class="table-of-contents__link toc-highlight">硬件数据流说明</a></li><li><a href="#代码位置及目录结构" class="table-of-contents__link toc-highlight">代码位置及目录结构</a></li></ul></li><li><a href="#编译" class="table-of-contents__link toc-highlight">编译</a><ul><li><a href="#编译环境" class="table-of-contents__link toc-highlight">编译环境</a></li><li><a href="#编译说明" class="table-of-contents__link toc-highlight">编译说明</a></li></ul></li><li><a href="#运行" class="table-of-contents__link toc-highlight">运行</a><ul><li><a href="#支持平台" class="table-of-contents__link toc-highlight">支持平台</a></li><li><a href="#板端部署及配置" class="table-of-contents__link toc-highlight">板端部署及配置</a></li><li><a href="#运行指南" class="table-of-contents__link toc-highlight">运行指南</a></li></ul></li></ul></li><li><a href="#解码示例" class="table-of-contents__link toc-highlight">解码示例</a><ul><li><a href="#功能概述-1" class="table-of-contents__link toc-highlight">功能概述</a><ul><li><a href="#软件架构" class="table-of-contents__link toc-highlight">软件架构</a></li><li><a href="#硬件数据流说明-1" class="table-of-contents__link toc-highlight">硬件数据流说明</a></li><li><a href="#代码位置及目录结构-1" class="table-of-contents__link toc-highlight">代码位置及目录结构</a></li></ul></li><li><a href="#编译-1" class="table-of-contents__link toc-highlight">编译</a><ul><li><a href="#编译环境-1" class="table-of-contents__link toc-highlight">编译环境</a></li><li><a href="#编译说明-1" class="table-of-contents__link toc-highlight">编译说明</a></li></ul></li><li><a href="#运行-1" class="table-of-contents__link toc-highlight">运行</a><ul><li><a href="#支持平台-1" class="table-of-contents__link toc-highlight">支持平台</a></li><li><a href="#板端部署及配置-1" class="table-of-contents__link toc-highlight">板端部署及配置</a></li><li><a href="#运行指南-1" class="table-of-contents__link toc-highlight">运行指南</a></li></ul></li></ul></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">友情链接</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://www.guyuehome.com/" target="_blank" rel="noopener noreferrer" class="footer__link-item">古月居<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">联系我们</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/D-Robotics" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://space.bilibili.com/437998606" target="_blank" rel="noopener noreferrer" class="footer__link-item">BiLiBiLi<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 D-Robotics.</div></div></div></footer></div>
</body>
</html>