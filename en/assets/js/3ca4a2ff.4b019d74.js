"use strict";(self.webpackChunkrdk_doc=self.webpackChunkrdk_doc||[]).push([[32023],{28453:(e,n,o)=>{o.d(n,{R:()=>i,x:()=>c});var r=o(96540);const t={},d=r.createContext(t);function i(e){const n=r.useContext(d);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),r.createElement(d.Provider,{value:n},e.children)}},33205:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>s,contentTitle:()=>c,default:()=>a,frontMatter:()=>i,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"Advanced_development/linux_development/driver_development/driver_pwm_dev","title":"PWM Drive Debugging Guide","description":"X3 has two types of controllers: one is standard PWM, with 3 groups of 3 each, totaling 9; the other is LPWM, mainly used to support synchronous exposure of sensors.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/07_Advanced_development/02_linux_development/driver_development/driver_pwm_dev.md","sourceDirName":"07_Advanced_development/02_linux_development/driver_development","slug":"/Advanced_development/linux_development/driver_development/driver_pwm_dev","permalink":"/rdk_doc/en/Advanced_development/linux_development/driver_development/driver_pwm_dev","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1757296769000,"sidebarPosition":8,"frontMatter":{"sidebar_position":8},"sidebar":"tutorialSidebar","previous":{"title":"SPI Debugging Guide","permalink":"/rdk_doc/en/Advanced_development/linux_development/driver_development/driver_spi_dev"},"next":{"title":"BPU Driver sysfs debugging interface","permalink":"/rdk_doc/en/Advanced_development/linux_development/driver_development/driver_bpu_sysfs_dev"}}');var t=o(74848),d=o(28453);const i={sidebar_position:8},c="PWM Drive Debugging Guide",s={},l=[{value:"Drive Code",id:"drive-code",level:2},{value:"Code Path",id:"code-path",level:3},{value:"Kernel Configuration",id:"kernel-configuration",level:3},{value:"DTS Node Configuration",id:"dts-node-configuration",level:3},{value:"Test",id:"test",level:2}];function p(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,d.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"pwm-drive-debugging-guide",children:"PWM Drive Debugging Guide"})}),"\n",(0,t.jsx)(n.p,{children:"X3 has two types of controllers: one is standard PWM, with 3 groups of 3 each, totaling 9; the other is LPWM, mainly used to support synchronous exposure of sensors."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"PWM default supports a frequency range of 192MHz to 46.8KHz, with RATIO register precision of 8 bits for each group of PWM."}),"\n",(0,t.jsx)(n.li,{children:"LPWM default supports a frequency range of 100KHz to 24.4Hz, without a duty cycle register, only a high-level duration HIGH. The HIGH register is configured in units of microseconds (us) and supports a maximum high-level duration of 160us, so the duty cycle of LPWM is related to the frequency."}),"\n",(0,t.jsxs)(n.li,{children:["LPWM is designed for sensor synchronization and is not a general-purpose PWM. ",(0,t.jsx)(n.strong,{children:"It is recommended to use PWM for pure PWM functionality."})]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"drive-code",children:"Drive Code"}),"\n",(0,t.jsx)(n.h3,{id:"code-path",children:"Code Path"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"drivers/pwm/pwm-hobot.c\n"})}),"\n",(0,t.jsx)(n.h3,{id:"kernel-configuration",children:"Kernel Configuration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"Device Drivers\n    -> Pulse-Width Modulation (PWM) Support\n        -> Hobot PWM controller support\n        -> Hobot lite PWM controller support\n"})}),"\n",(0,t.jsx)(n.h3,{id:"dts-node-configuration",children:"DTS Node Configuration"}),"\n",(0,t.jsxs)(n.p,{children:["In the ",(0,t.jsx)(n.code,{children:"hobot-xj3.dtsi"})," file, there are configurations for ",(0,t.jsx)(n.code,{children:"pwm"})," and ",(0,t.jsx)(n.code,{children:"lpwm"}),", which generally do not require any modifications."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'/* arch/arm64/boot/dts/hobot/hobot-xj3.dtsi */\nlpwm: lpwm@0xA500D000 {\n    compatible = "hobot,hobot-lpwm";\n    reg = <0 0xA5018000 0 0x1000>;\n    interrupt-parent = <&gic>;\n    interrupts = <0 68 4>;\n    pinctrl-names = "lpwm0", "lpwm1","lpwm2","lpwm3", "lpwm_pps";\n    pinctrl-0 = <&lpwm0_func>;\n    pinctrl-1 = <&lpwm1_func>;\n    pinctrl-2 = <&lpwm2_func>;\n    pinctrl-3 = <&lpwm3_func>;\n    pinctrl-4 = <&lpwm_pps>;\n    clocks = <&lpwm_mclk>;\n    clock-names = "lpwm_mclk";\n    status = "disabled";\n};\n    pwm_c0: pwm@0xA500D000 {\n    compatible = "hobot,hobot-pwm";\n    #pwm-cells = <3>;\n    reg = <0 0xA500D000 0 0x1000>;\n    interrupt-parent = <&gic>;\n    interrupts = <0 44 4>;\n    pinctrl-names = "pwm0", "pwm1","pwm2";\n    pinctrl-0 = <&pwm0_func>;\n    pinctrl-1 = <&pwm1_func>;\n    pinctrl-2 = <&pwm2_func>;\n    clocks = <&pwm0_mclk>;\n    clock-names = "pwm_mclk";\n    status = "disabled";\n};\n...\n'})}),"\n",(0,t.jsxs)(n.p,{children:["When you need to enable the corresponding serial port, you can modify the corresponding board-level file. Here, take ",(0,t.jsx)(n.code,{children:"hobot-x3-sdb_v4.dts"})," as an example to enable ",(0,t.jsx)(n.code,{children:"pwm0-2"})," and ",(0,t.jsx)(n.code,{children:"pwm3-5"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'/* arch/arm64/boot/dts/hobot/hobot-x3-sdb_v4.dts */\n...\n&pwm_c0 {\n    status = "okay";\n    pinctrl-0 = <&pwm0_func>;\n    pinctrl-1 = <>;\n    pinctrl-2 = <>;\n};\n&pwm_c1 {\n    status = "okay";\n    pinctrl-0 = <>;\n    pinctrl-1 = <&pwm4_func>;\n    pinctrl-2 = <>;\n};\n...\n'})}),"\n",(0,t.jsx)(n.h2,{id:"test",children:"Test"}),"\n",(0,t.jsxs)(n.p,{children:["Users can use the following script to test the ",(0,t.jsx)(n.code,{children:"pwm"})," function and measure the signal to verify if the ",(0,t.jsx)(n.code,{children:"pwm"})," is working properly."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:'echo 8 8 8 8  > /proc/sys/kernel/printk\nfor i in 0 3\ndo\n    cd /sys/class/pwm/pwmchip${i}\n    echo 0 > export\n    echo 1 > export\n    echo 2 > export\n    cd pwm0\n        echo 10000 > period\n        echo 3000  > duty_cycle\n        echo 1 > enable\n  \n        cd ../pwm1\n        echo 10000 > period\n        echo 1000  > duty_cycle\n        echo 1 > enable\n \n        cd ../pwm2\n        echo 10000 > period\n        echo 1000  > duty_cycle\n        echo 1 > enable\ndone\n# The following is for register reading\necho "pwm0 pinctrl:`devmem 0xa6004010 32`"\necho "pwm1 pinctrl:`devmem 0xa6004058 32`"\necho "pwm2 pinctrl:`devmem 0xa600405C 32`"\necho "pwm3 pinctrl:`devmem 0xa6004060 32`"\necho "pwm4 pinctrl:`devmem 0xa6004064 32`"\necho "pwm5 pinctrl:`devmem 0xa6004048 32`"\necho "pwm6 pinctrl:`devmem 0xa600404C 32`"\necho "pwm7 pinctrl:`devmem 0xa6004030 32`"\necho "pwm8 pinctrl:`devmem 0xa6004034 32`"\n \necho "Regs of PWM 0 1 2:"\necho "PWM_EN      `devmem 0xA500d000 32`"\necho "PWM_SLICE   `devmem 0xA500d004 32`"\necho "PWM_FREQ    `devmem 0xA500d008 32`"\necho "PWM_FREQ1   `devmem 0xA500d00C 32`"\necho "PWM_RATIO   `devmem 0xA500d014 32`"\necho "PWM_SRCPND  `devmem 0xA500d01C 32`"\necho "PWM_INTMASK `devmem 0xA500d020 32`"\n \necho "Regs of PWM 3 4 5:"\necho "PWM_EN      `devmem 0xA500e000 32`"\necho "PWM_SLICE   `devmem 0xA500e004 32`"\necho "PWM_FREQ    `devmem 0xA500e008 32`"\necho "PWM_FREQ1   `devmem 0xA500e00C 32`"\necho "PWM_RATIO   `devmem 0xA500e014 32`"\necho "PWM_SRCPND  `devmem 0xA500e01C 32`"\necho "PWM_INTMASK `devmem 0xA500e020 32`"\n'})})]})}function a(e={}){const{wrapper:n}={...(0,d.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}}}]);