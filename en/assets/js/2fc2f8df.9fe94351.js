"use strict";(self.webpackChunkrdk_doc=self.webpackChunkrdk_doc||[]).push([[78828],{28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>l});var t=i(96540);const s={},r=t.createContext(s);function a(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(r.Provider,{value:n},e.children)}},75725:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>a,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"Advanced_development/mcu_development/S100/mcu_spi","title":"SPI Usage Guide","description":"Hardware Support","source":"@site/i18n/en/docusaurus-plugin-content-docs-docs_s/current/07_Advanced_development/05_mcu_development/01_S100/06_mcu_spi.md","sourceDirName":"07_Advanced_development/05_mcu_development/01_S100","slug":"/Advanced_development/mcu_development/S100/mcu_spi","permalink":"/rdk_doc/en/rdk_s/Advanced_development/mcu_development/S100/mcu_spi","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1768581666000,"sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"PWM Usage Guide","permalink":"/rdk_doc/en/rdk_s/Advanced_development/mcu_development/S100/mcu_pwm"},"next":{"title":"ADC Usage Guide","permalink":"/rdk_doc/en/rdk_s/Advanced_development/mcu_development/S100/mcu_adc"}}');var s=i(74848),r=i(28453);const a={sidebar_position:6},l="SPI Usage Guide",c={},o=[{value:"Hardware Support",id:"hardware-support",level:2},{value:"Code Paths",id:"code-paths",level:2},{value:"Application Sample",id:"application-sample",level:2},{value:"Configuration Example",id:"configuration-example",level:3},{value:"Single Chip Select Usage Example",id:"single-chip-select-usage-example",level:3},{value:"Dual Chip Select Usage Example",id:"dual-chip-select-usage-example",level:3},{value:"Application Programming Interface",id:"application-programming-interface",level:3},{value:"void Spi_Init(const Spi_ConfigType* ConfigPtr)",id:"void-spi_initconst-spi_configtype-configptr",level:4},{value:"Std_ReturnType Spi_WriteIB(Spi_ChannelType Channel, const Spi_DataBufferType* DataBufferPtr)",id:"std_returntype-spi_writeibspi_channeltype-channel-const-spi_databuffertype-databufferptr",level:4},{value:"Std_ReturnType Spi_AsyncTransmit(Spi_SequenceType Sequence)",id:"std_returntype-spi_asynctransmitspi_sequencetype-sequence",level:4},{value:"Std_ReturnType Spi_ReadIB(Spi_ChannelType Channel, Spi_DataBufferType* DataBufferPtr)",id:"std_returntype-spi_readibspi_channeltype-channel-spi_databuffertype-databufferptr",level:4},{value:"Std_ReturnType Spi_SetupEB(Spi_ChannelType Channel, const Spi_DataBufferType* SrcDataBufferPtr, Spi_DataBufferType* DesDataBufferPtr, Spi_NumberOfDataType Length)",id:"std_returntype-spi_setupebspi_channeltype-channel-const-spi_databuffertype-srcdatabufferptr-spi_databuffertype-desdatabufferptr-spi_numberofdatatype-length",level:4},{value:"Spi_StatusType Spi_GetStatus(const Spi_ConfigType* ConfigPtr)",id:"spi_statustype-spi_getstatusconst-spi_configtype-configptr",level:4},{value:"Spi_JobResultType Spi_GetJobResult(Spi_JobType Job)",id:"spi_jobresulttype-spi_getjobresultspi_jobtype-job",level:4},{value:"Spi_SeqResultType Spi_GetSequenceResult(Spi_SequenceType Sequence)",id:"spi_seqresulttype-spi_getsequenceresultspi_sequencetype-sequence",level:4},{value:"void Spi_GetVersionInfo(Std_VersionInfoType* versioninfo)",id:"void-spi_getversioninfostd_versioninfotype-versioninfo",level:4},{value:"Std_ReturnType Spi_SyncTransmit(Spi_SequenceType Sequence)",id:"std_returntype-spi_synctransmitspi_sequencetype-sequence",level:4},{value:"Spi_StatusType Spi_GetHWUnitStatus(Spi_HWUnitType HWUnit)",id:"spi_statustype-spi_gethwunitstatusspi_hwunittype-hwunit",level:4},{value:"void Spi_Cancel(Spi_SequenceType Sequence)",id:"void-spi_cancelspi_sequencetype-sequence",level:4},{value:"Std_ReturnType Spi_SetAsyncMode(Spi_AsyncModeType Mode)",id:"std_returntype-spi_setasyncmodespi_asyncmodetype-mode",level:4},{value:"void Spi_MainFunction_Handling(void)",id:"void-spi_mainfunction_handlingvoid",level:4}];function d(e){const n={admonition:"admonition",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"spi-usage-guide",children:"SPI Usage Guide"})}),"\n",(0,s.jsx)(n.h2,{id:"hardware-support",children:"Hardware Support"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If SPI uses DMA transmission, the following constraints must be met:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The transfer length must be 8-byte aligned; otherwise, data boundary overflow issues may occur;"}),"\n",(0,s.jsx)(n.li,{children:"The buffer addresses for transmit and receive data must be 64-byte aligned;"}),"\n",(0,s.jsx)(n.li,{children:"The data amount per single DMA channel transfer must not exceed 4096 bytes;"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"SPI Slave mode is supported;"}),"\n",(0,s.jsx)(n.li,{children:"When the MCU-side SPI operates as a Slave with a speed greater than 9 MHz, only DMA mode is allowed;"}),"\n",(0,s.jsxs)(n.li,{children:["When the MCU-side SPI operates in 8-bit mode, the following limitations apply:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Maximum speed for 1 parallel SPI Tx/Rx: 50 MHz;"}),"\n",(0,s.jsx)(n.li,{children:"Maximum speed for 2 parallel SPI Tx/Rx: 33.3 MHz;"}),"\n",(0,s.jsx)(n.li,{children:"Maximum speed for 3 parallel SPI Tx/Rx: 25 MHz;"}),"\n",(0,s.jsx)(n.li,{children:"Maximum speed for 4 parallel SPI Tx/Rx: 20 MHz;"}),"\n",(0,s.jsx)(n.li,{children:"Maximum speed for 5 parallel SPI Tx/Rx: 15.6 MHz;"}),"\n",(0,s.jsx)(n.li,{children:"Maximum speed for 6 parallel SPI Tx/Rx: 12.5 MHz;"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"The SPI peripheral supports only MSB (Most Significant Bit first);"}),"\n",(0,s.jsxs)(n.li,{children:["SPI ",(0,s.jsx)(n.code,{children:"SpiCsPolarity"})," and ",(0,s.jsx)(n.code,{children:"spitimeclk2c"})," are not configurable; ",(0,s.jsx)(n.code,{children:"SpiCsPolarity"})," defaults to active-low;"]}),"\n",(0,s.jsxs)(n.li,{children:["When ",(0,s.jsx)(n.code,{children:"SpiCsToggleEnable"})," is enabled, the CS pin will be pulled high after one SPI frame transmission completes. Only TRAILING mode is supported; LEADING mode is not supported;"]}),"\n",(0,s.jsx)(n.li,{children:"SPI DMA mode consumes less CPU load compared to non-DMA mode;"}),"\n",(0,s.jsx)(n.li,{children:"When SPI transmits data in non-DMA mode and the system load is high, delayed SPI interrupt response may cause the SPI FIFO to not be written in time, resulting in a brief high pulse on the CS pin. In such cases, DMA mode is recommended;"}),"\n",(0,s.jsxs)(n.li,{children:["If multiple Sequences use the same SPI IP for asynchronous transmission without strict ordering requirements, Sequence transmission queuing may occur. In this scenario, interrupt-disabling critical section protection must be implemented in the ",(0,s.jsx)(n.code,{children:"SchM_Spi.c"})," file."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"code-paths",children:"Code Paths"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"McalCdd/Spi/inc/Spi.h \u2013 Header file for the SPI driver"}),"\n",(0,s.jsx)(n.li,{children:"McalCdd/Spi/inc/Spi_Lld.h \u2013 Header file for the SPI low-level driver"}),"\n",(0,s.jsx)(n.li,{children:"McalCdd/Spi/src/Spi.c \u2013 Source file for the SPI driver"}),"\n",(0,s.jsx)(n.li,{children:"McalCdd/Spi/src/Spi_Lld.c \u2013 Source file for the SPI low-level driver"}),"\n",(0,s.jsx)(n.li,{children:"McalCdd/Common/Register/inc/Spi_Register.h \u2013 SPI register definition file"}),"\n",(0,s.jsx)(n.li,{children:"Platform/Schm/SchM_Spi.h \u2013 SPI module scheduling management header file"}),"\n",(0,s.jsx)(n.li,{children:"Config/McalCdd/gen_s100_sip_B_mcu1/Spi/inc/Spi_Cfg.h \u2013 SPI configuration header file"}),"\n",(0,s.jsx)(n.li,{children:"Config/McalCdd/gen_s100_sip_B_mcu1/Spi/inc/Spi_PBcfg.h \u2013 SPI PB configuration header file"}),"\n",(0,s.jsx)(n.li,{children:"Config/McalCdd/gen_s100_sip_B_mcu1/Spi/src/Spi_PBcfg.c \u2013 SPI PB configuration source file"}),"\n",(0,s.jsx)(n.li,{children:"samples/Spi/SPI_sample/Spi_sample.c \u2013 SPI sample code"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"application-sample",children:"Application Sample"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The sample uses DMA but does not explicitly initialize it because initialization is already performed in the file ",(0,s.jsx)(n.code,{children:"Target/Target-hobot-lite-freertos-mcu1/target/HorizonTask.c"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The S100 chip has six SPI hardware instances: SPI2 through SPI7. The mapping between SPI channels, external devices, and physical unit abstraction is as follows:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:(0,s.jsx)(n.strong,{children:"SPI Channel"})}),(0,s.jsx)(n.th,{children:(0,s.jsx)(n.strong,{children:"External device"})}),(0,s.jsx)(n.th,{children:(0,s.jsx)(n.strong,{children:"Spi Physical Unit"})})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"SPI2"}),(0,s.jsx)(n.td,{children:"SPI_SpiExternalDevice_0"}),(0,s.jsx)(n.td,{children:"Spi_PhyConfig_SpiPhyUnit_0"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"SPI3"}),(0,s.jsx)(n.td,{children:"SPI_SpiExternalDevice_1"}),(0,s.jsx)(n.td,{children:"Spi_PhyConfig_SpiPhyUnit_1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"SPI4"}),(0,s.jsx)(n.td,{children:"SPI_SpiExternalDevice_2"}),(0,s.jsx)(n.td,{children:"Spi_PhyConfig_SpiPhyUnit_2"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"SPI5"}),(0,s.jsx)(n.td,{children:"SPI_SpiExternalDevice_3"}),(0,s.jsx)(n.td,{children:"Spi_PhyConfig_SpiPhyUnit_3"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"SPI6"}),(0,s.jsx)(n.td,{children:"SPI_SpiExternalDevice_4"}),(0,s.jsx)(n.td,{children:"Spi_PhyConfig_SpiPhyUnit_4"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"SPI7"}),(0,s.jsx)(n.td,{children:"SPI_SpiExternalDevice_5"}),(0,s.jsx)(n.td,{children:"Spi_PhyConfig_SpiPhyUnit_5"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"configuration-example",children:"Configuration Example"}),"\n",(0,s.jsx)(n.p,{children:"Taking SPI4 as an example, the configuration is as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"//Config/McalCdd/gen_s100_sip_B_mcu1/Spi/src/Spi_PBcfg.c\nstatic const Spi_PhyCfgType Spi_PhyConfig_SpiPhyUnit_2 =\n{\n    (uint8)2U, /* Instance */\n    SPI_SPURIOUS_CORE_ID, /* SpiCoreUse */\n    /* Spi Slave mode*/\n    (boolean)FALSE,  // FALSE for master mode, TRUE for slave mode\n    /* Spi Test Mode Operation Enable*/\n    (boolean)FALSE, // Loopback mode (no external wiring)\n    /* Spi Sample Point*/\n    (uint32)0U,\n#if (SPI_DMA_ENABLE == STD_ON)\n    (boolean)FALSE, // DMA configuration\n#endif\n    SPI_IP_POLLING, /* Transfer mode: interrupt or polling mode selectable */\n    (uint8)2U, /* State structure element from the array */\n    //SPI_PHYUNIT_SYNC /* IsSync */\n    SPI_PHYUNIT_ASYNC // Synchronous or asynchronous mode\n};\n\nstatic const Spi_ChannelCfg SpiChannel_2 =\n{\n    /* SpiChannel_2*/\n    EB, /* BufferType IB or EB */ // Use external or internal memory\n    8U, /* Frame size */\n    (uint32)1U, /* In the case SpiDefaultData is disabled. Set this value to 1U */\n    Spi_TxDefaultBufferSpiChannel_2,\n    Spi_RxDefaultBufferSpiChannel_2,\n    256U, /* Length (configured in SpiEbMaxLength) */\n    &Spi_BufferSpiChannel_2,\n    SPI_SPURIOUS_CORE_ID,\n    &Spi_ChannelState[2U] /* Spi_ChannelState pointer */\n};\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"single-chip-select-usage-example",children:"Single Chip Select Usage Example"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"spi_test"})," command is used to test SPI (Serial Peripheral Interface) functionality. It supports initialization and parameter setup, parameter retrieval, and SPI testing."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"spitest"})," command supports three operation modes, specified by the first argument:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"0: Initialization and parameter setup"}),"\n",(0,s.jsx)(n.li,{children:"1: Retrieve parameters"}),"\n",(0,s.jsx)(n.li,{children:"2: Execute SPI test"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Parameter explanation:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Operation mode (",(0,s.jsx)(n.code,{children:"argv[1]"}),"): Specifies the operation to perform; valid values are 0, 1, or 2."]}),"\n",(0,s.jsxs)(n.li,{children:["Device ID (",(0,s.jsx)(n.code,{children:"argv[2]"}),"): Specifies the SPI device ID, which determines which SPI instance is used. Refer to the SPI mapping table in the first section of this document."]}),"\n",(0,s.jsxs)(n.li,{children:["Channel number (",(0,s.jsx)(n.code,{children:"argv[3]"}),"): Specifies the SPI channel number, corresponding to the ",(0,s.jsx)(n.code,{children:"Spi_ChannelCfg"})," configuration above. This typically needs to be changed only when switching between internal and external memory buffers."]}),"\n",(0,s.jsxs)(n.li,{children:["Synchronization mode (",(0,s.jsx)(n.code,{children:"argv[4]"}),"): Used only when operation mode is 0, specifies the SPI communication synchronization mode.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"0: Asynchronous mode"}),"\n",(0,s.jsx)(n.li,{children:"1: Synchronous mode"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Transfer mode (",(0,s.jsx)(n.code,{children:"argv[5]"}),"): Used only when operation mode is 0, specifies the SPI data transfer mode.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"0: Polling mode"}),"\n",(0,s.jsx)(n.li,{children:"1: Interrupt mode"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsx)(n.p,{children:"Application-layer configuration must be consistent with low-level configuration; otherwise, errors will occur."})}),"\n",(0,s.jsx)(n.p,{children:"Short the MISO and MOSI pins of SPI4 and run the following command:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"D-Robotics:/$ spi_test 2\n[0433.628723 0]set interrupt\n[0433.628914 0]interrupt,2\n[0433.639657 0]interrupt,2\n[0433.649684 0]\nRxChBuf0 (256 bytes):\n0CC20DC0: 31 32 33 34 35 36 37 38 39 3A 3B 3C 3D 3E 3F 00  | 123456789:;<=>?.\n0CC20DD0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  | ................\n0CC20DE0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  | ................\n0CC20DF0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  | ................\n0CC20E00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  | ................\n0CC20E10: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  | ................\n0CC20E20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  | ................\n0CC20E30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  | ................\n0CC20E40: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  | ................\n0CC20E50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  | ................\n0CC20E60: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  | ................\n0CC20E70: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  | ................\n0CC20E80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  | ................\n0CC20E90: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  | ................\n0CC20EA0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  | ................\n0CC20EB0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  | ................\n[0433.679963 0]\nTxChBuf0 (256 bytes):\n0CBC3040: 31 32 33 34 35 36 37 38 39 3A 3B 3C 3D 3E 3F 00  | 123456789:;<=>?.\n0CBC3050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  | ................\n0CBC3060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  | ................\n0CBC3070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  | ................\n0CBC3080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  | ................\n0CBC3090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  | ................\n0CBC30A0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  | ................\n0CBC30B0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  | ................\n0CBC30C0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  | ................\n0CBC30D0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  | ................\n0CBC30E0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  | ................\n0CBC30F0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  | ................\n0CBC3100: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  | ................\n0CBC3110: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  | ................\n0CBC3120: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  | ................\n0CBC3130: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  | ................\n[0433.700110 0]=====SPI ASYNC TEST SUCCESS=====\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"dual-chip-select-usage-example",children:"Dual Chip Select Usage Example"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"SpiTest_Mul_cs"})," command is used to test SPI (Serial Peripheral Interface) functionality."]}),"\n",(0,s.jsx)(n.p,{children:"Usage and parameter explanation are as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"########################## support test case: ##########################\nusag: SpiTest_Mul_cs Case_num Sequences Cs DataWidth DataLen Loop_times\n[1]: SpiTest_Mul_cs 1 1 0 8 1 1 -- get versioninfo\n[2]: SpiTest_Mul_cs 2 5 0 8 10 1 -- InterruptMode Sync Transfer\n[3]: SpiTest_Mul_cs 3 5 0 8 10 1 -- PollingMode Sync Transfer\n[4]: SpiTest_Mul_cs 4 5 0 8 10 1 -- InterruptMode Async Transfer\n[5]: SpiTest_Mul_cs 5 5 0 8 10 1 -- PollingMode Async Transfer\nother: SpiTest 110  -- help\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Parameter explanation:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Case_num"})," (",(0,s.jsx)(n.code,{children:"argv[1]"}),"): Specifies the test case to run; 5 modes are supported. For example, to use interrupt-driven asynchronous transfer, set ",(0,s.jsx)(n.code,{children:"Case_num"})," to 4."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Sequences"})," (",(0,s.jsx)(n.code,{children:"argv[2]"}),"): Specifies which SPI instance to use. For SPI4, set ",(0,s.jsx)(n.code,{children:"Sequences"})," to 4."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Cs"})," (",(0,s.jsx)(n.code,{children:"argv[3]"}),"): Specifies which chip select (CS) line to use. For CS0, set ",(0,s.jsx)(n.code,{children:"Cs"})," to 0."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"DataWidth"})," (",(0,s.jsx)(n.code,{children:"argv[4]"}),"): Specifies the data width in bits. For 8-bit width, set ",(0,s.jsx)(n.code,{children:"DataWidth"})," to 8."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"DataLen"})," (",(0,s.jsx)(n.code,{children:"argv[5]"}),"): Specifies the number of data frames to transfer. For 10 frames, set ",(0,s.jsx)(n.code,{children:"DataLen"})," to 10."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Loop_times"})," (",(0,s.jsx)(n.code,{children:"argv[6]"}),"): Specifies how many times to repeat the test. For 5 iterations, set ",(0,s.jsx)(n.code,{children:"Loop_times"})," to 5."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["SPI4, asynchronous interrupt-driven transfer, CS1, 8-bit data width, 10 data frames, 1 test iteration:",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.code,{children:"SpiTest_Mul_cs 4 4 1 8 10 1"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Short the MISO and MOSI pins of SPI4 and run the following command:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Robotics:/$ SpiTest_Mul_cs 4 4 1 8 10 1\n[get_spi_status 98] [INFO]: SPI status: SPI_IDLE\n[SpiTest_Mul_cs 450] [INFO]: ####################### test_case_num: 4 #######################\n############################# Loop Times: 1 #############################\n[Spi_Trans_Test 231] [INFO]: data_tx: 0xcbccc40, data_rx: 0xcbcca40  \n[Spi_Trans_Test 238] [INFO]: len = 10, check_data_len = 10  \n[get_spi_sequence_result 122] [INFO]: SPI result: SPI_SEQ_PENDING  \nTX | 00 01 02 03 04 05 06 07 08 09 __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __   \nRX | 00 01 02 03 04 05 06 07 08 09 __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __   \n[check_data 81] [INFO]: check data success.  \n[Spi_Interrupt_Async_Transfer_Test 353] [INFO]: Transfer success.  \n[SpiTest_Mul_cs 474] [INFO]: Test case pass.  \n[SpiTest_Mul_cs 479] [INFO]: #####################################################################\n"})}),"\n",(0,s.jsx)(n.h3,{id:"application-programming-interface",children:"Application Programming Interface"}),"\n",(0,s.jsx)(n.h4,{id:"void-spi_initconst-spi_configtype-configptr",children:"void Spi_Init(const Spi_ConfigType* ConfigPtr)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: Service for SPI initialization.\n\nParameters (in)\n    ConfigPtr: Pointer to configuration set\nParameters (inout)\n    None\nParameters (out)\n    None\nReturn value: None\n"})}),"\n",(0,s.jsx)(n.h4,{id:"std_returntype-spi_writeibspi_channeltype-channel-const-spi_databuffertype-databufferptr",children:"Std_ReturnType Spi_WriteIB(Spi_ChannelType Channel, const Spi_DataBufferType* DataBufferPtr)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: Service for SPI de-initialization.\n\nParameters (in)\n    Channel: Channel ID.\n    DataBufferPtr: Source data buffer pointer\nParameters (inout)\n    None\nParameters (out)\n    None\nReturn value: Std_ReturnType\n    E_OK: Spi write IB buffer success.\n    E_NOT_OK: Spi write IB buffer failed.\n"})}),"\n",(0,s.jsx)(n.h4,{id:"std_returntype-spi_asynctransmitspi_sequencetype-sequence",children:"Std_ReturnType Spi_AsyncTransmit(Spi_SequenceType Sequence)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: Service to transmit data on the SPI bus.\n\nSync/Async: Asynchronous\nParameters (in)\n    Sequence: Sequence ID.\nParameters (inout)\n    None\nParameters (out)\n    None\nReturn value: Std_ReturnType\n    E_OK: set success\n    E_NOT_OK: set failed\n"})}),"\n",(0,s.jsx)(n.h4,{id:"std_returntype-spi_readibspi_channeltype-channel-spi_databuffertype-databufferptr",children:"Std_ReturnType Spi_ReadIB(Spi_ChannelType Channel, Spi_DataBufferType* DataBufferPtr)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: Service for reading synchronously one or more data from an IB SPI\n             Handler/Driver Channel specified by parameter.\n\nSync/Async: Synchronous\nParameters (in)\n    Channel: Channel ID.\nParameters (inout)\n    None\nParameters (out)\n    DataBufferPtr: Pointer to destination data buffer in RAM\nReturn value: Std_ReturnType\n    E_OK: set success\n    E_NOT_OK: set failed\n"})}),"\n",(0,s.jsx)(n.h4,{id:"std_returntype-spi_setupebspi_channeltype-channel-const-spi_databuffertype-srcdatabufferptr-spi_databuffertype-desdatabufferptr-spi_numberofdatatype-length",children:"Std_ReturnType Spi_SetupEB(Spi_ChannelType Channel, const Spi_DataBufferType* SrcDataBufferPtr, Spi_DataBufferType* DesDataBufferPtr, Spi_NumberOfDataType Length)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: Service to setup the buffers and the length of data for the EB SPI\n             Handler/Driver Channel specified.\n\nSync/Async: Synchronous\nParameters (in)\n    Channel: Channel ID.\n    SrcDataBufferPtr: Pointer to the memory location that will hold the transmitted data\n    Length: Length (number of data elements) of the data to be transmitted\nParameters (inout)\n    None\nParameters (out)\n    DesDataBufferPtr: Pointer to the memory location that will hold the received data\nReturn value: Std_ReturnType\n    E_OK: Spi Setup EB buffer success.\n    E_NOT_OK: Spi Setup EB buffer failed.\n"})}),"\n",(0,s.jsx)(n.h4,{id:"spi_statustype-spi_getstatusconst-spi_configtype-configptr",children:"Spi_StatusType Spi_GetStatus(const Spi_ConfigType* ConfigPtr)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: Service returns the SPI Handler/Driver software module status.\n\nSync/Async: Synchronous\nParameters (in)\n    None\nParameters (inout)\n    None\nParameters (out)\n    None\nReturn value: Spi_StatusType\n    Spi_StatusType\n"})}),"\n",(0,s.jsx)(n.h4,{id:"spi_jobresulttype-spi_getjobresultspi_jobtype-job",children:"Spi_JobResultType Spi_GetJobResult(Spi_JobType Job)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: This service returns the last transmission result of the specified Job.\n\nSync/Async: Synchronous\nParameters (in)\n    Job: Job ID. An invalid job ID will return an undefined result.\nParameters (inout)\n    None\nParameters (out)\n    None\nReturn value: Spi_JobResultType\n    Spi_JobResultType\n"})}),"\n",(0,s.jsx)(n.h4,{id:"spi_seqresulttype-spi_getsequenceresultspi_sequencetype-sequence",children:"Spi_SeqResultType Spi_GetSequenceResult(Spi_SequenceType Sequence)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: This service returns the last transmission result of the specified Sequence.\n\nSync/Async: Synchronous\nParameters (in)\n    Sequence: Sequence ID. An invalid sequence ID will return an undefined result.\nParameters (inout)\n    None\nParameters (out)\n    None\nReturn value: Spi_JobResultType\n    Spi_JobResultType\n"})}),"\n",(0,s.jsx)(n.h4,{id:"void-spi_getversioninfostd_versioninfotype-versioninfo",children:"void Spi_GetVersionInfo(Std_VersionInfoType* versioninfo)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: This service returns the version information of this module.\n\nSync/Async: Synchronous\nParameters (in)\n    None\nParameters (inout)\n    None\nParameters (out)\n    versioninfo: Pointer to where to store the version information of this module.\nReturn value: None\n"})}),"\n",(0,s.jsx)(n.h4,{id:"std_returntype-spi_synctransmitspi_sequencetype-sequence",children:"Std_ReturnType Spi_SyncTransmit(Spi_SequenceType Sequence)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: Service to transmit data on the SPI bus.\n\nSync/Async: Synchronous\nParameters (in)\n    Sequence: Sequence ID.\nParameters (inout)\n    None\nParameters (out)\n    None\nReturn value: Std_ReturnType\n    E_OK: Transmission command has been accepted\n    E_NOT_OK: Transmission command has not been accepted\n"})}),"\n",(0,s.jsx)(n.h4,{id:"spi_statustype-spi_gethwunitstatusspi_hwunittype-hwunit",children:"Spi_StatusType Spi_GetHWUnitStatus(Spi_HWUnitType HWUnit)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: This service returns the status of the specified SPI Hardware\n             microcontroller peripheral.\n\nSync/Async: Synchronous\nParameters (in)\n    HWUnit: SPI Hardware microcontroller peripheral (unit) ID.\nParameters (inout)\n    None\nParameters (out)\n    None\nReturn value: Spi_StatusType\n    Spi_StatusType\n"})}),"\n",(0,s.jsx)(n.h4,{id:"void-spi_cancelspi_sequencetype-sequence",children:"void Spi_Cancel(Spi_SequenceType Sequence)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: Service cancels the specified on-going sequence transmission.\n\nSync/Async: Synchronous\nParameters(in)\n    None\nParameters(inout)\n    None\nParameters(out)\n    None\nReturn value: None\n"})}),"\n",(0,s.jsx)(n.h4,{id:"std_returntype-spi_setasyncmodespi_asyncmodetype-mode",children:"Std_ReturnType Spi_SetAsyncMode(Spi_AsyncModeType Mode)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: Service to set the asynchronous mechanism mode for SPI\n             busses handled asynchronously.\n\nSync/Async: Synchronous\nParameters(in)\n    Mode: New mode required.\nParameters(inout)\n    None\nParameters(out)\n    None\nReturn value:    Std_ReturnType:\n    E_OK: Setting command has been accepted\n    E_NOT_OK: Setting command has not been accepted\n"})}),"\n",(0,s.jsx)(n.h4,{id:"void-spi_mainfunction_handlingvoid",children:"void Spi_MainFunction_Handling(void)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: This function shall poll the SPI interrupts linked to HW Units\n             allocated to the transmission of SPI sequences to enable the evolution\n             of transmission state machine.\n\nSync/Async: Synchronous\nParameters(in)\n    None\nParameters(inout)\n    None\nParameters(out)\n    None\nReturn value: None\n"})})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);