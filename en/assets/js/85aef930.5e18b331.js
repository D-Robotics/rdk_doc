"use strict";(self.webpackChunkrdk_doc=self.webpackChunkrdk_doc||[]).push([[33830],{28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>_});var i=n(96540);const o={},d=i.createContext(o);function r(e){const t=i.useContext(d);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function _(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(d.Provider,{value:t},e.children)}},99250:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>_,default:()=>c,frontMatter:()=>r,metadata:()=>i,toc:()=>s});const i=JSON.parse('{"id":"Advanced_development/linux_development/driver_development_x5/driver_io_domain_dev","title":"IO-DOMAIN Debugging Guide","description":"IO-Domain is used to configure the voltage domains for the X5 module. Taking the RGMII interface as an example, if the external voltage domain is designed to be 3.3V, the IO-DOMAIN for the RGMII module needs to be set to 3.3V. If the external voltage domain is 1.8V, the configuration should be 1.8V. It is important to note the following:","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/07_Advanced_development/02_linux_development/driver_development_x5/driver_io_domain_dev.md","sourceDirName":"07_Advanced_development/02_linux_development/driver_development_x5","slug":"/Advanced_development/linux_development/driver_development_x5/driver_io_domain_dev","permalink":"/rdk_doc/en/Advanced_development/linux_development/driver_development_x5/driver_io_domain_dev","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1756732076000,"sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Pinctrl Debugging Guide","permalink":"/rdk_doc/en/Advanced_development/linux_development/driver_development_x5/driver_pinctrl_dev"},"next":{"title":"SPI Debugging Guide","permalink":"/rdk_doc/en/Advanced_development/linux_development/driver_development_x5/driver_spi_dev"}}');var o=n(74848),d=n(28453);const r={sidebar_position:6},_="IO-DOMAIN Debugging Guide",l={},s=[{value:"Driver Code",id:"driver-code",level:2},{value:"Code Location",id:"code-location",level:3},{value:"IO-DOMAIN DTS",id:"io-domain-dts",level:3},{value:"DTS Configuration for Driver Call",id:"dts-configuration-for-driver-call",level:3},{value:"Driver Call Example Code",id:"driver-call-example-code",level:3},{value:"Modifying Voltage Domain in U-Boot",id:"modifying-voltage-domain-in-u-boot",level:2}];function a(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,d.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"io-domain-debugging-guide",children:"IO-DOMAIN Debugging Guide"})}),"\n",(0,o.jsx)(t.p,{children:"IO-Domain is used to configure the voltage domains for the X5 module. Taking the RGMII interface as an example, if the external voltage domain is designed to be 3.3V, the IO-DOMAIN for the RGMII module needs to be set to 3.3V. If the external voltage domain is 1.8V, the configuration should be 1.8V. It is important to note the following:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"If the external voltage domain is 3.3V but the corresponding IO-DOMAIN is configured to 1.8V, it may cause damage to the chip."}),"\n",(0,o.jsx)(t.li,{children:"If the external voltage domain is 1.8V but the corresponding IO-DOMAIN is configured to 3.3V, the module may fail to function properly."}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"driver-code",children:"Driver Code"}),"\n",(0,o.jsx)(t.h3,{id:"code-location",children:"Code Location"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-bash",children:"drivers/pinctrl/hobot/ # Directory containing the source files for the pinctrl driver\ninclude/linux/platform_data/pinctrl-single.h # Header file for the pinctrl driver\n"})}),"\n",(0,o.jsx)(t.h3,{id:"io-domain-dts",children:"IO-DOMAIN DTS"}),"\n",(0,o.jsxs)(t.p,{children:["The Pinctrl function-related definitions for the X5 are located in the ",(0,o.jsx)(t.code,{children:"pinmux-func.dtsi"})," file under the ",(0,o.jsx)(t.code,{children:"arch/arm64/boot/dts/hobot/"})," folder within the SDK package kernel directory."]}),"\n",(0,o.jsx)(t.p,{children:"Since IO-Domain is implemented within the pinctrl-single framework, its DTS configuration is similar to that of pinctrl. In the IO-Domain DTS, all the 1.8V and 3.3V configuration groups for the modules are already listed. Typically, customers do not need to modify this. During development, they can simply choose the appropriate configuration based on the actual requirements."}),"\n",(0,o.jsx)(t.p,{children:'A special case is the configuration for SD and SDIO IO-Domain groups. Since the voltage domain for SD and SDIO are configured simultaneously on the chip\u2019s PAD, we use the MMC controller for SD and SDIO to independently control the voltage domain of the SD/SDIO pins. The configuration option is the custom "power-source" macro, as shown below:'}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-c",children:"...\n\tpconf_sd_sdio_ds12_padctrl_3v3: pconf-sd-sdio-ds12-padctrl-3v3 {\n\t\tbias-pull-up;\n\t\tpower-source = <HORIZON_IO_PAD_CTRL_VOLTAGE_3V3>;\n\t\tdrive-strength = <12>;\n\t};\n\n\tpconf_sd_sdio_pu_ds12_padctrl_1v8: pconf-sd-sdio-ds12-padctrl-1v8 {\n\t\tbias-pull-up;\n\t\tpower-source = <HORIZON_IO_PAD_CTRL_VOLTAGE_1V8>;\n\t\tdrive-strength = <12>;\n\t};\n...\n\n\tpinctrl_sd: sdgrp {\n\t\thorizon,pins = <\n\t\t\tHSIO_SD_WP\t\tHSIO_PINMUX_2\tBIT_OFFSET24\tMUX_ALT0\t&pconf_sd_sdio_pu_ds12_ipctrl\n\t\t\tHSIO_SD_CLK\t\tHSIO_PINMUX_2\tBIT_OFFSET22\tMUX_ALT0\t&pconf_sd_sdio_pu_ds12_ipctrl\n\t\t\tHSIO_SD_CMD\t\tHSIO_PINMUX_2\tBIT_OFFSET20\tMUX_ALT0\t&pconf_sd_sdio_pu_ds12_ipctrl\n\t\t\tHSIO_SD_CDN\t\tHSIO_PINMUX_2\tBIT_OFFSET18\tMUX_ALT0\t&pconf_sd_sdio_pu_ds12_ipctrl\n\t\t\tHSIO_SD_DATA0\tHSIO_PINMUX_2\tBIT_OFFSET16\tMUX_ALT0\t&pconf_sd_sdio_pu_ds12_ipctrl\n\t\t\tHSIO_SD_DATA1\tHSIO_PINMUX_2\tBIT_OFFSET14\tMUX_ALT0\t&pconf_sd_sdio_pu_ds12_ipctrl\n\t\t\tHSIO_SD_DATA2\tHSIO_PINMUX_2\tBIT_OFFSET12\tMUX_ALT0\t&pconf_sd_sdio_pu_ds12_ipctrl\n\t\t\tHSIO_SD_DATA3\tHSIO_PINMUX_2\tBIT_OFFSET10\tMUX_ALT0\t&pconf_sd_sdio_pu_ds12_ipctrl\n\t\t>;\n\t};\n\n\tpinctrl_sdio: sdiogrp {\n\t\thorizon,pins = <\n\t\t\tHSIO_SDIO_WP\tHSIO_PINMUX_2\tBIT_OFFSET8\tMUX_ALT0\t\t&pconf_sd_sdio_pu_ds12_ipctrl\n\t\t\tHSIO_SDIO_CLK\tHSIO_PINMUX_0\tBIT_OFFSET30\tMUX_ALT0\t&pconf_sd_sdio_pu_ds12_ipctrl\n\t\t\tHSIO_SDIO_CMD\tHSIO_PINMUX_0\tBIT_OFFSET28\tMUX_ALT0\t&pconf_sd_sdio_pu_ds12_ipctrl\n\t\t\tHSIO_SDIO_DATA0\tHSIO_PINMUX_1\tBIT_OFFSET0\t\tMUX_ALT0\t&pconf_sd_sdio_pu_ds12_ipctrl\n\t\t\tHSIO_SDIO_DATA1\tHSIO_PINMUX_2\tBIT_OFFSET30\tMUX_ALT0\t&pconf_sd_sdio_pu_ds12_ipctrl\n\t\t\tHSIO_SDIO_DATA2\tHSIO_PINMUX_2\tBIT_OFFSET28\tMUX_ALT0\t&pconf_sd_sdio_pu_ds12_ipctrl\n\t\t\tHSIO_SDIO_DATA3\tHSIO_PINMUX_2\tBIT_OFFSET26\tMUX_ALT0\t&pconf_sd_sdio_pu_ds12_ipctrl\n\t\t>;\n\t};\n...\n"})}),"\n",(0,o.jsx)(t.h3,{id:"dts-configuration-for-driver-call",children:"DTS Configuration for Driver Call"}),"\n",(0,o.jsx)(t.p,{children:"First, define the special voltage domain configuration for the current hardware in the DTS. For example, to configure PWM0 channel 1 to 1.8V:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-c",children:"&lsio_iomuxc {\n    pinctrl_pwm0_1_1v8: pinctrl-pwm0-1_1v8 {\n        horizon,pins = <\n            LSIO_SPI2_SSN\tLSIO_PINMUX_1\tBIT_OFFSET18\tMUX_ALT3\t&pconf_pwm_1v8\n        >;\n    };\n}\n"})}),"\n",(0,o.jsx)(t.p,{children:"Similar to the usage of pinctrl, the driver references the IO-Domain that needs to be configured in its own DTS. For example, for the PWM driver, the configuration is as follows:\n\uff1a"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-c",children:'&pwm0 {\n    ...\n    pinctrl-names = "default";\n    pinctrl-0 = <&pinctrl_pwm0_1_1v8>; /* Configure pwm0 Ch1 to 1.8V voltage domain, PWM0 function */\n\n    ...\n};\n'})}),"\n",(0,o.jsx)(t.h3,{id:"driver-call-example-code",children:"Driver Call Example Code"}),"\n",(0,o.jsx)(t.p,{children:"Similar to the Pinctrl invocation method, the driver first searches for the corresponding pinctrl state using Pinctrl-names, and then switches to the appropriate state."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-c",children:'static int hobot_xxx_probe(struct platform_device *pdev)\n{\n    ...\n    g_xxx_dev->pinctrl = devm_pinctrl_get(&pdev->dev);\n    if (IS_ERR(g_xxx_dev->pinctrl)) {\n        dev_warn(&pdev->dev, "pinctrl get none\\n");\n        g_xxx_dev->pins_voltage = NULL;\n    }\n    ...\n        \n\n        /* Lookup state according to pinctrl-names */\n        g_xxx_dev->pins_voltage = pinctrl_lookup_state(g_xxx_dev->pinctrl,\n                "xxx_voltage_func");\n    if (IS_ERR(g_xxx_dev->pins_voltage)) {\n        dev_info(&pdev->dev, "xxx_voltage_func get error %ld\\n",\n                PTR_ERR(g_xxx_dev->pins_voltage));\n        g_xxx_dev->pins_voltage = NULL;\n    }\n    ...\n        /* select state */\n        if (g_xxx_dev->pins_voltage) {\n            ret = pinctrl_select_state(g_xxx_dev->pinctrl, g_xxx_dev->pins_voltage);\n            if (ret) {\n                dev_info(&pdev->dev, "xxx_voltage_func set error %d\\n", ret);\n            }\n        }\n    ...\n}\n'})}),"\n",(0,o.jsx)(t.h2,{id:"modifying-voltage-domain-in-u-boot",children:"Modifying Voltage Domain in U-Boot"}),"\n",(0,o.jsx)(t.p,{children:"The Pinctrl driver is already implemented in X5's U-Boot. The usage is consistent with the kernel, and the specific properties of the pins are defined through DTS."})]})}function c(e={}){const{wrapper:t}={...(0,d.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(a,{...e})}):a(e)}}}]);