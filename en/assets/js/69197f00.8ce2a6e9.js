"use strict";(self.webpackChunkrdk_doc=self.webpackChunkrdk_doc||[]).push([[43661],{28453:(e,r,n)=>{n.d(r,{R:()=>i,x:()=>a});var o=n(96540);const s={},t=o.createContext(s);function i(e){const r=o.useContext(t);return o.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(t.Provider,{value:r},e.children)}},66113:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>i,metadata:()=>o,toc:()=>m});const o=JSON.parse('{"id":"Advanced_development/linux_development/driver_development_s100/driver_hbmem/s100_hbmem_introduce","title":"Function Description","description":"The Hbmem module primarily implements the following functionalities: memory allocation, memory sharing, memory queue management, and memory pools, specifically designed for managing system-reserved memory.","source":"@site/i18n/en/docusaurus-plugin-content-docs-docs_s/current/07_Advanced_development/02_linux_development/04_driver_development_s100/15_driver_hbmem/01_s100_hbmem_introduce.md","sourceDirName":"07_Advanced_development/02_linux_development/04_driver_development_s100/15_driver_hbmem","slug":"/Advanced_development/linux_development/driver_development_s100/driver_hbmem/s100_hbmem_introduce","permalink":"/rdk_doc/en/rdk_s/Advanced_development/linux_development/driver_development_s100/driver_hbmem/s100_hbmem_introduce","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1768581666000,"sidebarPosition":1,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"HBMEM\u4f7f\u7528\u6307\u5357","permalink":"/rdk_doc/en/rdk_s/15_driver_hbmem"},"next":{"title":"Hardware Information","permalink":"/rdk_doc/en/rdk_s/Advanced_development/linux_development/driver_development_s100/driver_hbmem/s100_hbmem_hardware"}}');var s=n(74848),t=n(28453);const i={},a="Function Description",l={},m=[{value:"Memory Allocation",id:"memory-allocation",level:2},{value:"Memory Sharing",id:"memory-sharing",level:2},{value:"Memory Queue Management",id:"memory-queue-management",level:2},{value:"Memory Pool",id:"memory-pool",level:2},{value:"Shared Memory Pool",id:"shared-memory-pool",level:2}];function d(e){const r={h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"function-description",children:"Function Description"})}),"\n",(0,s.jsxs)(r.p,{children:["The Hbmem module primarily implements the following functionalities: ",(0,s.jsx)(r.strong,{children:"memory allocation"}),", ",(0,s.jsx)(r.strong,{children:"memory sharing"}),", ",(0,s.jsx)(r.strong,{children:"memory queue management"}),", and ",(0,s.jsx)(r.strong,{children:"memory pools"}),", specifically designed for managing ",(0,s.jsx)(r.strong,{children:"system-reserved memory"}),"."]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.img,{src:"http://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/02_linux_development/driver_development_s100/hbmem/01_func_overview-en.png",alt:""})}),"\n",(0,s.jsx)(r.h2,{id:"memory-allocation",children:"Memory Allocation"}),"\n",(0,s.jsx)(r.p,{children:"The memory allocation interfaces mainly implement functionalities such as allocation, deallocation, and cache flushing for physically contiguous memory. This module provides two types of memory allocation:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"com_buf"}),": Used for general-purpose allocation of large contiguous memory blocks, suitable for scenarios like audio data or plain feature maps."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"graph_buf"}),": Used for allocating memory for RGB, RAW, and YUV images. For RGB and RAW formats, a single buffer is used. For planar YUV formats, physical addresses of individual components are non-contiguous, making it suitable for scenarios such as Pyramid output buffers."]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"Additionally, if multiple graphic buffers need to be allocated, users can utilize the graphic buffer group-related interfaces. These interfaces support allocating multiple graphic buffers at once and returning them as a group."}),"\n",(0,s.jsxs)(r.p,{children:["This module also supports setting memory attributes, including cache attributes and memory heap attributes. After successful memory allocation, ",(0,s.jsx)(r.strong,{children:"users obtain a corresponding file descriptor"}),". Based on this file descriptor, users can perform operations such as releasing the physical memory, invalidating/flushing caches, and retrieving buffer information. To facilitate memory operations, this module also supports using virtual addresses for cache invalidation/flushing and retrieving buffer information."]}),"\n",(0,s.jsxs)(r.p,{children:["It is ",(0,s.jsx)(r.strong,{children:"not recommended"})," for users to directly perform mmap or pass physical addresses, as these operations ",(0,s.jsx)(r.strong,{children:"do not increment the memory's reference count"}),", potentially leading to situations where users continue accessing memory after it has already been freed."]}),"\n",(0,s.jsx)(r.h2,{id:"memory-sharing",children:"Memory Sharing"}),"\n",(0,s.jsx)(r.p,{children:"The memory sharing module provides interfaces enabling safe memory sharing across multiple threads or processes. Users can directly pass buffers of type com_buf or graph_buf to another thread or process and then import the buffer using the relevant import interfaces. This allows users to retrieve the buffer's information and increment its reference count, preventing premature deallocation by other modules and thus enabling safe buffer sharing. This sharing mechanism is primarily implemented through memory queue management, facilitating buffer exchange between producers and consumers."}),"\n",(0,s.jsx)(r.p,{children:"Similarly, graphic buffer groups also support safe memory sharing across multiple threads or processes, using a method analogous to that of individual graphic buffers."}),"\n",(0,s.jsx)(r.h2,{id:"memory-queue-management",children:"Memory Queue Management"}),"\n",(0,s.jsxs)(r.p,{children:["The memory queue management module provides a generic queue management mechanism supporting four operational states for queue elements: ",(0,s.jsx)(r.strong,{children:"FREE"}),", ",(0,s.jsx)(r.strong,{children:"DEQUEUE"}),", ",(0,s.jsx)(r.strong,{children:"QUEUE"}),", and ",(0,s.jsx)(r.strong,{children:"REQUEST"}),":"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"FREE"}),": Indicates that the producer can acquire this queue slot and fill in element information."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"DEQUEUE"}),": Indicates that the element has been acquired by the producer and has not yet been returned."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"QUEUE"}),": Indicates that the producer has filled the element and it is ready for the consumer to acquire."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"REQUEST"}),": Indicates that the element has been acquired by the consumer and has not yet been released."]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"Producers and consumers use their respective interfaces to ensure proper cycling of buffer elements between them."}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Note"}),": Since the memory queue is implemented as a circular queue, once it becomes full, writing new events will overwrite the oldest (first) event. Additionally, ",(0,s.jsx)(r.strong,{children:"this queue only supports operations within a single process"}),"."]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.img,{src:"http://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/02_linux_development/driver_development_s100/hbmem/01_memory_queue-en.jpg",alt:""})}),"\n",(0,s.jsx)(r.h2,{id:"memory-pool",children:"Memory Pool"}),"\n",(0,s.jsx)(r.p,{children:"The memory pool module provides interfaces allowing users to create a local memory pool via the memory allocation functionality and then allocate or deallocate small memory blocks from this pool."}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Using the memory pool module enables users to allocate memory quickly without entering kernel mode"}),", thereby achieving more efficient memory management. Currently, user programs (e.g., hbrt, dnn, etc.) often implement their own memory management modules to accelerate memory allocation, resulting in code duplication and increased development and maintenance overhead. Therefore, users are encouraged to adopt the memory pool module for memory management to improve code reusability."]}),"\n",(0,s.jsxs)(r.p,{children:["During system boot-up, a large memory block is pre-allocated for users. Consequently, when users request memory later, they can directly use memory from this pre-allocated pool, bypassing the need to enter kernel mode for allocation\u2014effectively pre-completing this step. ",(0,s.jsx)(r.strong,{children:"Note that this memory pool currently only supports operations within a single process, and memory allocated from the pool cannot be shared across multiple processes."})]}),"\n",(0,s.jsx)(r.h2,{id:"shared-memory-pool",children:"Shared Memory Pool"}),"\n",(0,s.jsx)(r.p,{children:"The shared memory pool provides the same functionality as described above, with the key difference being that memory allocated from a shared memory pool supports sharing across multiple processes. However, all buffers allocated from a shared memory pool must be of the same size, which can only be specified when the shared memory pool is created. Due to multi-process sharing support, operations such as importing or freeing buffers from a shared memory pool are slightly less efficient compared to those from a regular (non-shared) memory pool."})]})}function c(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);