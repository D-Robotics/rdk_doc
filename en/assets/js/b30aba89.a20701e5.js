"use strict";(self.webpackChunkrdk_doc=self.webpackChunkrdk_doc||[]).push([[97357],{28453:(e,n,i)=>{i.d(n,{R:()=>p,x:()=>t});var r=i(96540);const c={},d=r.createContext(c);function p(e){const n=r.useContext(d);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:p(e.components),r.createElement(d.Provider,{value:n},e.children)}},88760:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>t,default:()=>o,frontMatter:()=>p,metadata:()=>r,toc:()=>s});const r=JSON.parse('{"id":"Advanced_development/linux_development/driver_development_s100/driver_pcie/s100x_pcie_libhbpciehal","title":"PCIe \u7528\u6237\u6001 High Level API\u4ecb\u7ecd","description":"\u7b80\u4ecb","source":"@site/docs_s/07_Advanced_development/02_linux_development/04_driver_development_s100/13_driver_pcie/04_s100x_pcie_libhbpciehal.md","sourceDirName":"07_Advanced_development/02_linux_development/04_driver_development_s100/13_driver_pcie","slug":"/Advanced_development/linux_development/driver_development_s100/driver_pcie/s100x_pcie_libhbpciehal","permalink":"/rdk_doc/en/rdk_s/Advanced_development/linux_development/driver_development_s100/driver_pcie/s100x_pcie_libhbpciehal","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1756744459000,"sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"S100X PCIe\u6a21\u5757\u529f\u80fd\u5728kernel\u4e0b\u7684\u914d\u7f6e","permalink":"/rdk_doc/en/rdk_s/Advanced_development/linux_development/driver_development_s100/driver_pcie/s100x_pcie_sw_setup"},"next":{"title":"WiFi\u9a71\u52a8\u8c03\u8bd5\u6307\u5357","permalink":"/rdk_doc/en/rdk_s/Advanced_development/linux_development/driver_development_s100/driver_wifi"}}');var c=i(74848),d=i(28453);const p={sidebar_position:4},t="PCIe \u7528\u6237\u6001 High Level API\u4ecb\u7ecd",l={},s=[{value:"\u7b80\u4ecb",id:"\u7b80\u4ecb",level:2},{value:"API\u5217\u8868",id:"api\u5217\u8868",level:2},{value:"\u4f7f\u7528\u6d41\u7a0b",id:"\u4f7f\u7528\u6d41\u7a0b",level:2},{value:"Publisher(chip#0)",id:"publisherchip0",level:3},{value:"Subscriber(chip#1)",id:"subscriberchip1",level:3}];function a(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,d.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(n.header,{children:(0,c.jsx)(n.h1,{id:"pcie-\u7528\u6237\u6001-high-level-api\u4ecb\u7ecd",children:"PCIe \u7528\u6237\u6001 High Level API\u4ecb\u7ecd"})}),"\n",(0,c.jsx)(n.h2,{id:"\u7b80\u4ecb",children:"\u7b80\u4ecb"}),"\n",(0,c.jsx)(n.p,{children:"High Level API (libhbpciehl.so) \u57fa\u4e8e Low Level API\uff08libhbpcie.so)\uff0c\u62bd\u8c61\u51fa\u901a\u7528\u7684 topic / subscribe / publish \u6982\u5ff5\uff0c\u5c4f\u853d\u4e0d\u540c\u7cfb\u5217\u5730\u74dc\u82af\u7247\u7684\u786c\u4ef6\u5dee\u5f02\uff0c\u8ba9\u7528\u6237\u80fd\u591f\u66f4\u52a0\u4fbf\u6377\u7684\u4f7f\u7528 PCIe \u8fdb\u884c\u6570\u636e\u901a\u4fe1\u3002"}),"\n",(0,c.jsx)(n.p,{children:"\u4e3b\u8981\u652f\u6301\u5982\u4e0b\u529f\u80fd\uff1a"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"\u6570\u636e\u7684\u53d1\u9001\uff08publish\uff09"}),"\n",(0,c.jsx)(n.li,{children:"\u6570\u636e\u7684\u63a5\u6536\uff08subscribe\uff09"}),"\n",(0,c.jsxs)(n.li,{children:["\u53d1\u9001/\u63a5\u6536Buffer\u7684\u7ba1\u7406","\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"\u4f7f\u7528\u5185\u5efabuffer"}),"\n",(0,c.jsx)(n.li,{children:"\u4f7f\u7528\u7528\u6237\u7533\u8bf7\u7684buffer(\u8981\u6c42\u7269\u7406\u5730\u5740\u8fde\u7eed\uff09"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.h2,{id:"api\u5217\u8868",children:"API\u5217\u8868"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-c",children:"pcieErrCode pcieInit(pcieHandler *ph, uint8_t chipID, uint8_t topicID);\npcieErrCode pcieDeInit(pcieHandler ph);\npcieErrCode pcieGetMaxTopicSize(pcieHandler ph, uint8_t *topicSize);\npcieErrCode pciePublish(pcieHandler ph, uint8_t weight);\npcieErrCode pcieSubscribe(pcieHandler ph);\npcieErrCode pcieGetMaxInnerBufSize(pcieHandler ph, uint32_t *size);\npcieErrCode pcieAllocInnerBuf(pcieHandler ph, uint32_t size, void **virtualAddr, uint64_t *physAddr);\npcieErrCode pcieRegisterUserBuf(pcieHandler ph, uint64_t physAddr, uint32_t size);\npcieErrCode pcieStartRecv(pcieHandler ph, recvDataCallBack fun, void *funData);\npcieErrCode pcieSendData(pcieHandler ph, uint32_t size);\n"})}),"\n",(0,c.jsx)(n.h2,{id:"\u4f7f\u7528\u6d41\u7a0b",children:"\u4f7f\u7528\u6d41\u7a0b"}),"\n",(0,c.jsx)(n.p,{children:"\u53d1\u9001\u65b9\u548c\u63a5\u6536\u65b9\u7684\u6d41\u7a0b\u5982\u4e0b\u56fe\uff1a"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/02_linux_development/driver_development_s100/pcie/hl_process.png",alt:"\u56fe\u7247\u63cf\u8ff0"})}),"\n",(0,c.jsx)(n.h3,{id:"publisherchip0",children:"Publisher(chip#0)"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-c",children:"void main()\n{\n    uint32_t size;\n    void *addr;\n    uint64_t phys;\n    pcieHandler ph;\n    void *UserBuffer;\n    uint64_t UserBufferPhys;\n\n    /* connect chip1 topic0 */\n    pcieInit(&ph, 1, 0);\n\n    pciePublish(ph);\n\n    if (useInnerBuffer) {\n        pcieGetMaxInnerBufSize(ph, &size);\n        pcieAllocInnerBuf(ph, &addr, &phys, size);\n        /* fill user data to inner buffer */\n        ...\n\n    } else {\n        /* prepare the User data */\n        ...\n        /* use data in user buffer */\n        pcieRegisterUserBuf(ph, UserBufferPhys, size);\n    }\n\n    pcieSendData(ph, size);\n\n    pcieDeInit(ph);\n\n    return;\n}\n"})}),"\n",(0,c.jsx)(n.h3,{id:"subscriberchip1",children:"Subscriber(chip#1)"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-c",children:"void recvDataHandler(pcieHandler ph, uint32_t RecvSize, void *pData)\n{\n    /* deal with the received data */\n    ...\n}\n\nvoid main()\n{\n    void *pData;\n    pcieHandler ph;\n    uint32_t size;\n    void *addr;\n    uint64_t phys;\n\n    /* connect chip0 topic0 */\n    pcieInit(&ph, 0, 0);\n\n    pcieSubscribe(ph);\n\n    if (useInnerBuffer) {\n        pcieGetMaxInnerBufSize(ph, &size);\n        pcieAllocInnerBuf(ph, &addr, &phys, size);\n    } else {\n        /* alloc user buff */\n        ...\n        pcieRegisterUserBuf(ph, UserBufferPhys, size);\n    }\n\n    pcieStartRecv(ph, recvDataHandler, pData);\n\n    /* wait for receiving data */\n    while (1) {\n        sleep(1);\n    }\n\n    pcieDeInit(ph);\n\n    return;\n}\n"})})]})}function o(e={}){const{wrapper:n}={...(0,d.R)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(a,{...e})}):a(e)}}}]);