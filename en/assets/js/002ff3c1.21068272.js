"use strict";(self.webpackChunkrdk_doc=self.webpackChunkrdk_doc||[]).push([[94866],{10468:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"Advanced_development/mcu_development/S100/basic_information","title":"MCU Quick Start Guide","description":"Scope","source":"@site/i18n/en/docusaurus-plugin-content-docs-docs_s/current/07_Advanced_development/05_mcu_development/01_S100/01_basic_information.md","sourceDirName":"07_Advanced_development/05_mcu_development/01_S100","slug":"/Advanced_development/mcu_development/S100/basic_information","permalink":"/rdk_doc/en/rdk_s/Advanced_development/mcu_development/S100/basic_information","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1764750792000,"sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"MCU Code Package Structure Introduction","permalink":"/rdk_doc/en/rdk_s/Advanced_development/mcu_development/S100/code_release"},"next":{"title":"MCU System Description","permalink":"/rdk_doc/en/rdk_s/Advanced_development/mcu_development/S100/MCU_build_system"}}');var t=i(74848),o=i(28453);const r={sidebar_position:1},l="MCU Quick Start Guide",d={},c=[{value:"Scope",id:"scope",level:2},{value:"Basic Information",id:"basic-information",level:2},{value:"MCU Architecture",id:"mcu-architecture",level:2},{value:"Development Environment",id:"development-environment",level:2},{value:"Host Compilation Environment Requirements",id:"host-compilation-environment-requirements",level:3},{value:"Compiling the MCU System",id:"compiling-the-mcu-system",level:2},{value:"Compilation Success Indication",id:"compilation-success-indication",level:2},{value:"Compilation Output Directory",id:"compilation-output-directory",level:3},{value:"MCU1 Startup/Shutdown Process",id:"mcu1-startupshutdown-process",level:2},{value:"MCU1 Startup Principle and Steps",id:"start_mcu1",level:3},{value:"MCU1 Startup Principle",id:"mcu1-startup-principle",level:4},{value:"MCU1 Startup Steps",id:"mcu1-startup-steps",level:4},{value:"MCU1 Shutdown Principle and Steps",id:"mcu1-shutdown-principle-and-steps",level:3},{value:"MCU1 Shutdown Principle",id:"mcu1-shutdown-principle",level:4},{value:"MCU1 Shutdown Steps",id:"mcu1-shutdown-steps",level:4},{value:"MCU0/MCU1 Module Partitioning",id:"mcu0mcu1-module-partitioning",level:2},{value:"MCU Debug Features in sysfs",id:"mcu-debug-features-in-sysfs",level:2},{value:"MCU UART Usage",id:"mcu-uart-usage",level:2},{value:"MCU0 Flashing Procedure",id:"mcu0-flashing-procedure",level:2},{value:"Manual Flashing",id:"manual-flashing",level:3},{value:"Flashing on a Non-Blank Board",id:"flashing-on-a-non-blank-board",level:4},{value:"Flashing on a Blank Board",id:"flashing-on-a-blank-board",level:4},{value:"Tool-Based Flashing",id:"tool-based-flashing",level:3},{value:"MCU1 Undefined/Abort Exception Handling Principle",id:"mcu1-undefinedabort-exception-handling-principle",level:2},{value:"Overview of MCU1 main() Function",id:"overview-of-mcu1-main-function",level:2},{value:"MCU Log Overview",id:"mcu-log-overview",level:2}];function a(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"mcu-quick-start-guide",children:"MCU Quick Start Guide"})}),"\n",(0,t.jsx)(n.h2,{id:"scope",children:"Scope"}),"\n",(0,t.jsx)(n.p,{children:"This section provides an overview of the RDK-S100 MCU system, aiming to help readers quickly understand and master the relevant content to facilitate MCU1 development. Since MCU0 handles functions such as booting the Acore, MCU1, and power management, it is not recommended for customers to modify this part. The source code for MCU0 is not released by default; instead, pre-validated binary files from D-Robotics are provided. This chapter only briefly describes parts that might conflict with MCU1, helping users avoid resource contention issues between MCU0 and MCU1 during development."}),"\n",(0,t.jsx)(n.h2,{id:"basic-information",children:"Basic Information"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"The MCU compilation toolchain is GCC, specifically version gcc-arm-none-eabi-10.3-2021.10."}),"\n",(0,t.jsxs)(n.li,{children:["The MCU core is ARM R52+. You can refer to the ARM R52 Technical Reference Manual: ",(0,t.jsx)(n.a,{href:"https://developer.arm.com/documentation/100026/latest",children:"Official Link"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"Both MCUs run FreeRTOS, version FreeRTOS Kernel V10.0.1."}),"\n",(0,t.jsx)(n.li,{children:"The MCU system is primarily divided into two parts: MCU0 and MCU1. MCU0 handles booting the Acore, MCU1, and power management, and its source code is currently not open-sourced. MCU1 runs user applications and is open-sourced, allowing customers to modify it according to their needs."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"mcu-architecture",children:"MCU Architecture"}),"\n",(0,t.jsx)(n.p,{children:"MCU0 is the starting point of board initialization and is critically important, as it manages booting the Acore, MCU1, and power management. The Linux OS running on the Acore serves as the primary platform for customer application development, while the FreeRTOS OS on MCU1 ensures reliable execution of real-time tasks."}),"\n",(0,t.jsx)(n.p,{children:"MCU1 is implemented via Linux's remoteproc framework. The Acore controls MCU1's startup and shutdown by sending notifications to MCU0 through sysfs. Additionally, during RDK-S100's sleep mode, the Acore notifies MCU0 to manage MCU1, enabling low-power sleep functionality."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"http://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/05_mcu_development/01_S100/basic_information/MCU_frame-en.jpg",alt:""})}),"\n",(0,t.jsx)(n.h2,{id:"development-environment",children:"Development Environment"}),"\n",(0,t.jsx)(n.p,{children:"Cross-compilation refers to developing and building software on a host machine, then deploying the built software onto the development board for execution. Host machines typically offer higher performance and more memory than development boards, enabling efficient code building and supporting a wider range of development tools."}),"\n",(0,t.jsx)(n.h3,{id:"host-compilation-environment-requirements",children:"Host Compilation Environment Requirements"}),"\n",(0,t.jsx)(n.p,{children:"Ubuntu 22.04 is recommended to maintain consistency with the RDK S100 system version and minimize dependency issues caused by version mismatches."}),"\n",(0,t.jsx)(n.p,{children:"Install the following packages on Ubuntu 22.04:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'sudo apt-get install -y build-essential make cmake libpcre3 libpcre3-dev bc bison \\\n                        flex python3-numpy mtd-utils zlib1g-dev debootstrap \\\n                        libdata-hexdumper-perl libncurses5-dev zip qemu-user-static \\\n                        curl repo git liblz4-tool apt-cacher-ng libssl-dev checkpolicy autoconf \\\n                        android-sdk-libsparse-utils mtools parted dosfstools udev rsync python3-pip scons\n\npip install "scons>=4.0.0"\npip install ecdsa\npip install tqdm\n'})}),"\n",(0,t.jsx)(n.h2,{id:"compiling-the-mcu-system",children:"Compiling the MCU System"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Python3 is used for compilation. The RDK S100 development environment uses Python 3.8.10."}),"\n",(0,t.jsx)(n.li,{children:"MCU1 images are available in two versions: debug and release. The debug version includes debugging information, while the release version does not."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"# Compile MCU1 Debug version\ncd mcu/Build/FreeRtos_mcu1\npython build_freertos.py s100_sip_B debug\n# 1. On the first compilation, the toolchain will be downloaded from ARM's official website and extracted (takes ~10 minutes). Poor network connectivity may cause download failures or incomplete downloads. In such cases, delete the partially downloaded toolchain and retry.\n# 2. If you already have the toolchain, move it to /Build/ToolChain/Gcc/. The build script will skip downloading if the toolchain is detected.\n# mv <toolchain_path>/gcc-arm-none-eabi-10.3-2021.10/ <new_code_path>/Build/ToolChain/Gcc/gcc-arm-none-eabi-10.3-2021.10\n*/\n\n# Compile MCU1 Release version\ncd mcu/Build/FreeRtos_mcu1\npython build_freertos.py s100_sip_B release\n"})}),"\n",(0,t.jsx)(n.h2,{id:"compilation-success-indication",children:"Compilation Success Indication"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/05_mcu_development/01_S100/basic_information/build_success.png",alt:""})}),"\n",(0,t.jsx)(n.h3,{id:"compilation-output-directory",children:"Compilation Output Directory"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"output/\n\u251c\u2500\u2500 debug                               # Contains files generated for the debug version\n|    \u251c\u2500\u2500 objs                           # Generated .i/.s/.o files\n|    \u2514\u2500\u2500 S100_MCU_SIP_V2.0              # Generated .bin/.map/.elf files\n|         \u251c\u2500\u2500 custom_compiler_flags.py\n|         \u251c\u2500\u2500 S100_MCU_DEBUG.elf        # MCU1 firmware file\n|         \u251c\u2500\u2500 S100_MCU_DEBUG.map\n|         \u251c\u2500\u2500 S100_MCU_SIP_V2.0.bin\n\u251c\u2500\u2500 objs                                # Generated .i/.s/.o files (varies by build version)\n\u251c\u2500\u2500 release                             # Contains files generated for the release version\n|    \u251c\u2500\u2500 objs                           # Generated .i/.s/.o files\n|    \u2514\u2500\u2500 S100_MCU_SIP_V2.0              # Generated .bin/.map/.elf files\n"})}),"\n",(0,t.jsx)(n.h2,{id:"mcu1-startupshutdown-process",children:"MCU1 Startup/Shutdown Process"}),"\n",(0,t.jsx)(n.p,{children:"MCU1 startup and shutdown are controlled by the Acore through the remoteproc framework, which sends commands to MCU0 to manage MCU1."}),"\n",(0,t.jsx)(n.h3,{id:"start_mcu1",children:"MCU1 Startup Principle and Steps"}),"\n",(0,t.jsx)(n.h4,{id:"mcu1-startup-principle",children:"MCU1 Startup Principle"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"http://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/05_mcu_development/01_S100/basic_information/mcu1_start-en.jpg",alt:""})}),"\n",(0,t.jsx)(n.h4,{id:"mcu1-startup-steps",children:"MCU1 Startup Steps"}),"\n",(0,t.jsx)(n.p,{children:"The following steps use the debug version as an example; the release version is similar but with fewer log outputs."}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["After compilation, the debug build generates ",(0,t.jsx)(n.code,{children:"S100_MCU_DEBUG.elf"})," (similarly, the release build generates its own .elf file) in the ",(0,t.jsx)(n.code,{children:"S100_MCU_SIP_V2.0"})," folder. This file is the MCU1 firmware and must be pushed to the board's ",(0,t.jsx)(n.code,{children:"/lib/firmware"})," directory. For example:"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/05_mcu_development/01_S100/basic_information/push_elf.png",alt:""})}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsx)(n.li,{children:"Board-side startup procedure:"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"cd /sys/class/remoteproc/remoteproc_mcu0\necho S100_MCU_DEBUG.elf > firmware\necho start > state\n"})}),"\n",(0,t.jsx)(n.p,{children:"Upon successful startup, the serial logs appear as shown below."}),"\n",(0,t.jsx)(n.p,{children:"Acore-side serial log:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/05_mcu_development/01_S100/basic_information/Acore_start_log.png",alt:""})}),"\n",(0,t.jsx)(n.p,{children:"MCU-side serial log:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/05_mcu_development/01_S100/basic_information/MCU_start_log.png",alt:""})}),"\n",(0,t.jsx)(n.h3,{id:"mcu1-shutdown-principle-and-steps",children:"MCU1 Shutdown Principle and Steps"}),"\n",(0,t.jsx)(n.h4,{id:"mcu1-shutdown-principle",children:"MCU1 Shutdown Principle"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"http://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/05_mcu_development/01_S100/basic_information/mcu1_stop-en.jpg",alt:""})}),"\n",(0,t.jsx)(n.h4,{id:"mcu1-shutdown-steps",children:"MCU1 Shutdown Steps"}),"\n",(0,t.jsx)(n.p,{children:"The following steps use the debug version as an example; the release version is similar but with fewer log outputs."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"cd /sys/class/remoteproc/remoteproc_mcu0\necho S100_MCU_DEBUG.elf > firmware\necho stop > state\n"})}),"\n",(0,t.jsx)(n.p,{children:"Upon successful shutdown, the serial logs appear as shown below."}),"\n",(0,t.jsx)(n.p,{children:"Acore-side serial log:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/05_mcu_development/01_S100/basic_information/Acore_stop_log.png",alt:""})}),"\n",(0,t.jsx)(n.p,{children:"MCU-side serial log:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/05_mcu_development/01_S100/basic_information/MCU_stop_log.png",alt:""})}),"\n",(0,t.jsxs)(n.admonition,{type:"caution",children:[(0,t.jsx)(n.p,{children:"After stopping MCU1, you must wait until the system enters WFI (Wait For Interrupt) mode before restarting MCU1, as shown below. Explanation: If MCU1 is restarted before the system enters WFI mode, the firmware will be reloaded into the MCU SRAM, overwriting the previous code and potentially causing system crashes or hangs."}),(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/05_mcu_development/01_S100/basic_information/mcu1_enter_wfi.png",alt:""})})]}),"\n",(0,t.jsx)(n.h2,{id:"mcu0mcu1-module-partitioning",children:"MCU0/MCU1 Module Partitioning"}),"\n",(0,t.jsx)(n.p,{children:"The overall MCU system includes modules such as ICU, RTC, IPC, port, and CAN. For user convenience, functionalities are partitioned as shown in the table below."}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Module"}),(0,t.jsx)(n.th,{children:"Location"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"ppslcu"}),(0,t.jsx)(n.td,{children:"MCU0"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"port"}),(0,t.jsx)(n.td,{children:"MCU0"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"uart"}),(0,t.jsx)(n.td,{children:"MCU0/MCU1"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"log"}),(0,t.jsx)(n.td,{children:"MCU0/MCU1"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"shell_init"}),(0,t.jsx)(n.td,{children:"MCU0/MCU1"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"mDma"}),(0,t.jsx)(n.td,{children:"MCU0/MCU1"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"I2c"}),(0,t.jsx)(n.td,{children:"MCU0: i2c6, i2c7 / MCU1: i2c8, i2c9"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"tca9539"}),(0,t.jsx)(n.td,{children:"MCU0"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"ICU"}),(0,t.jsx)(n.td,{children:"MCU0"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"GPT"}),(0,t.jsx)(n.td,{children:"MCU0"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"pmic"}),(0,t.jsx)(n.td,{children:"MCU0"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"fls_init"}),(0,t.jsx)(n.td,{children:"MCU0"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"otafiash"}),(0,t.jsx)(n.td,{children:"MCU0"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"ipc"}),(0,t.jsx)(n.td,{children:"MCU0: instance8 / MCU1: instance0 (other instances are unassigned and available for use)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"crypto"}),(0,t.jsx)(n.td,{children:"MCU0"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"pvt"}),(0,t.jsx)(n.td,{children:"MCU0"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"canGW"}),(0,t.jsx)(n.td,{children:"MCU1"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Rtc"}),(0,t.jsx)(n.td,{children:"MCU0"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"RTC_pps"}),(0,t.jsx)(n.td,{children:"MCU0"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Eth_Init"}),(0,t.jsx)(n.td,{children:"MCU1"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Scmi"}),(0,t.jsx)(n.td,{children:"MCU0"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"mcu-debug-features-in-sysfs",children:"MCU Debug Features in sysfs"}),"\n",(0,t.jsxs)(n.p,{children:["The MCU currently supports several debug features via sysfs, including checking system status (",(0,t.jsx)(n.code,{children:"alive"}),"), system uptime (",(0,t.jsx)(n.code,{children:"taskcounter"}),"), MCU version (",(0,t.jsx)(n.code,{children:"mcu_version"}),"), and SBL version (",(0,t.jsx)(n.code,{children:"sbl_version"}),")."]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:["System status (",(0,t.jsx)(n.code,{children:"alive"}),")"]}),": Indicates whether MCU0/MCU1 is alive or dead. The ",(0,t.jsx)(n.code,{children:"alive"})," status updates every 1 second, so there is a 1-second delay when retrieving the status."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:["System uptime (",(0,t.jsx)(n.code,{children:"taskcounter"}),")"]}),": Shows the duration (in seconds) since the MCU was started."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:["MCU version (",(0,t.jsx)(n.code,{children:"mcu_version"}),")"]}),": Displays MCU version information, including whether it's a debug or release build and the compilation timestamp."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:["SBL version (",(0,t.jsx)(n.code,{children:"sbl_version"}),")"]}),": Shows SBL version information and compilation timestamp. This is only available under ",(0,t.jsx)(n.code,{children:"remoteproc_mcu0"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"MCU serial logs"}),": Allows viewing MCU serial logs. ",(0,t.jsx)(n.code,{children:"remoteproc_mcu0"})," corresponds to MCU0 logs, and ",(0,t.jsx)(n.code,{children:"remoteproc_mcu1"})," corresponds to MCU1 logs."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:["MCU CPU loads (",(0,t.jsx)(n.code,{children:"cpuloads"}),")"]}),": Provides task status, priority, remaining stack, execution count (FreeRTOS tick count), and CPU usage for MCU0/MCU1 tasks, aiding debugging. Retrieving ",(0,t.jsx)(n.code,{children:"cpuloads"})," data involves significant data copying to the sysfs output buffer, resulting in a 1-second delay. This feature is only available when MCU0/MCU1 is powered on."]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsx)(n.p,{children:"The information shown in the images may vary with version updates. The examples provided here are for reference only."})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["System status (",(0,t.jsx)(n.code,{children:"alive"}),"):"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/05_mcu_development/01_S100/basic_information/alive_state.png",alt:""})}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsxs)(n.li,{children:["System uptime (",(0,t.jsx)(n.code,{children:"taskcounter"}),"):"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/05_mcu_development/01_S100/basic_information/taskcounter_state.png",alt:""})}),"\n",(0,t.jsxs)(n.ol,{start:"3",children:["\n",(0,t.jsxs)(n.li,{children:["MCU version (",(0,t.jsx)(n.code,{children:"mcu_version"}),"):"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/05_mcu_development/01_S100/basic_information/mcu_version.png",alt:""})}),"\n",(0,t.jsxs)(n.ol,{start:"4",children:["\n",(0,t.jsxs)(n.li,{children:["SBL version (",(0,t.jsx)(n.code,{children:"sbl_version"}),"):"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/05_mcu_development/01_S100/basic_information/sbl_version.png",alt:""})}),"\n",(0,t.jsxs)(n.ol,{start:"5",children:["\n",(0,t.jsx)(n.li,{children:"MCU serial log retrieval:"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/05_mcu_development/01_S100/basic_information/log.png",alt:""})}),"\n",(0,t.jsxs)(n.ol,{start:"6",children:["\n",(0,t.jsx)(n.li,{children:"Obtain MCU CPU loads, as shown below:"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"http://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/05_mcu_development/01_S100/basic_information/cpuload.jpg",alt:""})}),"\n",(0,t.jsx)(n.h2,{id:"mcu-uart-usage",children:"MCU UART Usage"}),"\n",(0,t.jsx)(n.p,{children:"If the RDK-S100 uses the following connection method, the MCU UART and Acore UART share the same serial port. Check it yourself via: Device Manager \u2192 Ports \u2192 MCU-COM, Baud Rate 921600."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/05_mcu_development/01_S100/basic_information/MCU_COM1.jpg",alt:""})}),"\n",(0,t.jsx)(n.h2,{id:"mcu0-flashing-procedure",children:"MCU0 Flashing Procedure"}),"\n",(0,t.jsx)(n.h3,{id:"manual-flashing",children:"Manual Flashing"}),"\n",(0,t.jsx)(n.h4,{id:"flashing-on-a-non-blank-board",children:"Flashing on a Non-Blank Board"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Power on the board and continuously press Enter on the Acore UART to enter Uboot (keep pressing Enter)."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"fastboot 0\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsxs)(n.li,{children:["Locate the compiled MCU0 image under the ",(0,t.jsx)(n.code,{children:"/output_sysmcu/"})," directory (MCU0 source code is only provided in the commercial version)."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'fastboot oem interface:mtd\n/* Compiled MCU0 image: MCU_S100_SIP_V2.0.img */\nfastboot flash MCU_a "xxx/MCU_S100_SIP_V2.0.img"\nfastboot flash MCU_b "xxx/MCU_S100_SIP_V2.0.img"\n'})}),"\n",(0,t.jsx)(n.h4,{id:"flashing-on-a-blank-board",children:"Flashing on a Blank Board"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"For blank board flashing, please refer to the following tool-based flashing method."})}),"\n",(0,t.jsx)(n.h3,{id:"tool-based-flashing",children:"Tool-Based Flashing"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["When you can successfully enter Uboot, configure as follows:","\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:'Select "Uboot" for "Download Mode";'}),"\n",(0,t.jsx)(n.li,{children:'Select "eMMC" for "Storage Medium";'}),"\n",(0,t.jsx)(n.li,{children:'Select "Secure" for "Type";'}),"\n",(0,t.jsxs)(n.li,{children:['For "Image Directory", choose the folder containing ',(0,t.jsx)(n.code,{children:"img_packages"})," and ",(0,t.jsx)(n.code,{children:"xmodem_tools"}),";"]}),"\n",(0,t.jsx)(n.li,{children:'Select the appropriate "Acore UART Port" based on your actual setup;'}),"\n",(0,t.jsx)(n.li,{children:'Set "Baud Rate" to "921600";'}),"\n",(0,t.jsx)(n.li,{children:'Click the small arrow next to "Other Settings", then click "Partition Selection" and check only "miniboot_flash".'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"http://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/05_mcu_development/01_S100/basic_information/mcu_uboot-en.png",alt:""})}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsx)(n.li,{children:'If you cannot enter Uboot normally, select "USB" for download mode\u2014no need to specify UART port or baud rate. Keep all other settings consistent with the Uboot scenario:'}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"http://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/05_mcu_development/01_S100/basic_information/mcu_usb-en.png",alt:""})}),"\n",(0,t.jsx)(n.h2,{id:"mcu1-undefinedabort-exception-handling-principle",children:"MCU1 Undefined/Abort Exception Handling Principle"}),"\n",(0,t.jsx)(n.p,{children:"Under normal circumstances, when the system enters an Undefined/Abort exception, it eventually enters an infinite loop. The system can only resume normal operation after a full power cycle. Since the RDK-S100 cannot power-cycle MCU1 independently, modifications to the system workflow are required to achieve the desired behavior."}),"\n",(0,t.jsx)(n.p,{children:"Specific principle: When an Undefined/Abort exception occurs, the system also ends up in an infinite loop. By using Acore\u2019s sysfs interface to perform a software power-down of MCU1\u2014i.e., notifying MCU1 to enter WFI mode\u2014MCU1 will perform a software reboot upon the next start, thus achieving the intended recovery."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"http://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/05_mcu_development/01_S100/basic_information/MCU_exception-en.jpg",alt:""})}),"\n",(0,t.jsxs)(n.p,{children:["Taking the Undefined exception as an example: when it occurs, the UART outputs the log \u201cEL1_Undefined_Handler\u201d and eventually enters the ",(0,t.jsx)(n.code,{children:"S100_Exception_Handler"})," function, where it loops indefinitely based on the ",(0,t.jsx)(n.code,{children:"exception_on"})," variable. When Acore stops MCU1 via the remoteproc framework, an inter-processor interrupt modifies the ",(0,t.jsx)(n.code,{children:"exception_on"})," variable, disables the periodic tick interrupt, and puts MCU1 into WFI mode (STANDBY mode):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"void Os_Isr_Cross_Core_Ins0_Isr(void)\n{\n  LogSync(\"mcu1 enter WFI mode!\\r\\n\");\n  power_on = 0;\n  ClearCrossCoreISR0();\n  if (exception_on)\n  {\n    exception_on = 0;\n  }\n}\n\nvoid S100_Exception_Handler(void)\n{\n    LogSync(\"os enter %s!\\r\\n\", __func__);\n    while (exception_on){};\n    LogSync(\"%s enter wfi mode!\\r\\n\", __func__);\n    Os_Disable_Millisecond();\n    Os_Clear_Millisecond();\n    STANDBY();\n};\n\nvoid EL1_Undefined_Handler(void)\n{\n    int32_t func_ptr;\n    *(volatile unsigned int *)(UART_0_BASE) = ('E');\n    *(volatile unsigned int *)(UART_0_BASE) = ('L');\n    *(volatile unsigned int *)(UART_0_BASE) = ('1');\n    *(volatile unsigned int *)(UART_0_BASE) = ('_');\n    *(volatile unsigned int *)(UART_0_BASE) = ('U');\n    *(volatile unsigned int *)(UART_0_BASE) = ('n');\n    *(volatile unsigned int *)(UART_0_BASE) = ('d');\n    *(volatile unsigned int *)(UART_0_BASE) = ('e');\n    *(volatile unsigned int *)(UART_0_BASE) = ('f');\n    *(volatile unsigned int *)(UART_0_BASE) = ('i');\n    *(volatile unsigned int *)(UART_0_BASE) = ('n');\n    *(volatile unsigned int *)(UART_0_BASE) = ('e');\n    *(volatile unsigned int *)(UART_0_BASE) = ('d');\n    *(volatile unsigned int *)(UART_0_BASE) = ('_');\n    *(volatile unsigned int *)(UART_0_BASE) = ('H');\n    *(volatile unsigned int *)(UART_0_BASE) = ('a');\n    *(volatile unsigned int *)(UART_0_BASE) = ('n');\n    *(volatile unsigned int *)(UART_0_BASE) = ('d');\n    *(volatile unsigned int *)(UART_0_BASE) = ('l');\n    *(volatile unsigned int *)(UART_0_BASE) = ('e');\n    *(volatile unsigned int *)(UART_0_BASE) = ('r');\n    *(volatile unsigned int *)(UART_0_BASE) = ('\\r');\n    *(volatile unsigned int *)(UART_0_BASE) = ('\\n');\n    LogSync(\"os enter %s!\\r\\n\", __func__);\n    exception_on = 1;\n\n    func_ptr = &S100_Exception_Handler;\n    __asm volatile (\n        \"mov lr, %[func_ptr]\\t\"\n        :\n        : [func_ptr] \"r\" ((uintptr_t)func_ptr)\n        : \"lr\"\n    );\n\n    __asm volatile (\"ERET\");\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"overview-of-mcu1-main-function",children:"Overview of MCU1 main() Function"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"main()"})," function is critical code executed after system startup. The following code is essential for normal MCU1 boot-up. Do ",(0,t.jsx)(n.strong,{children:"not"})," arbitrarily delete any part of it, as doing so may cause boot failures."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'int main(void)\n{\n    Ipc_MainPowerUp = TRUE;   /* IPC power-on flag; MCU1 is powered on by default since MCU0 is already powered */\n    PpsIcu_Irq_Init();        /* Configure PPS-related interrupts as edge-triggered */\n    Uart_Init();              /* Initialize UART for debugging */\n    Log_Init();               /* Initialize log UART; after this, MCU logs can be retrieved from Acore */\n    #ifdef SHELL_ENABLE\n    Shell_Init();             /* Initialize shell commands; controlled by the SHELL_ENABLE macro */\n    #endif\n    Version_into_AonSram();   /* Store MCU version info in AON SRAM; accessible from Acore afterward */\n    LogSync("MCU FreeRtos Lite Init Success!\\r\\n");\n    FreeRtos_Irq_Init();      /* Initialize FreeRTOS interrupts */\n    FreeRtos_Task_Init();     /* Initialize FreeRTOS tasks and start the scheduler */\n    for(;;){};\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"mcu-log-overview",children:"MCU Log Overview"}),"\n",(0,t.jsx)(n.p,{children:"The MCU provides basic logging functionality, primarily used for debugging and runtime status recording. The current version of the Log module supports formatted string output, enabling developers to quickly locate issues and inspect variable states during debugging."}),"\n",(0,t.jsx)(n.p,{children:"Currently supported format specifiers in MCU logs include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"%s \u2014\u2014 String"}),"\n",(0,t.jsx)(n.li,{children:"%d \u2014\u2014 Signed decimal integer"}),"\n",(0,t.jsx)(n.li,{children:"%u \u2014\u2014 Unsigned decimal integer"}),"\n",(0,t.jsx)(n.li,{children:"%x \u2014\u2014 Lowercase hexadecimal"}),"\n",(0,t.jsx)(n.li,{children:"%X \u2014\u2014 Uppercase hexadecimal"}),"\n",(0,t.jsx)(n.li,{children:"%c \u2014\u2014 Single character"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Other format specifiers are not currently supported. Future versions will gradually expand support for additional data types and formatting options to meet more diverse debugging needs."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>l});var s=i(96540);const t={},o=s.createContext(t);function r(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);