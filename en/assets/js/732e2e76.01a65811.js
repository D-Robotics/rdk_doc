"use strict";(self.webpackChunkrdk_doc=self.webpackChunkrdk_doc||[]).push([[74658],{9009:(t,n,e)=>{e.r(n),e.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>_,frontMatter:()=>a,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"Advanced_development/linux_development/driver_development_x5/driver_spi_dev","title":"SPI Debugging Guide","description":"SPI Hardware Support","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/07_Advanced_development/02_linux_development/driver_development_x5/driver_spi_dev.md","sourceDirName":"07_Advanced_development/02_linux_development/driver_development_x5","slug":"/Advanced_development/linux_development/driver_development_x5/driver_spi_dev","permalink":"/rdk_doc/en/Advanced_development/linux_development/driver_development_x5/driver_spi_dev","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1761287360000,"sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"tutorialSidebar","previous":{"title":"IO-DOMAIN Debugging Guide","permalink":"/rdk_doc/en/Advanced_development/linux_development/driver_development_x5/driver_io_domain_dev"},"next":{"title":"Thermal System","permalink":"/rdk_doc/en/Advanced_development/linux_development/driver_development_x5/driver_thermal_dev"}}');var r=e(74848),s=e(28453);const a={sidebar_position:7},d="SPI Debugging Guide",c={},o=[{value:"SPI Hardware Support",id:"spi-hardware-support",level:2},{value:"Linux SPI Driver Framework Overview",id:"linux-spi-driver-framework-overview",level:2},{value:"Code Path",id:"code-path",level:3},{value:"Controller Hardware Description",id:"controller-hardware-description",level:3},{value:"DTS Configuration Description",id:"dts-configuration-description",level:3},{value:"DTS Configuration for Using DMA",id:"dts-configuration-for-using-dma",level:3},{value:"SPI Function Verification",id:"spi-function-verification",level:2},{value:"Test Environment Preparation",id:"test-environment-preparation",level:3},{value:"SPI Internal Loopback Test",id:"spi-internal-loopback-test",level:3},{value:"SPI External Loopback Test",id:"spi-external-loopback-test",level:3},{value:"Appendix",id:"appendix",level:2}];function l(t){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...t.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"spi-debugging-guide",children:"SPI Debugging Guide"})}),"\n",(0,r.jsx)(n.h2,{id:"spi-hardware-support",children:"SPI Hardware Support"}),"\n",(0,r.jsx)(n.p,{children:"X5 supports a total of 7 SPI controllers, with 6 controllers (spi0-spi5) located in the LSIO subsystem and 1 controller (spi6) located in the DSP subsystem. All SPI controllers support both master and slave modes."}),"\n",(0,r.jsx)(n.h2,{id:"linux-spi-driver-framework-overview",children:"Linux SPI Driver Framework Overview"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"spi driver layer"}),": This layer mainly implements operations for the SPI hardware IP, and also implements the interfaces defined by the SPI framework."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"spi framework layer"}),": This layer can be considered as an adaptation layer for the SPI driver. It defines a set of interfaces that the lower layer (driver) needs to implement, while providing a common interface that abstracts hardware details to the upper layers."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"spi char device layer"}),": Provides nodes for the user space, making it easier for data exchange between user space and kernel space."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"code-path",children:"Code Path"}),"\n",(0,r.jsxs)(n.p,{children:["X5 uses the NewThink (\u65b0\u601d) SSI controller, and the driver code is located in the ",(0,r.jsx)(n.code,{children:"drivers/spi"})," directory. The main files are as follows:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"drivers/spi/spi-dw-core.c\ndrivers/spi/spi-dw-mmio.c\ndrivers/spi/spi-dw-dma.c\n"})}),"\n",(0,r.jsx)(n.h3,{id:"controller-hardware-description",children:"Controller Hardware Description"}),"\n",(0,r.jsx)(n.p,{children:"All SPI controllers on the X5 can operate in Master/Slave modes. The operational limitations for Master and Slave modes are as follows:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"SPI-Master"}),": Maximum frequency of 50MHz"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"SPI-Slave"}),": Maximum frequency of 32MHz"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"All SPI controllers on the X5 can operate in either interrupt or DMA mode. The limitations for interrupt mode are as follows:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"SPI-Slave"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Rx"}),": With the CPU running at a fixed frequency of 1.5GHz, it can achieve up to 32MHz."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Tx"}),": With the CPU running at a fixed frequency of 1.5GHz, it can achieve up to 16MHz."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"SPI-Master"}),": Normal communication is supported."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"dts-configuration-description",children:"DTS Configuration Description"}),"\n",(0,r.jsxs)(n.p,{children:["The device tree definitions for the X5 SPI controllers are located in the ",(0,r.jsx)(n.code,{children:"x5.dtsi"})," file under the ",(0,r.jsx)(n.code,{children:"arch/arm64/boot/dts/hobot/"})," folder in the SDK package kernel directory."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)("font",{color:"red",children:"Note:"})," The nodes in ",(0,r.jsx)(n.code,{children:"x5.dtsi"})," mainly declare SoC-level features and are independent of specific circuit boards. In most cases, these do not need to be modified."]}),"\n",(0,r.jsx)(n.p,{children:"The X5 SPI controller is disabled by default. Please enable the corresponding SPI controller in the appropriate DTS file based on your actual hardware configuration."}),"\n",(0,r.jsx)(n.p,{children:"For example, to enable SPI2:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'&spi2 {\n\tstatus = "okay";\n\tpinctrl-names = "default";\n\tpinctrl-0 = <&pinctrl_spi2>;\n};\n'})}),"\n",(0,r.jsx)(n.h3,{id:"dts-configuration-for-using-dma",children:"DTS Configuration for Using DMA"}),"\n",(0,r.jsx)(n.p,{children:"To use DMA, you need to bind the corresponding DMA handshake in the relevant DTS file. For example, to enable DMA for SPI2:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'&spi2 {\n\tstatus = "okay";\n\tpinctrl-names = "default";\n\tpinctrl-0 = <&pinctrl_spi2>;\n\tdma-names = "tx", "rx";\n\tdmas = <&axi_dmac 25>, <&axi_dmac 24>;\n};\n'})}),"\n",(0,r.jsxs)(n.p,{children:["When binding SPI6, you need to specify ",(0,r.jsx)(n.code,{children:"dsp_axi_dma"}),", as shown below:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'&spi6 {\n\tstatus = "okay";\n\tpinctrl-names = "default";\n\tpinctrl-0 = <&pinctrl_dsp_spi>;\n\tdma-names = "tx", "rx";\n\tdmas = <&dsp_axi_dma 21>, <&dsp_axi_dma 20>;\n};\n'})}),"\n",(0,r.jsx)(n.p,{children:"SPI DMA Handshake List:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"SPI"}),(0,r.jsx)(n.th,{children:"DMA TX"}),(0,r.jsx)(n.th,{children:"DMA RX"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"SPI0"}),(0,r.jsx)(n.td,{children:"20"}),(0,r.jsx)(n.td,{children:"21"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"SPI1"}),(0,r.jsx)(n.td,{children:"22"}),(0,r.jsx)(n.td,{children:"23"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"SPI2"}),(0,r.jsx)(n.td,{children:"24"}),(0,r.jsx)(n.td,{children:"25"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"SPI3"}),(0,r.jsx)(n.td,{children:"26"}),(0,r.jsx)(n.td,{children:"27"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"SPI4"}),(0,r.jsx)(n.td,{children:"28"}),(0,r.jsx)(n.td,{children:"29"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"SPI5"}),(0,r.jsx)(n.td,{children:"30"}),(0,r.jsx)(n.td,{children:"31"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"SPI6"}),(0,r.jsx)(n.td,{children:"21"}),(0,r.jsx)(n.td,{children:"22"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"spi-function-verification",children:"SPI Function Verification"}),"\n",(0,r.jsx)(n.p,{children:"This section introduces the function verification of X5 SPI, including environment setup, test command execution, and test code."}),"\n",(0,r.jsx)(n.h3,{id:"test-environment-preparation",children:"Test Environment Preparation"}),"\n",(0,r.jsxs)(n.p,{children:["Ensure that the kernel's ",(0,r.jsx)(n.code,{children:"CONFIG_SPI_SPIDEV"})," is enabled:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"/* arch/arm64/configs/hobot_x5_soc_defconfig */\n...\nCONFIG_SPI_SPIDEV=m\n...\n"})}),"\n",(0,r.jsx)(n.p,{children:"Ensure that a dummy slave device has been created under the SPI controller node to be tested in the current hardware's DTS."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'&spi2 {\n\tspidev@2 {\n\t\tcompatible = "dr,x5-spidev";\n\t\tspi-max-frequency = <32000000>;\n\t\treg = <0>;\n\t};\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"spi-internal-loopback-test",children:"SPI Internal Loopback Test"}),"\n",(0,r.jsx)(n.p,{children:"The SPI internal loopback test is only supported by SPI Master. The principle is that the SPI hardware's TX FIFO sends data to the RX FIFO, forming a loopback."}),"\n",(0,r.jsx)(n.p,{children:"The test command and expected results are as follows:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"# modprobe spidev\n# ./spidev_tc -D /dev/spidev2.0 -v -s 1000000 -m 3 -l -e 10 -t 1\n   spi mode: 0x20\n   bits per word: 8\n   max speed: 1000000 Hz (1000 KHz)\n   userspace spi read and write test, len=10 times=1\n   test, times=0\n   TX | 67 C6 69 73 51 FF 4A EC 29 CD __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __\n\n   RX | 67 C6 69 73 51 FF 4A EC 29 CD __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __\n"})}),"\n",(0,r.jsx)(n.h3,{id:"spi-external-loopback-test",children:"SPI External Loopback Test"}),"\n",(0,r.jsx)(n.p,{children:"The SPI external loopback test involves setting up one SPI Slave and one SPI Master, with corresponding wires connected for the test."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'&spi2 {\n\tstatus = "okay";\n\tpinctrl-names = "default";\n\tpinctrl-0 = <&pinctrl_spi2>;\n\tspi-slave;\n\n\tslave@0 {\n\t\tcompatible = "dr,x5-spidev";\n\t\tspi-max-frequency = <32000000>;\n\t\treg = <0>;\n\t};\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Modify the SPI4 DTS to support Master functionality as follows:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'&spi4 {\n\tstatus = "okay";\n\tpinctrl-names = "default";\n\tpinctrl-0 = <&pinctrl_spi4>;\n\n\tspidev@0 {\n\t\tcompatible = "dr,x5-spidev";\n\t\tspi-max-frequency = <32000000>;\n\t\treg = <0>;\n\t};\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"The test command and expected results are as follows (using SPI2 as the Slave and SPI4 as the Master):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"# ./spidev_tc -D /dev/spidev2.0 -v -s 1000000 -m 2 -e 10 -t 1&\n\tbits per word: 8\n\tmax speed: 1000000 Hz (1000 KHz)\n\tuserspace spi write test, len=10 times=1\n\ttest, times=0\n\tTX | 67 C6 69 73 51 FF 4A EC 29 CD __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __\n\n# ./spidev_tc -D /dev/spidev4.0 -v -s 1000000 -m 1 -e 10 -t 1&\n\tspi mode: 0x0\n\tbits per word: 8\n\tmax speed: 1000000 Hz (1000 KHz)\n\tuserspace spi read test, len=10 times=1\n\ttest, times=0\n\tRX | 67 C6 69 73 51 FF 4A EC 29 CD __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __\n\n[2]+  Done                       ./spidev_tc -D /dev/spidev2.0 -v -s 1000000 -m 1 -e 10 -t 1\n[1]+  Done                       ./spidev_tc -D /dev/spidev4.0 -v -s 1000000 -m 2 -e 10 -t 1\n"})}),"\n",(0,r.jsx)(n.admonition,{title:"Note",type:"info",children:(0,r.jsxs)(n.p,{children:["When performing the external loopback test, the SPI Slave program should be executed first, followed by the SPI Master program. If the SPI Master program is executed first, followed by the SPI Slave program, data loss may occur due to desynchronization between the Master and Slave. Similarly, the ",(0,r.jsx)(n.code,{children:"-t"})," parameter of ",(0,r.jsx)(n.code,{children:"spidev_tc"})," should only be specified once. If multiple tests are needed, it is recommended to write a script to execute the test program multiple times to ensure synchronization between the Master and Slave."]})}),"\n",(0,r.jsx)(n.h2,{id:"appendix",children:"Appendix"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Appendix 1: Test Case Source Code: spidev_tc.c"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'/*\n * SPI testing utility (using spidev driver)\n *\n * Copyright (c) 2007  MontaVista Software, Inc.\n * Copyright (c) 2007  Anton Vorontsov <avorontsov@ru.mvista.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License.\n *\n * Cross-compile with cross-gcc -I/path/to/cross-kernel/include\n */\n\n#include <stdint.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <time.h>\n#include <sys/ioctl.h>\n#include <linux/ioctl.h>\n#include <sys/stat.h>\n#include <linux/types.h>\n#include <linux/spi/spidev.h>\n\n#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))\n\nstatic void pabort(const char *s)\n{\n\tperror(s);\n\tabort();\n}\n\nstatic const char *device = "/dev/spidev1.1";\nstatic uint32_t mode;\nstatic uint8_t bits = 8;\nstatic char *input_file;\nstatic char *output_file;\nstatic uint32_t speed = 500000;\nstatic uint16_t delay;\nstatic int verbose;\nstatic int transfer_size;\nstatic int iterations;\nstatic int interval = 5; /* interval in seconds for showing transfer rate */\nstatic int rw_mode = 0;\t//1: read, 2: write, 3: write and read\nstatic int rw_len = 4;\nstatic int rw_times = 5;\nstatic int frameid_flag = 0;\nstatic int crc_flag = 0;\nstatic int heart_flag = 0;\nstatic uint32_t tx_frameid = 0, rx_frameid = 0;\nstatic uint32_t heart_interval = 5;\t// 5s\n\nuint8_t default_tx[] = {\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0x40, 0x00, 0x00, 0x00, 0x00, 0x95,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xF0, 0x0D,\n};\n\nuint8_t heart_pack[] = {\n\t0xAA, 0x55, 0xAA, 0x55,\n\t0xAA, 0x55, 0xAA, 0x55,\n\t0xAA, 0x55, 0xAA, 0x55,\n\t0xAA, 0x55, 0xAA, 0x55,\n};\n\nuint8_t default_rx[ARRAY_SIZE(default_tx)] = {0, };\nchar *input_tx;\n\n/** CRC table for the CRC-16. The poly is 0x8005 (x^16 + x^15 + x^2 + 1) */\nstatic uint16_t const crc16_table[256] = {\n\t0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241,\n\t0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,\n\t0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40,\n\t0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841,\n\t0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40,\n\t0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41,\n\t0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641,\n\t0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040,\n\t0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240,\n\t0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441,\n\t0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41,\n\t0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840,\n\t0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41,\n\t0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40,\n\t0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640,\n\t0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041,\n\t0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240,\n\t0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441,\n\t0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41,\n\t0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840,\n\t0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41,\n\t0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40,\n\t0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640,\n\t0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041,\n\t0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241,\n\t0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440,\n\t0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40,\n\t0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841,\n\t0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40,\n\t0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41,\n\t0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641,\n\t0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040\n};\n\nstatic inline uint16_t crc16_byte(uint16_t crc, const uint8_t data)\n{\n\treturn (crc >> 8) ^ crc16_table[(crc ^ data) & 0xff];\n}\n\nstatic uint16_t crc16(uint16_t crc, uint8_t const *buffer, size_t len)\n{\n\twhile (len--)\n\t\tcrc = crc16_byte(crc, *buffer++);\n\treturn crc;\n}\n\nstatic void hex_dump(const void *src, size_t length, size_t line_size,\n\t\t     char *prefix)\n{\n\tint i = 0;\n\tconst unsigned char *address = src;\n\tconst unsigned char *line = address;\n\tunsigned char c;\n\n\tprintf("%s | ", prefix);\n\twhile (length-- > 0) {\n\t\tprintf("%02X ", *address++);\n\t\tif (!(++i % line_size) || (length == 0 && i % line_size)) {\n\t\t\tif (length == 0) {\n\t\t\t\twhile (i++ % line_size)\n\t\t\t\t\tprintf("__ ");\n\t\t\t}\n\t\t\tprintf(" | ");  /* right close */\n\t\t\twhile (line < address) {\n\t\t\t\tc = *line++;\n\t\t\t\tprintf("%c", (c < 33 || c == 255) ? 0x2E : c);\n\t\t\t}\n\t\t\tprintf("\\n");\n\t\t\tif (length > 0)\n\t\t\t\tprintf("%s | ", prefix);\n\t\t}\n\t}\n}\n\nstatic void hex_dump2(const void *src, size_t length, size_t line_size,\n\t\t  char *prefix)\n{\n     int i = 0;\n     const unsigned char *address = src;\n\n     printf("%s | ", prefix);\n     while (length-- > 0) {\n\t     printf("%02X ", *address++);\n\t     if (!(++i % line_size) || (length == 0 && i % line_size)) {\n\t\t     if (length == 0) {\n\t\t\t     while (i++ % line_size)\n\t\t\t\t     printf("__ ");\n\t\t     }\n\t\t     printf("\\n");\n\t\t     if (length > 0)\n\t\t\t     printf("%s | ", prefix);\n\t     }\n     }\n     printf("\\n");\n}\n\n/*\n *  Unescape - process hexadecimal escape character\n *      converts shell input "\\x23" -> 0x23\n */\nstatic int unescape(char *_dst, char *_src, size_t len)\n{\n\tint ret = 0;\n\tint match;\n\tchar *src = _src;\n\tchar *dst = _dst;\n\tunsigned int ch;\n\n\twhile (*src) {\n\t\tif (*src == \'\\\\\' && *(src+1) == \'x\') {\n\t\t\tmatch = sscanf(src + 2, "%2x", &ch);\n\t\t\tif (!match)\n\t\t\t\tpabort("malformed input string");\n\n\t\t\tsrc += 4;\n\t\t\t*dst++ = (unsigned char)ch;\n\t\t} else {\n\t\t\t*dst++ = *src++;\n\t\t}\n\t\tret++;\n\t}\n\treturn ret;\n}\n\nstatic void transfer(int fd, uint8_t const *tx, uint8_t const *rx, size_t len)\n{\n\tint ret;\n\tint out_fd;\n\tstruct spi_ioc_transfer tr = {\n\t\t.tx_buf = (unsigned long)tx,\n\t\t.rx_buf = (unsigned long)rx,\n\t\t.len = len,\n\t\t.delay_usecs = delay,\n\t\t.speed_hz = speed,\n\t\t.bits_per_word = bits,\n\t};\n\n\tstruct timespec currentTime;\n\tstruct timespec currentTime1;\n\n\tif (mode & SPI_TX_QUAD)\n\t\ttr.tx_nbits = 4;\n\telse if (mode & SPI_TX_DUAL)\n\t\ttr.tx_nbits = 2;\n\tif (mode & SPI_RX_QUAD)\n\t\ttr.rx_nbits = 4;\n\telse if (mode & SPI_RX_DUAL)\n\t\ttr.rx_nbits = 2;\n\tif (!(mode & SPI_LOOP)) {\n\t\tif (mode & (SPI_TX_QUAD | SPI_TX_DUAL))\n\t\t\ttr.rx_buf = 0;\n\t\telse if (mode & (SPI_RX_QUAD | SPI_RX_DUAL))\n\t\t\ttr.tx_buf = 0;\n\t}\n\n\tclock_gettime(CLOCK_REALTIME, &currentTime);\n\tlong milliseconds = currentTime.tv_nsec / 1000000;\n\tprintf("before trans time: %ld ms\\n", milliseconds);\n\tret = ioctl(fd, SPI_IOC_MESSAGE(1), &tr);\n\tif (ret < 1)\n\t\tpabort("can\'t send spi message");\n\tclock_gettime(CLOCK_REALTIME, &currentTime1);\n\tlong milliseconds1 = currentTime1.tv_nsec / 1000000;\n\tprintf("after trans time: %ld ms\\n", milliseconds1);\n\n\tprintf("diff: %ld ms\\n", (milliseconds1 - milliseconds));\n\n\tif (verbose)\n\t\thex_dump(tx, len, 32, "TX");\n\n\tif (output_file) {\n\t\tout_fd = open(output_file, O_WRONLY | O_CREAT | O_TRUNC, 0666);\n\t\tif (out_fd < 0)\n\t\t\tpabort("could not open output file");\n\n\t\tret = write(out_fd, rx, len);\n\t\tif (ret != len)\n\t\t\tpabort("not all bytes written to output file");\n\n\t\tclose(out_fd);\n\t}\n\n\tif (verbose)\n\t\thex_dump(rx, len, 32, "RX");\n}\n\nstatic void transfer2(int fd, uint8_t const *tx, uint8_t const *rx, size_t len)\n{\n\tint ret;\n\tint out_fd;\n\tstruct spi_ioc_transfer tr = {\n\t\t.tx_buf = (unsigned long)tx,\n\t\t.rx_buf = (unsigned long)rx,\n\t\t.len = len,\n\t\t.delay_usecs = delay,\n\t\t.speed_hz = speed,\n\t\t.bits_per_word = bits,\n\t};\n\n\tif (mode & SPI_TX_QUAD)\n\t\ttr.tx_nbits = 4;\n\telse if (mode & SPI_TX_DUAL)\n\t\ttr.tx_nbits = 2;\n\tif (mode & SPI_RX_QUAD)\n\t\ttr.rx_nbits = 4;\n\telse if (mode & SPI_RX_DUAL)\n\t\ttr.rx_nbits = 2;\n\tif (!(mode & SPI_LOOP)) {\n\t\tif (mode & (SPI_TX_QUAD | SPI_TX_DUAL))\n\t\t\ttr.rx_buf = 0;\n\t\telse if (mode & (SPI_RX_QUAD | SPI_RX_DUAL))\n\t\t\ttr.tx_buf = 0;\n\t}\n\n\tif (verbose && rw_mode >> 1)\n\t\thex_dump2(tx, len, 32, "TX");\n\n\tret = ioctl(fd, SPI_IOC_MESSAGE(1), &tr);\n\tif (ret < 1) {\n\t\t//pabort("can\'t send spi message");\n\t\tprintf("can\'t send spi message");\n\t} else {\n\t\tif (output_file) {\n\t\t\tout_fd = open(output_file, O_WRONLY | O_CREAT | O_TRUNC, 0666);\n\t\t\tif (out_fd < 0)\n\t\t\t\tpabort("could not open output file");\n\n\t\t\tret = write(out_fd, rx, len);\n\t\t\tif (ret != len)\n\t\t\t\tpabort("not all bytes written to output file");\n\n\t\t\tclose(out_fd);\n\t\t}\n\n\t\tif (verbose && rw_mode&0x01)\n\t\t\thex_dump2(rx, len, 32, "RX");\n\t}\n\tif (strcmp(tx, rx) != 0) {\n\t\tprintf("SPI transfer failed\\n");\n\t\texit(-1);\n\t}\n\n}\n\nstatic void transfer3(int fd, uint8_t const *tx, uint8_t const *rx, size_t len)\n{\n\tint ret;\n\tuint8_t const *p = rx;\n\tstruct spi_ioc_transfer tr = {\n\t\t.tx_buf = (unsigned long)tx,\n\t\t.rx_buf = (unsigned long)rx,\n\t\t.len = len,\n\t\t.delay_usecs = delay,\n\t\t.speed_hz = speed,\n\t\t.bits_per_word = bits,\n\t};\n\n\tif (mode & SPI_TX_QUAD)\n\t\ttr.tx_nbits = 4;\n\telse if (mode & SPI_TX_DUAL)\n\t\ttr.tx_nbits = 2;\n\tif (mode & SPI_RX_QUAD)\n\t\ttr.rx_nbits = 4;\n\telse if (mode & SPI_RX_DUAL)\n\t\ttr.rx_nbits = 2;\n\tif (!(mode & SPI_LOOP)) {\n\t\tif (mode & (SPI_TX_QUAD | SPI_TX_DUAL))\n\t\t\ttr.rx_buf = 0;\n\t\telse if (mode & (SPI_RX_QUAD | SPI_RX_DUAL))\n\t\t\ttr.tx_buf = 0;\n\t}\n\n\thex_dump2(tx, len, 32, "TX");\n\n\tret = ioctl(fd, SPI_IOC_MESSAGE(1), &tr);\n\tif (ret < 1) {\n\t\tprintf("can\'t send spi message");\n\t} else {\n\t\thex_dump2(rx, len, 32, "RX");\n\n\t\tif (frameid_flag) {\n\t\t\tuint32_t *pframeid = (uint32_t *)p;\n\t\t\trx_frameid = *pframeid;\n\t\t\tp += sizeof(uint32_t);\n\n\t\t\tprintf("device = %s, crc_val = %d", device, rx_frameid);\n\t\t}\n\n\t\tif (crc_flag) {\n\t\t\tuint16_t crc_val_check = crc16(0, p, sizeof(heart_pack));\n\t\t\tp += sizeof(heart_pack);\n\t\t\tuint16_t *pcrc_val = (uint16_t *)p;\n\n\t\t\tprintf("device = %s, crc_val = %d, crc_val_check = %d", device, *pcrc_val, crc_val_check);\n\t\t}\n\t}\n}\n\nstatic void print_usage(const char *prog)\n{\n\tprintf("Usage: %s [-DsbdiolHOLC3vpNR24SImetfch1]\\n", prog);\n\tputs("  -D --device   device to use (default /dev/spidev1.1)\\n"\n\t     "  -s --speed    max speed (Hz)\\n"\n\t     "  -d --delay    delay (usec)\\n"\n\t     "  -b --bpw      bits per word\\n"\n\t     "  -i --input    input data from a file (e.g. \\"test.bin\\")\\n"\n\t     "  -o --output   output data to a file (e.g. \\"results.bin\\")\\n"\n\t     "  -l --loop     loopback\\n"\n\t     "  -H --cpha     clock phase\\n"\n\t     "  -O --cpol     clock polarity\\n"\n\t     "  -L --lsb      least significant bit first\\n"\n\t     "  -C --cs-high  chip select active high\\n"\n\t     "  -3 --3wire    SI/SO signals shared\\n"\n\t     "  -v --verbose  Verbose (show tx buffer)\\n"\n\t     "  -p            Send data (e.g. \\"1234\\\\xde\\\\xad\\")\\n"\n\t     "  -N --no-cs    no chip select\\n"\n\t     "  -R --ready    slave pulls low to pause\\n"\n\t     "  -2 --dual     dual transfer\\n"\n\t     "  -4 --quad     quad transfer\\n"\n\t     "  -S --size     transfer size\\n"\n\t     "  -I --iter     iterations\\n"\n\t     "  -m --rw-mode  1 read, 2 write, 3 write and read\\n"\n\t     "  -e --rw-len   read or write len\\n"\n\t     "  -t --rw-times read or write times\\n"\n\t\t "  -f --frame-id support frame id\\n"\n\t\t "  -c --crc support crc\\n"\n\t\t "  -h --heart pack for test\\n"\n\t\t "  -1 --heart pack interval(default: 5s)\\n");\n\texit(1);\n}\n\nstatic void parse_opts(int argc, char *argv[])\n{\n\twhile (1) {\n\t\tstatic const struct option lopts[] = {\n\t\t\t{ "device",  1, 0, \'D\' },\n\t\t\t{ "speed",   1, 0, \'s\' },\n\t\t\t{ "delay",   1, 0, \'d\' },\n\t\t\t{ "bpw",     1, 0, \'b\' },\n\t\t\t{ "input",   1, 0, \'i\' },\n\t\t\t{ "output",  1, 0, \'o\' },\n\t\t\t{ "loop",    0, 0, \'l\' },\n\t\t\t{ "cpha",    0, 0, \'H\' },\n\t\t\t{ "cpol",    0, 0, \'O\' },\n\t\t\t{ "lsb",     0, 0, \'L\' },\n\t\t\t{ "cs-high", 0, 0, \'C\' },\n\t\t\t{ "3wire",   0, 0, \'3\' },\n\t\t\t{ "no-cs",   0, 0, \'N\' },\n\t\t\t{ "ready",   0, 0, \'R\' },\n\t\t\t{ "dual",    0, 0, \'2\' },\n\t\t\t{ "verbose", 0, 0, \'v\' },\n\t\t\t{ "quad",    0, 0, \'4\' },\n\t\t\t{ "size",    1, 0, \'S\' },\n\t\t\t{ "iter",    1, 0, \'I\' },\n\t\t\t{ "rw-mode",    1, 0, \'m\' },\n\t\t\t{ "rw-len",    1, 0, \'e\' },\n\t\t\t{ "rw-times",    1, 0, \'t\' },\n\t\t\t{ "frame-id",\t0, 0, \'f\' },\n\t\t\t{ "crc", 0, 0, \'c\' },\n\t\t\t{ "heart", 0, 0, \'h\' },\n\t\t\t{ "interval", 0, 0, \'1\' },\n\t\t\t{ NULL, 0, 0, 0 },\n\t\t};\n\t\tint c;\n\n\t\tc = getopt_long(argc, argv, "D:s:d:b:i:o:lHOLC3NR24p:vS:I:m:e:t:fch1:",\n\t\t\t\tlopts, NULL);\n\t\t//printf("optind: %d\\n", optind);\n\t\t//printf("optarg: %s\\n", optarg);\n\t\t//printf("option: %c\\n", c);\n\n\t\tif (c == -1)\n\t\t\tbreak;\n\n\t\tswitch (c) {\n\t\tcase \'D\':\n\t\t\tdevice = optarg;\n\t\t\tbreak;\n\t\tcase \'s\':\n\t\t\tspeed = atoi(optarg);\n\t\t\tbreak;\n\t\tcase \'d\':\n\t\t\tdelay = atoi(optarg);\n\t\t\tbreak;\n\t\tcase \'b\':\n\t\t\tbits = atoi(optarg);\n\t\t\tbreak;\n\t\tcase \'i\':\n\t\t\tinput_file = optarg;\n\t\t\tbreak;\n\t\tcase \'o\':\n\t\t\toutput_file = optarg;\n\t\t\tbreak;\n\t\tcase \'l\':\n\t\t\tmode |= SPI_LOOP;\n\t\t\tbreak;\n\t\tcase \'H\':\n\t\t\tmode |= SPI_CPHA;\n\t\t\tbreak;\n\t\tcase \'O\':\n\t\t\tmode |= SPI_CPOL;\n\t\t\tbreak;\n\t\tcase \'L\':\n\t\t\tmode |= SPI_LSB_FIRST;\n\t\t\tbreak;\n\t\tcase \'C\':\n\t\t\tmode |= SPI_CS_HIGH;\n\t\t\tbreak;\n\t\tcase \'3\':\n\t\t\tmode |= SPI_3WIRE;\n\t\t\tbreak;\n\t\tcase \'N\':\n\t\t\tmode |= SPI_NO_CS;\n\t\t\tbreak;\n\t\tcase \'v\':\n\t\t\tverbose = 1;\n\t\t\tbreak;\n\t\tcase \'R\':\n\t\t\tmode |= SPI_READY;\n\t\t\tbreak;\n\t\tcase \'p\':\n\t\t\tinput_tx = optarg;\n\t\t\tbreak;\n\t\tcase \'2\':\n\t\t\tmode |= SPI_TX_DUAL;\n\t\t\tbreak;\n\t\tcase \'4\':\n\t\t\tmode |= SPI_TX_QUAD;\n\t\t\tbreak;\n\t\tcase \'S\':\n\t\t\ttransfer_size = atoi(optarg);\n\t\t\tbreak;\n\t\tcase \'I\':\n\t\t\titerations = atoi(optarg);\n\t\t\tbreak;\n\t\tcase \'m\':\n\t\t\trw_mode = atoi(optarg);\n\t\t\tbreak;\n\t\tcase \'e\':\n\t\t\trw_len = atoi(optarg);\n\t\t\tbreak;\n\t\tcase \'t\':\n\t\t\trw_times = atoi(optarg);\n\t\t\tbreak;\n\t\tcase \'f\':\n\t\t\tframeid_flag = 1;\n\t\t\tbreak;\n\t\tcase \'c\':\n\t\t\tcrc_flag = 1;\n\t\t\tbreak;\n\t\tcase \'h\':\n\t\t\theart_flag = 1;\n\t\t\tbreak;\n\t\tcase \'1\':\n\t\t\theart_interval = atoi(optarg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprint_usage(argv[0]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (mode & SPI_LOOP) {\n\t\tif (mode & SPI_TX_DUAL)\n\t\t\tmode |= SPI_RX_DUAL;\n\t\tif (mode & SPI_TX_QUAD)\n\t\t\tmode |= SPI_RX_QUAD;\n\t}\n}\n\nstatic void transfer_escaped_string(int fd, char *str)\n{\n\tsize_t size = strlen(str);\n\tuint8_t *tx;\n\tuint8_t *rx;\n\n\ttx = malloc(size);\n\tif (!tx)\n\t\tpabort("can\'t allocate tx buffer");\n\n\trx = malloc(size);\n\tif (!rx)\n\t\tpabort("can\'t allocate rx buffer");\n\n\tsize = unescape((char *)tx, str, size);\n\ttransfer(fd, tx, rx, size);\n\tfree(rx);\n\tfree(tx);\n}\n\nstatic void transfer_file(int fd, char *filename)\n{\n\tssize_t bytes;\n\tstruct stat sb;\n\tint tx_fd;\n\tuint8_t *tx;\n\tuint8_t *rx;\n\n\tif (stat(filename, &sb) == -1)\n\t\tpabort("can\'t stat input file");\n\n\ttx_fd = open(filename, O_RDONLY);\n\tif (tx_fd < 0)\n\t\tpabort("can\'t open input file");\n\n\ttx = malloc(sb.st_size);\n\tif (!tx)\n\t\tpabort("can\'t allocate tx buffer");\n\n\trx = malloc(sb.st_size);\n\tif (!rx)\n\t\tpabort("can\'t allocate rx buffer");\n\n\tbytes = read(tx_fd, tx, sb.st_size);\n\tif (bytes != sb.st_size)\n\t\tpabort("failed to read input file");\n\n\ttransfer(fd, tx, rx, sb.st_size);\n\tfree(rx);\n\tfree(tx);\n\tclose(tx_fd);\n}\n\nstatic uint64_t _read_count;\nstatic uint64_t _write_count;\n\nstatic void show_transfer_rate(void)\n{\n\tstatic uint64_t prev_read_count, prev_write_count;\n\tdouble rx_rate, tx_rate;\n\n\trx_rate = ((_read_count - prev_read_count) * 8) / (interval*1000.0);\n\ttx_rate = ((_write_count - prev_write_count) * 8) / (interval*1000.0);\n\n\tprintf("rate: tx %.1fkbps, rx %.1fkbps\\n", rx_rate, tx_rate);\n\n\tprev_read_count = _read_count;\n\tprev_write_count = _write_count;\n}\n\nstatic void transfer_buf(int fd, int len)\n{\n\tuint8_t *tx;\n\tuint8_t *rx;\n\tint i;\n\n\ttx = malloc(len);\n\tif (!tx)\n\t\tpabort("can\'t allocate tx buffer");\n\tfor (i = 0; i < len; i++)\n\t\ttx[i] = random();\n\n\trx = malloc(len);\n\tif (!rx)\n\t\tpabort("can\'t allocate rx buffer");\n\n\ttransfer(fd, tx, rx, len);\n\n\t_write_count += len;\n\t_read_count += len;\n\n\tif (mode & SPI_LOOP) {\n\t\tif (memcmp(tx, rx, len)) {\n\t\t\tfprintf(stderr, "transfer error !\\n");\n\t\t\thex_dump(tx, len, 32, "TX");\n\t\t\thex_dump(rx, len, 32, "RX");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tfree(rx);\n\tfree(tx);\n}\n\nstatic void transfer_read_write(int fd)\n{\n\tuint8_t *tx;\n\tuint8_t *rx;\n\tint i, j;\n\tint len, times;\n\tchar str[64] = {0};\n\n\tlen = rw_len > 0 ? rw_len : 4;\n\ttimes = rw_times > 0 ? rw_times : 4;\n\tif (rw_mode == 2)\n\t\tsprintf(str, "write");\n\telse if (rw_mode == 3)\n\t\tsprintf(str, "read and write");\n\telse {\n\t\trw_mode = 1;\n\t\tsprintf(str, "read");\n\t}\n\n\tprintf("userspace spi %s test, len=%d times=%d\\n", str, len, times);\n\n\ttx = malloc(len + 4);\n\tif (!tx)\n\t\tpabort("can\'t allocate tx buffer");\n\trx = malloc(len + 4);\n\tif (!rx)\n\t\tpabort("can\'t allocate rx buffer");\n\n\tfor (j = 0; j < rw_times; j++) {\n\t\tmemset(tx, 0, len);\n\t\tmemset(rx, 0, len);\n\n\t\tif (rw_mode >> 1) {\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t\ttx[i] = random();\n\t\t} else {\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t\ttx[i] = i;\n\t\t}\n\t\tprintf("test, times=%d\\n", j);\n\t\ttransfer2(fd, tx, rx, len);\n\t\t//sleep(2);\n\t}\n}\n\nstatic void transfer_heart_pack(int fd)\n{\n\tuint8_t *p;\n\tuint8_t *tx;\n\tuint8_t *rx;\n\tint len;\n\n\tlen = sizeof(heart_pack);\n\tif (frameid_flag)\n\t\tlen += sizeof(uint32_t);\n\tif (crc_flag)\n\t\tlen += sizeof(uint16_t);\n\n\ttx = malloc(len);\n\tif (!tx)\n\t\tpabort("can\'t allocate tx buffer");\n\trx = malloc(len);\n\tif (!rx)\n\t\tpabort("can\'t allocate rx buffer");\n\n\twhile (1) {\n\t\tmemset(tx, 0 ,len);\n\t\tmemset(rx, 0, len);\n\n\t\tp = tx;\n\t\tif (frameid_flag) {\n\t\t\tuint32_t *pframeid = (uint32_t *)p;\n\t\t\t*pframeid = tx_frameid;\n\t\t\ttx_frameid++;\n\t\t\tp += sizeof(uint32_t);\n\n\t\t\tprintf("device = %s, crc_val = %d", device, *pframeid);\n\t\t}\n\n\t\tmemcpy(p, heart_pack, sizeof(heart_pack));\n\t\tp += sizeof(heart_pack);\n\n\t\tif (crc_flag) {\n\t\t\tuint16_t crc_val = crc16(0, heart_pack, sizeof(heart_pack));\n\t\t\tuint16_t *pcrc_val = (uint16_t *)p;\n\t\t\t*pcrc_val = crc_val;\n\n\t\t\tprintf("device = %s, crc_val = %d", device, crc_val);\n\t\t}\n\n\t\ttransfer3(fd, tx, rx, len);\n\n\t\tsleep(heart_interval);\n\t}\n}\n\nint main(int argc, char *argv[])\n{\n\tint ret = 0;\n\tint fd;\n\n\tparse_opts(argc, argv);\n\n\tfd = open(device, O_RDWR);\n\tif (fd < 0)\n\t\tpabort("can\'t open device");\n\n\t/*\n\t * spi mode\n\t */\n\tret = ioctl(fd, SPI_IOC_WR_MODE32, &mode);\n\tif (ret == -1)\n\t\tpabort("can\'t set spi mode");\n\n\tret = ioctl(fd, SPI_IOC_RD_MODE32, &mode);\n\tif (ret == -1)\n\t\tpabort("can\'t get spi mode");\n\n\t/*\n\t * bits per word\n\t */\n\tret = ioctl(fd, SPI_IOC_WR_BITS_PER_WORD, &bits);\n\tif (ret == -1)\n\t\tpabort("can\'t set bits per word");\n\n\tret = ioctl(fd, SPI_IOC_RD_BITS_PER_WORD, &bits);\n\tif (ret == -1)\n\t\tpabort("can\'t get bits per word");\n\n\t/*\n\t * max speed hz\n\t */\n\tret = ioctl(fd, SPI_IOC_WR_MAX_SPEED_HZ, &speed);\n\tif (ret == -1)\n\t\tpabort("can\'t set max speed hz");\n\n\tret = ioctl(fd, SPI_IOC_RD_MAX_SPEED_HZ, &speed);\n\tif (ret == -1)\n\t\tpabort("can\'t get max speed hz");\n\n\tprintf("spi mode: 0x%x\\n", mode);\n\tprintf("bits per word: %d\\n", bits);\n\tprintf("max speed: %d Hz (%d KHz)\\n", speed, speed/1000);\n\n\tif (input_tx && input_file)\n\t\tpabort("only one of -p and --input may be selected");\n\n\tif (input_tx)\n\t\ttransfer_escaped_string(fd, input_tx);\n\telse if (input_file)\n\t\ttransfer_file(fd, input_file);\n\telse if (transfer_size) {\n\t\tstruct timespec last_stat;\n\n\t\tclock_gettime(CLOCK_MONOTONIC, &last_stat);\n\n\t\twhile (iterations-- > 0) {\n\t\t\tstruct timespec current;\n\n\t\t\ttransfer_buf(fd, transfer_size);\n\n\t\t\tclock_gettime(CLOCK_MONOTONIC, &current);\n\t\t\tif (current.tv_sec - last_stat.tv_sec > interval) {\n\t\t\t\tshow_transfer_rate();\n\t\t\t\tlast_stat = current;\n\t\t\t}\n\t\t}\n\t\tprintf("total: tx %.1fKB, rx %.1fKB\\n",\n\t\t       _write_count/1024.0, _read_count/1024.0);\n\t} else if (rw_mode) {\n\t\ttransfer_read_write(fd);\n\t} else if (heart_flag) {\n\t\ttransfer_heart_pack(fd);\n\t} else\n\t\ttransfer(fd, default_tx, default_rx, sizeof(default_tx));\n\n\tclose(fd);\n\n\treturn ret;\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"\u9644\u5f552 \u6d4b\u8bd5\u7528\u4f8b\u6e90\u7801\uff1aMakefile"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"OUT_DIR = $(shell pwd)/_build/\n\n.PHONY: build install clean\n\nBIN_NAME = spidev_tc\nSRCS = $(wildcard ./*.c)\nOBJS = $(addprefix ${OUT_DIR}/, $(patsubst %.c, %.o, ${SRCS}))\n\nBIN_TEST1 = ${OUT_DIR}/${BIN_NAME}\nOBJECT = ${BIN_TEST1}\n\nbuild: ${OBJECT}\n\nQ:=\n\n$(OBJECT): $(OBJS)\n\t$(Q)mkdir -p $(abspath $(dir $@))\n\t$(Q)echo CC $@\n\t$(Q)${CC} ${CFLAGS} ${INCS} $^ ${LDFLAGS} $(LIBS) -o $@\n\n${OUT_DIR}/%.o: %.c\n\t$(Q)mkdir -p $(abspath $(dir $@))\n\t$(Q)echo CC $@\n\t$(Q)${CC} $(INCS) -c $< -o $@\n\nclean :\n\trm -rf $(OBJS) $(OBJECT)\n"})})]})}function _(t={}){const{wrapper:n}={...(0,s.R)(),...t.components};return n?(0,r.jsx)(n,{...t,children:(0,r.jsx)(l,{...t})}):l(t)}},28453:(t,n,e)=>{e.d(n,{R:()=>a,x:()=>d});var i=e(96540);const r={},s=i.createContext(r);function a(t){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof t?t(n):{...n,...t}},[n,t])}function d(t){let n;return n=t.disableParentContext?"function"==typeof t.components?t.components(r):t.components||r:a(t.components),i.createElement(s.Provider,{value:n},t.children)}}}]);