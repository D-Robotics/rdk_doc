"use strict";(self.webpackChunkrdk_doc=self.webpackChunkrdk_doc||[]).push([[25777],{28453:(e,n,X)=>{X.d(n,{R:()=>t,x:()=>d});var i=X(96540);const s={},r=i.createContext(s);function t(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),i.createElement(r.Provider,{value:n},e.children)}},37356:(e,n,X)=>{X.r(n),X.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>o,frontMatter:()=>t,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"Advanced_development/linux_development/driver_development_s100/driver_i2c_dev","title":"I2C Debugging Guide","description":"Preface","source":"@site/i18n/en/docusaurus-plugin-content-docs-docs_s/current/07_Advanced_development/02_linux_development/04_driver_development_s100/03_driver_i2c_dev.md","sourceDirName":"07_Advanced_development/02_linux_development/04_driver_development_s100","slug":"/Advanced_development/linux_development/driver_development_s100/driver_i2c_dev","permalink":"/rdk_doc/en/rdk_s/Advanced_development/linux_development/driver_development_s100/driver_i2c_dev","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1764174115000,"sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"UART Driver Debugging Guide","permalink":"/rdk_doc/en/rdk_s/Advanced_development/linux_development/driver_development_s100/driver_uart_dev"},"next":{"title":"GPIO Usage","permalink":"/rdk_doc/en/rdk_s/Advanced_development/linux_development/driver_development_s100/driver_gpio_dev"}}');var s=X(74848),r=X(28453);const t={sidebar_position:3},d="I2C Debugging Guide",c={},a=[{value:"Preface",id:"preface",level:2},{value:"Driver Code",id:"driver-code",level:2},{value:"Kernel Configuration Location",id:"kernel-configuration-location",level:3},{value:"Kernel DTS Node Configuration",id:"kernel-dts-node-configuration",level:3},{value:"I2C Usage",id:"i2c-usage",level:2},{value:"Kernel Space",id:"kernel-space",level:3},{value:"I2C Speed Configuration",id:"i2c-speed-configuration",level:4},{value:"User Space",id:"user-space",level:3},{value:"Debug Interfaces",id:"debug-interfaces",level:4},{value:"i2c-tools",id:"i2c-tools",level:3},{value:"I2C Testing",id:"i2c-testing",level:2},{value:"Checking i2cdev nodes",id:"checking-i2cdev-nodes",level:3},{value:"Test procedure",id:"test-procedure",level:3}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"i2c-debugging-guide",children:"I2C Debugging Guide"})}),"\n",(0,s.jsx)(n.h2,{id:"preface",children:"Preface"}),"\n",(0,s.jsx)(n.p,{children:"The S100 chip provides a standard I2C bus. The I2C bus controller transfers information between devices connected to the bus via a Serial Data Line (SDA) and a Serial Clock Line (SCL). Each device has a unique address (whether it's a microcontroller\u2014MCU, LCD controller, memory, or keyboard interface) and can act as both a transmitter and a receiver (determined by the device's functionality)."}),"\n",(0,s.jsx)(n.p,{children:"The I2C controller supports the following features:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Supports four speed modes:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Standard mode (0\u2013100 Kb/s)"}),"\n",(0,s.jsx)(n.li,{children:"Fast mode (100\u2013400 Kb/s)"}),"\n",(0,s.jsx)(n.li,{children:"Fast mode plus (400\u20131000 Kb/s)"}),"\n",(0,s.jsx)(n.li,{children:"High-speed mode (1000 Kb/s\u20133.4 Mb/s)"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Supports master/slave mode configuration"}),"\n",(0,s.jsx)(n.li,{children:"Supports both 7-bit and 10-bit addressing modes"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"driver-code",children:"Driver Code"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"drivers/i2c/i2c-dev.c # I2C character device interface code\ndrivers/i2c/i2c-core-base.c  # I2C framework code\ndrivers/i2c/busses/i2c-designware-platdrv.c   # I2C driver source file\n"})}),"\n",(0,s.jsx)(n.h3,{id:"kernel-configuration-location",children:"Kernel Configuration Location"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"/* hobot-drivers/configs/drobot_s100_defconfig */\nCONFIG_I2C_CHARDEV=y \t\t\t# I2C driver userspace configuration macro\nCONFIG_I2C_DESIGNWARE_PLATFORM=y \t# DesignWare I2C driver configuration macro\n"})}),"\n",(0,s.jsx)(n.h3,{id:"kernel-dts-node-configuration",children:"Kernel DTS Node Configuration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-{.text}",children:'/*kernel/arch/arm64/boot/dts/hobot/drobot-s100-soc.dtsi*/\ni2c0: i2c@39420000 {\n        power-domains = <&scmi_smc_pd PD_IDX_LSPERI_TOP>;\n        #address-cells = <1>;\n        #size-cells = <0>;\n        compatible = "snps,designware-i2c";\n        reg = <0x0 0x39420000 0x0 0x10000>;\n        clocks = <&scmi_smc_clk CLK_IDX_TOP_PERI_I2C0>;\n        clock-names = "apb_pclk";\n        interrupts = <GIC_SPI PERISYS_I2C0_INTR PERISYS_I2C0_INTR_TRIG_TYPE>;\n        clock-frequency = <400000>;\n        i2c-sda-hold-time-ns = <50>;\n        pinctrl-names = "default", "gpio";\n        pinctrl-0 = <&cam_i2c0>;\n        pinctrl-1 = <&cam_i2c0_gpio>;\n        scl-gpios = <&cam_port0 8 GPIO_ACTIVE_HIGH>;\n        sda-gpios = <&cam_port0 9 GPIO_ACTIVE_HIGH>;\n        status = "okay";\n};\n'})}),"\n",(0,s.jsx)(n.h2,{id:"i2c-usage",children:"I2C Usage"}),"\n",(0,s.jsxs)(n.p,{children:["Detailed instructions on I2C usage can be found in ",(0,s.jsx)(n.code,{children:"kernel/Documentation/i2c/"}),". This document mainly highlights S100-specific aspects of the I2C driver interface."]}),"\n",(0,s.jsx)(n.h3,{id:"kernel-space",children:"Kernel Space"}),"\n",(0,s.jsx)(n.p,{children:"The S100 I2C driver provides an interface in kernel space to configure the I2C transfer frequency. Usage is as follows:"}),"\n",(0,s.jsx)(n.h4,{id:"i2c-speed-configuration",children:"I2C Speed Configuration"}),"\n",(0,s.jsxs)(n.p,{children:["The default I2C speed is 400K. The driver supports four speeds: 100K, 400K, 1M, and 3.4M. The speed can be modified by adjusting the ",(0,s.jsx)(n.code,{children:"clock-frequency"})," property of the corresponding I2C node in the device tree (DTS). The relevant code for actual speed selection is as follows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-{.text}",children:'kernel/drivers/i2c/busses/i2c-designware-common.c\nSupported I2C speeds are defined as:\nstatic const u32 supported_speeds[] = {\n\tI2C_MAX_HIGH_SPEED_MODE_FREQ,\n\tI2C_MAX_FAST_MODE_PLUS_FREQ,\n\tI2C_MAX_FAST_MODE_FREQ,\n\tI2C_MAX_STANDARD_MODE_FREQ,\n};\n...\nkernel/drivers/i2c/busses/i2c-designware-pcidrv.c\nThe function interface to retrieve clock-frequency from the device tree is:\ni2c_parse_fw_timings(&pdev->dev, t, false);\nExpanded as:\nvoid i2c_parse_fw_timings(struct device *dev, struct i2c_timings *t, bool use_defaults)\n{\n\tbool u = use_defaults;\n\tu32 d;\n\n\ti2c_parse_timing(dev, "clock-frequency", &t->bus_freq_hz,\n\t\t\t I2C_MAX_STANDARD_MODE_FREQ, u);\n\n\td = t->bus_freq_hz <= I2C_MAX_STANDARD_MODE_FREQ ? 1000 :\n\t    t->bus_freq_hz <= I2C_MAX_FAST_MODE_FREQ ? 300 : 120;\n\ti2c_parse_timing(dev, "i2c-scl-rising-time-ns", &t->scl_rise_ns, d, u);\n\n\td = t->bus_freq_hz <= I2C_MAX_FAST_MODE_FREQ ? 300 : 120;\n\ti2c_parse_timing(dev, "i2c-scl-falling-time-ns", &t->scl_fall_ns, d, u);\n\n\ti2c_parse_timing(dev, "i2c-scl-internal-delay-ns",\n\t\t\t &t->scl_int_delay_ns, 0, u);\n\ti2c_parse_timing(dev, "i2c-sda-falling-time-ns", &t->sda_fall_ns,\n\t\t\t t->scl_fall_ns, u);\n\ti2c_parse_timing(dev, "i2c-sda-hold-time-ns", &t->sda_hold_ns, 0, u);\n\ti2c_parse_timing(dev, "i2c-digital-filter-width-ns",\n\t\t\t &t->digital_filter_width_ns, 0, u);\n\ti2c_parse_timing(dev, "i2c-analog-filter-cutoff-frequency",\n\t\t\t &t->analog_filter_cutoff_freq_hz, 0, u);\n}\nThe function interface to validate I2C speed is:\ni2c_dw_validate_speed(dev);\nExpanded as:\nint i2c_dw_validate_speed(struct dw_i2c_dev *dev)\n{\n\tstruct i2c_timings *t = &dev->timings;\n\tunsigned int i;\n\n\t/*\n\t * Only standard mode at 100kHz, fast mode at 400kHz,\n\t * fast mode plus at 1MHz and high speed mode at 3.4MHz are supported.\n\t */\n\tfor (i = 0; i < ARRAY_SIZE(supported_speeds); i++) {\n\t\tif (t->bus_freq_hz == supported_speeds[i])\n\t\t\treturn 0;\n\t}\n\n\tdev_err(dev->dev,\n\t\t"%d Hz is unsupported, only 100kHz, 400kHz, 1MHz and 3.4MHz are supported\\n",\n\t\tt->bus_freq_hz);\n\n\treturn -EINVAL;\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"user-space",children:"User Space"}),"\n",(0,s.jsxs)(n.p,{children:["Typically, I2C devices are controlled by kernel drivers, but all devices on the bus can also be accessed from userspace via the ",(0,s.jsx)(n.code,{children:"/dev/i2c-%d"})," interface. Detailed documentation is available in ",(0,s.jsx)(n.code,{children:"Documentation/i2c/dev-interface.rst"})," under the kernel source tree."]}),"\n",(0,s.jsx)(n.h4,{id:"debug-interfaces",children:"Debug Interfaces"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Register Information Retrieval"})}),"\n",(0,s.jsx)(n.p,{children:"To view I2C register information (using i2c-0 as an example):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-{.text}",children:"root@ubuntu:/# cat /sys/kernel/debug/dw_i2c0/registers\n39420000.i2c registers:\n=================================\nCON:            0x00000065\nSAR:            0x00000055\nDATA_CMD:       0x00000800\nINTR_STAT:      0x00000000\nINTR_MASK:      0x00000000\nRX_TL:          0x00000000\nTX_TL:          0x00000002\nSTATUS:         0x00000006\nTXFLR:          0x00000000\nRXFLR:          0x00000000\nSDA_HOLD:       0x0001000c\nTX_ABRT:        0x00000000\nEN_STATUS:      0x00000000\nCLR_RESTA:      0x00000000\nPARAM:          0x000303ee\nVERSION:        0x3230322a\nTYPE:           0x44570140\n=================================\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"reldump_en Interface"})}),"\n",(0,s.jsxs)(n.p,{children:["Real-time dump enable interface. When enabled, real-time I2C transfer data can be viewed via ",(0,s.jsx)(n.code,{children:"dmesg"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-{.text}",children:"# enable\necho 1 > /sys/kernel/debug/dw_i2c0/reldump_en\n\n# disable\necho 0 > /sys/kernel/debug/dw_i2c0/reldump_en\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"fifodump_en Interface"})}),"\n",(0,s.jsx)(n.p,{children:"FIFO dump enable interface. When enabled, it dumps the most recent I2C read/write transactions. Each channel is configured separately and only supports master mode with 7-bit addressing."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-{.text}",children:"# enable\necho 1 > /sys/kernel/debug/dw_i2c0/fifodump_en\n\n# disable\necho 0 > /sys/kernel/debug/dw_i2c0/fifodump_en\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"fifodump Interface"})}),"\n",(0,s.jsxs)(n.p,{children:["Temporarily stores I2C data. When ",(0,s.jsx)(n.code,{children:"fifodump_en"})," is enabled, the stored data can be printed using ",(0,s.jsx)(n.code,{children:"cat"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Transmission normal:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-{.text}",children:"root@ubuntu:~# i2cdump -f -y 0 0x28\n     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f    0123456789abcdef\n00: 00 1f 21 00 00 00 00 00 00 00 XX XX XX XX XX XX    .?!.......XXXXXX\n10: XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX    XXXXXXXXXXXXXXXX\n20: XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX    XXXXXXXXXXXXXXXX\n30: XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX    XXXXXXXXXXXXXXXX\n40: XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX    XXXXXXXXXXXXXXXX\n50: XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX    XXXXXXXXXXXXXXXX\n60: XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX    XXXXXXXXXXXXXXXX\n70: XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX    XXXXXXXXXXXXXXXX\n80: XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX    XXXXXXXXXXXXXXXX\n90: XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX    XXXXXXXXXXXXXXXX\na0: XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX    XXXXXXXXXXXXXXXX\nb0: XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX    XXXXXXXXXXXXXXXX\nc0: XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX    XXXXXXXXXXXXXXXX\nd0: XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX    XXXXXXXXXXXXXXXX\ne0: XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX    XXXXXXXXXXXXXXXX\nf0: XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX    XXXXXXXXXXXXXXXX\n\nroot@ubuntu:~# cat /sys/kernel/debug/dw_i2c0/fifodump\n=b[0]-t[1229.799811]-n[2]-me[0]-ce[1]-ae[0x800008]=\nm[0]-a[0x28]-f[0x0]:0x84\nm[1]-a[0x28]-f[0x1]:0x00\n=b[0]-t[1229.799881]-n[2]-me[0]-ce[1]-ae[0x800008]=\nm[0]-a[0x28]-f[0x0]:0x85\nm[1]-a[0x28]-f[0x1]:0x00\n=b[0]-t[1229.799953]-n[2]-me[0]-ce[1]-ae[0x800008]=\nm[0]-a[0x28]-f[0x0]:0x86\nm[1]-a[0x28]-f[0x1]:0x00\n=b[0]-t[1229.800046]-n[2]-me[0]-ce[1]-ae[0x800008]=\nm[0]-a[0x28]-f[0x0]:0x87\nm[1]-a[0x28]-f[0x1]:0x00\n=b[0]-t[1229.800152]-n[2]-me[0]-ce[1]-ae[0x800008]=\nm[0]-a[0x28]-f[0x0]:0x88\nm[1]-a[0x28]-f[0x1]:0x00\n=b[0]-t[1229.800233]-n[2]-me[0]-ce[1]-ae[0x800008]=\nm[0]-a[0x28]-f[0x0]:0x89\nm[1]-a[0x28]-f[0x1]:0x00\n=b[0]-t[1229.800308]-n[2]-me[0]-ce[1]-ae[0x800008]=\nm[0]-a[0x28]-f[0x0]:0x8a\nm[1]-a[0x28]-f[0x1]:0x00\n=b[0]-t[1229.800384]-n[2]-me[0]-ce[1]-ae[0x800008]=\nm[0]-a[0x28]-f[0x0]:0x8b\nm[1]-a[0x28]-f[0x1]:0x00\n\n b: bus number.\n t: timestamp.\n n: msg numbers.\n m: msg label.\n a: slave addr.\n f: flags, 0 is write, 1 is read.\n"})}),"\n",(0,s.jsx)(n.p,{children:"Transmission abnormal:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-{.text}",children:'=b[1]-t[32991.050148]-n[2]-me[0]-ce[1]-ae[0x800001]=\nm[0]-a[0x10]-f[0x0]:0xfa\nm[1]-a[0x10]-f[0x1]:0x13\n=b[1]-t[32991.050257]-n[2]-me[0]-ce[1]-ae[0x800001]=\nm[0]-a[0x10]-f[0x0]:0xfb\nm[1]-a[0x10]-f[0x1]:0x13\n\nme: msg_err. Normal transmission is equal to "0", address/length mismatch will equal "-EINVAL".\nce: cmd_err. Normal transmission is equal to "0", the error was "DW_IC_ERR_TX_ABRT (0x1u)" transmit termination error.\nae: abort_source.\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Whitelist interface"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-{.text}",children:"root@ubuntu:~# echo 01 02 > /sys/kernel/debug/dw_i2c0/whitelist\nroot@ubuntu:~# cat /sys/kernel/debug/dw_i2c0/whitelist\nwhitelist: 01 02\n"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"The whitelist can be configured using the echo command and displayed using the cat command."}),"\n",(0,s.jsx)(n.li,{children:"The whitelist supports address filtering for both reldump and fifodump."}),"\n",(0,s.jsx)(n.li,{children:'Input is interpreted as hexadecimal by default; invalid input or addresses exceeding 128 will trigger an error. Writing "0" disables the whitelist.'}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"i2c-tools",children:"i2c-tools"}),"\n",(0,s.jsx)(n.p,{children:"i2c-tools is an open-source utility suite. It has already been cross-compiled and included in the S100 system software's rootfs, allowing customers to use it directly:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"i2cdetect --- enumerates I2C buses and all devices on each bus"}),"\n",(0,s.jsx)(n.li,{children:"i2cdump --- displays all register values of an I2C device"}),"\n",(0,s.jsx)(n.li,{children:"i2cget --- reads the value of a specific register from an I2C device"}),"\n",(0,s.jsx)(n.li,{children:"i2cset --- writes a value to a specific register of an I2C device"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"i2c-testing",children:"I2C Testing"}),"\n",(0,s.jsx)(n.h3,{id:"checking-i2cdev-nodes",children:"Checking i2cdev nodes"}),"\n",(0,s.jsx)(n.p,{children:"Verify whether i2c-dev nodes have been created. All devices listed below are configured as master devices:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-{.text}",children:"root@ubuntu:~# ls /sys/class/i2c-dev/\ni2c-0  i2c-1  i2c-2  i2c-3  i2c-4  i2c-5\n\nroot@ubuntu:~# cat /sys/class/i2c-dev/i2c-0/name\nSynopsys DesignWare I2C adapter\n"})}),"\n",(0,s.jsx)(n.p,{children:"Check whether I2C device nodes have been created:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-{.text}",children:"root@ubuntu:~# ls /sys/class/i2c-dev/i2c-0/device/\ndelete_device  device  i2c-dev  name  new_device  of_node  power  subsystem  uevent\n"})}),"\n",(0,s.jsx)(n.h3,{id:"test-procedure",children:"Test procedure"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Test command: i2cdetect -y -r 3"}),"\n",(0,s.jsx)(n.li,{children:"Test example as follows:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-{.text}",children:"root@ubuntu:~# i2cdetect -r -y 3\n     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f\n00:                         -- -- -- -- -- -- -- -- \n10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \n20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \n30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \n40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \n50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \n60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \n70: -- -- -- -- -- -- -- --  \n"})})]})}function o(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);