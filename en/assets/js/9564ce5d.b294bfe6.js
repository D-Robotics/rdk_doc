"use strict";(self.webpackChunkrdk_doc=self.webpackChunkrdk_doc||[]).push([[67552],{16734:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>d,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"Advanced_development/mcu_development/S100/mcu_eth","title":"Eth Usage Guide","description":"Basic Overview","source":"@site/i18n/en/docusaurus-plugin-content-docs-docs_s/current/07_Advanced_development/05_mcu_development/01_S100/11_mcu_eth.md","sourceDirName":"07_Advanced_development/05_mcu_development/01_S100","slug":"/Advanced_development/mcu_development/S100/mcu_eth","permalink":"/rdk_doc/en/rdk_s/Advanced_development/mcu_development/S100/mcu_eth","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1770026433000,"sidebarPosition":11,"frontMatter":{"sidebar_position":11},"sidebar":"tutorialSidebar","previous":{"title":"I2C Usage Guide","permalink":"/rdk_doc/en/rdk_s/Advanced_development/mcu_development/S100/mcu_i2c"},"next":{"title":"PORT\u6a21\u5757\u6307\u5357","permalink":"/rdk_doc/en/rdk_s/07_Advanced_development/05_mcu_development/01_S100/12_mcu_port"}}');var i=n(74848),s=n(28453);const d={sidebar_position:11},o="Eth Usage Guide",a={},l=[{value:"Basic Overview",id:"basic-overview",level:2},{value:"Hardware Features",id:"hardware-features",level:3},{value:"Assumptions and Limitations",id:"assumptions-and-limitations",level:3},{value:"Code Paths",id:"code-paths",level:2},{value:"Application Sample",id:"application-sample",level:2},{value:"Data Transmission",id:"data-transmission",level:3},{value:"Data Reception",id:"data-reception",level:3},{value:"Notes",id:"notes",level:3},{value:"Application Programming Interface",id:"application-programming-interface",level:3},{value:"void Eth_Init( const Eth_ConfigType* CfgPtr )",id:"void-eth_init-const-eth_configtype-cfgptr-",level:4},{value:"Std_ReturnType Eth_SetControllerMode(uint8 CtrlIdx, Eth_ModeType CtrlMode)",id:"std_returntype-eth_setcontrollermodeuint8-ctrlidx-eth_modetype-ctrlmode",level:4},{value:"Std_ReturnType Eth_GetControllerMode(uint8 CtrlIdx, Eth_ModeType* CtrlModePtr)",id:"std_returntype-eth_getcontrollermodeuint8-ctrlidx-eth_modetype-ctrlmodeptr",level:4},{value:"void Eth_GetPhysAddr(uint8 CtrlIdx, uint8* PhysAddrPtr)",id:"void-eth_getphysaddruint8-ctrlidx-uint8-physaddrptr",level:4},{value:"void Eth_SetPhysAddr(uint8 CtrlIdx, const uint8* PhysAddrPtr)",id:"void-eth_setphysaddruint8-ctrlidx-const-uint8-physaddrptr",level:4},{value:"Std_ReturnType Eth_GetCurrentTime(uint8 CtrlIdx, Eth_TimeStampQualType* timeQualPtr, Eth_TimeStampType* timeStampPtr)",id:"std_returntype-eth_getcurrenttimeuint8-ctrlidx-eth_timestampqualtype-timequalptr-eth_timestamptype-timestampptr",level:4},{value:"BufReq_ReturnType Eth_ProvideTxBuffer(uint8 CtrlIdx, uint8 Priority, Eth_BufIdxType *BufIdxPtr, uint8 **BufPtr, uint16 *LenBytePtr)",id:"bufreq_returntype-eth_providetxbufferuint8-ctrlidx-uint8-priority-eth_bufidxtype-bufidxptr-uint8-bufptr-uint16-lenbyteptr",level:4},{value:"Std_ReturnType Eth_Transmit(uint8 CtrlIdx, Eth_BufIdxType BufIdx, Eth_FrameType FrameType, boolean TxConfirmation, uint16 LenByte, const uint8* PhysAddrPtr)",id:"std_returntype-eth_transmituint8-ctrlidx-eth_bufidxtype-bufidx-eth_frametype-frametype-boolean-txconfirmation-uint16-lenbyte-const-uint8-physaddrptr",level:4},{value:"void Eth_Receive(uint8 CtrlIdx, uint8 FifoIdx, Eth_RxStatusType* RxStatusPtr)",id:"void-eth_receiveuint8-ctrlidx-uint8-fifoidx-eth_rxstatustype-rxstatusptr",level:4},{value:"void Eth_TxConfirmation(uint8 CtrlIdx)",id:"void-eth_txconfirmationuint8-ctrlidx",level:4},{value:"Std_ReturnType Eth_EnableSnapshot(uint8 CtrlIdx, GMAC_PPS_SOURCE PpsSource)",id:"std_returntype-eth_enablesnapshotuint8-ctrlidx-gmac_pps_source-ppssource",level:4},{value:"Std_ReturnType Eth_GetSnapshotTime(uint8 CtrlIdx, Eth_TimeStampType * TimeStampPtr)",id:"std_returntype-eth_getsnapshottimeuint8-ctrlidx-eth_timestamptype--timestampptr",level:4}];function c(e){const t={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"eth-usage-guide",children:"Eth Usage Guide"})}),"\n",(0,i.jsx)(t.h2,{id:"basic-overview",children:"Basic Overview"}),"\n",(0,i.jsx)(t.h3,{id:"hardware-features",children:"Hardware Features"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Supports data transfer rates up to 1000 Mbps"}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Supports full-duplex flow control operations (including IEEE 802.3x Pause packets and Priority Flow Control)"}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Supports network statistics functionality"}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Supports Ethernet packet timestamping as defined by IEEE 1588-2002/1588-2008 standards"}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Supports output of PPS (Pulse Per Second) signal"}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Supports programmable Ethernet frame length, up to a maximum of 16 KB"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"assumptions-and-limitations",children:"Assumptions and Limitations"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"FIFOs for transmit and receive directions support up to 6 each."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Does not support transmission of data exceeding the available buffer size of the controller in use; longer data must be transmitted using Internet Protocol (IP) and Transmission Control Protocol (TCP)."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"The length of a single received frame (including the 14-byte Ethernet header and 4-byte FCS) must be less than or equal to the configured RX buffer length."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Module clock frequency is 300 MHz, and the PTP clock period is 20 ns."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"code-paths",children:"Code Paths"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"McalCdd/Ethernet/inc # Header files"}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"McalCdd/Ethernet/src/Eth.c # Provides external API interfaces"}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"McalCdd/Ethernet/src/Eth_Interrupt.c # Interrupt handling callback function interfaces"}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"McalCdd/Ethernet/src/Mac_Lld.c # Wraps register control interfaces for use by API functions"}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Config/McalCdd/gen_s100_sip_B_mcu1/Ethernet/src/Eth_PBcfg.c # Pre-compiled Eth configuration, used to provide initialization attributes for external API calls"}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Config/McalCdd/gen_s100_sip_B_mcu1/Ethernet/src/Mac_Ip_PBcfg.c # Pre-compiled MAC driver configuration, statically dependent on Eth_PBcfg.c"}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"samples/Eth/Eth_Test/Eth_test.c # Eth functional test example program"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"application-sample",children:"Application Sample"}),"\n",(0,i.jsxs)(t.p,{children:["Taking S100's ",(0,i.jsx)(t.code,{children:"samples/Eth/Eth_Test/Eth_test.c"})," sending an ARP packet as an example:"]}),"\n",(0,i.jsx)(t.h3,{id:"data-transmission",children:"Data Transmission"}),"\n",(0,i.jsx)(t.p,{children:"The Eth_test.c test program constructs and sends an ARP packet. A PC uses Wireshark to capture packets and verify whether the data is received correctly. The IP address is set by default and cannot be modified dynamically."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"0xd4, 0xfd, 0x9b, 0xae, 0x48, 0xf5, // Sender MAC address: d4:fd:9b:ae:48:f5  // MCU\n0xC0, 0xA8, 0x01, 0x32,             // Sender IP address: 192.168.1.50\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Target MAC address: 00:00:00:00:00:00  // PC\n0xC0, 0xA8, 0x01, 0xf,              // Target IP address: 192.168.1.15\n"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Pseudocode calls"}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Eth_ProvideTxBuffer // Allocate buffer\nEth_Transmit        // Transmit data\nEth_TxConfirmation  // Release buffer\n"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Test instructions"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"By default, only Eth initialization is performed upon system startup. The data transmission steps are as follows:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"# Enable periodic calling of EthTest_Mainfunc\nsetvar Eth_Test 1\n\n# Bring Eth up\nsetvar eth_contrMode 1\nsetvar eth_testCase 3\n\n# Send ARP packet\nsetvar eth_testCase 14\n"})}),"\n",(0,i.jsx)(t.h3,{id:"data-reception",children:"Data Reception"}),"\n",(0,i.jsx)(t.p,{children:"Received packets are printed via the serial port within EthIf_RxIndication. Reference implementation as follows:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'if(eth_getIngressTsFlag)\n{\n    eth_getIngressTsFlag = FALSE;\n    /* QT-S01-API-60105 QT-S01-API-60106 QT-S01-API-60107 QT-S01-API-60194 */\n    Eth_GetIngressTimeStamp(CtrlIdx,DataPtr,&Eth_TimeQual,&Eth_TimeStamp);\n    //LogSync("Ingress timestamp quality: %s\\r\\n", (Eth_TimeQual==ETH_VALID)?"ETH_VALID":"ETH_INVALID");\n    //LogSync("Ingress timestamp: %ds: %dns\\r\\n", ((uint32)(Eth_TimeStamp.secondsHi) << 16) + Eth_TimeStamp.seconds, Eth_TimeStamp.nanoseconds);\n    if(Eth_TimeStamp.secondsHi!=0 || Eth_TimeStamp.nanoseconds!=0)\n    {\n        eth_checkIngressTsFlg=TRUE;\n    }\n}\n\nif (count % 100 == 0) {\n    LogSync("Eth packet is received, FrameType: %x, IsBroadcast: %s\\r\\n", FrameType, (IsBroadcast==TRUE)?"TRUE":"FALSE");\n    LogSync("DstMac: %x-%x-%x-%x-%x-%x\\r\\n", *(DataPtr-14),*(DataPtr-13),*(DataPtr-12),*(DataPtr-11),*(DataPtr-10),*(DataPtr-9));\n    LogSync("SrcMac: %x-%x-%x-%x-%x-%x\\r\\n", PhysAddrPtr[0],PhysAddrPtr[1],PhysAddrPtr[2],PhysAddrPtr[3],PhysAddrPtr[4],PhysAddrPtr[5]);\n}\ncount++;\nif(FrameType==0x800)\n{\n    LogSync("IP header checksum:%x,%x\\r\\n",DataPtr[10],DataPtr[11]);\n    if(DataPtr[9]==0x11)//UDP\n    {\n        LogSync("UDP checksum:%x,%x\\r\\n",DataPtr[26],DataPtr[27]);\n        eth_checkCksFlg=TRUE;\n    }\n    else if(DataPtr[9]==0x6)//TCP\n    {\n        LogSync("TCP checksum:%x,%x\\r\\n",DataPtr[36],DataPtr[37]);\n        eth_checkCksFlg=TRUE;\n    }\n}\n'})}),"\n",(0,i.jsx)(t.h3,{id:"notes",children:"Notes"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"S100 uses polling mode for data transmission by default. In polling mode, note that after transmitting data using the allocated buffer, Eth_TxConfirmation must be called to release the buffer."}),"\n",(0,i.jsx)(t.li,{children:"Before calling Eth_Init, ensure the PHY is de-asserted from reset to guarantee successful initialization. On S100, this is achieved by pulling the PHY reset pin high."}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"application-programming-interface",children:"Application Programming Interface"}),"\n",(0,i.jsx)(t.h4,{id:"void-eth_init-const-eth_configtype-cfgptr-",children:"void Eth_Init( const Eth_ConfigType* CfgPtr )"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Description: Initializes the Ethernet Driver.\n\nSync/Async: Synchronous\nParameters (in)\n    CfgPtr: Points to the implementation-specific configuration structure\nParameters (inout)\n    None\nParameters (out)\n    None\nReturn value: None\n"})}),"\n",(0,i.jsx)(t.h4,{id:"std_returntype-eth_setcontrollermodeuint8-ctrlidx-eth_modetype-ctrlmode",children:"Std_ReturnType Eth_SetControllerMode(uint8 CtrlIdx, Eth_ModeType CtrlMode)"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Description: Enables / disables the indexed controller.\n\nSync/Async: Asynchronous\nParameters (in)\n    CtrlIdx: Index of the controller within the context of the Ethernet Driver\n    CtrlMode: ETH_MODE_DOWN: disable the controller; ETH_MODE_ACTIVE: enable the controller\nParameters (inout)\n    None\nParameters (out)\n    None\nReturn value: Std_ReturnType\n    E_OK: success\n    E_NOT_OK: controller mode could not be changed\n"})}),"\n",(0,i.jsx)(t.h4,{id:"std_returntype-eth_getcontrollermodeuint8-ctrlidx-eth_modetype-ctrlmodeptr",children:"Std_ReturnType Eth_GetControllerMode(uint8 CtrlIdx, Eth_ModeType* CtrlModePtr)"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Description: Retrieves the current mode of the indexed controller.\n\nSync/Async: Synchronous\nParameters (in)\n    CtrlIdx: Index of the controller within the context of the Ethernet Driver\nParameters (inout)\n    CtrlModePtr: Pointer to store the controller mode (ETH_MODE_DOWN: disabled; ETH_MODE_ACTIVE: enabled)\nParameters (out)\n    None\nReturn value: Std_ReturnType\n    E_OK: success\n    E_NOT_OK: controller mode could not be obtained\n"})}),"\n",(0,i.jsx)(t.h4,{id:"void-eth_getphysaddruint8-ctrlidx-uint8-physaddrptr",children:"void Eth_GetPhysAddr(uint8 CtrlIdx, uint8* PhysAddrPtr)"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Description: Obtains the physical source address (MAC address) used by the indexed controller.\n\nSync/Async: Synchronous\nParameters (in)\n    CtrlIdx: Index of the controller within the context of the Ethernet Driver\nParameters (inout)\n    PhysAddrPtr: Physical source address (MAC address) in network byte order\nParameters (out)\n    None\nReturn value: None\n"})}),"\n",(0,i.jsx)(t.h4,{id:"void-eth_setphysaddruint8-ctrlidx-const-uint8-physaddrptr",children:"void Eth_SetPhysAddr(uint8 CtrlIdx, const uint8* PhysAddrPtr)"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Description: Sets the physical source address used by the indexed controller.\n\nSync/Async: Synchronous\nParameters(in)\n    CtrlIdx: Index of the controller within the context of the Ethernet Driver\n    PhysAddrPtr: Pointer to memory containing the physical source address (MAC address) in network byte order\nParameters(inout)\n    None\nParameters(out)\n    None\nReturn value: None\n"})}),"\n",(0,i.jsx)(t.h4,{id:"std_returntype-eth_getcurrenttimeuint8-ctrlidx-eth_timestampqualtype-timequalptr-eth_timestamptype-timestampptr",children:"Std_ReturnType Eth_GetCurrentTime(uint8 CtrlIdx, Eth_TimeStampQualType* timeQualPtr, Eth_TimeStampType* timeStampPtr)"}),"\n",(0,i.jsx)(t.admonition,{title:"Note",type:"info",children:(0,i.jsx)(t.p,{children:"Eth_GetCurrentTime may be called within an exclusive area."})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Description: Returns a time value out of the HW registers according to the capability of the HW. If the HW resolution is lower than the Eth_TimeStampType resolution resp. range, then the remaining bits will be filled with 0.\n\nSync/Async: Synchronous\nParameters(in)\n    CtrlIdx: Index of the controller within the context of the Ethernet Driver\nParameters(inout)\n    None\nParameters(out)\n    timeQualPtr: Quality of HW time stamp, e.g. based on current drift\n    timeStampPtr: Current time stamp\nReturn value: Std_ReturnType\n    E_OK: success\n    E_NOT_OK: failed\n"})}),"\n",(0,i.jsx)(t.h4,{id:"bufreq_returntype-eth_providetxbufferuint8-ctrlidx-uint8-priority-eth_bufidxtype-bufidxptr-uint8-bufptr-uint16-lenbyteptr",children:"BufReq_ReturnType Eth_ProvideTxBuffer(uint8 CtrlIdx, uint8 Priority, Eth_BufIdxType *BufIdxPtr, uint8 **BufPtr, uint16 *LenBytePtr)"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Description: Provides access to a transmit buffer of the FIFO related to the specified priority.\n\nSync/Async: Synchronous\nParameters(in)\n    CtrlIdx: Index of the controller\n    Priority: Frame priority for transmit buffer FIFO selection\nParameters(inout)\n    LenBytePtr: In: desired length in bytes, out: granted length in bytes\nParameters(out)\n    BufIdxPtr: Index to the granted buffer resource. To be used for subsequent requests\n    BufPtr: Pointer to the granted buffer\nReturn value: BufReq_ReturnType\n    BUFREQ_OK: success\n    BUFREQ_E_NOT_OK: development error detected\n    BUFREQ_E_BUSY: all buffers in use\n    BUFREQ_E_OVFL: requested buffer too large\n"})}),"\n",(0,i.jsx)(t.h4,{id:"std_returntype-eth_transmituint8-ctrlidx-eth_bufidxtype-bufidx-eth_frametype-frametype-boolean-txconfirmation-uint16-lenbyte-const-uint8-physaddrptr",children:"Std_ReturnType Eth_Transmit(uint8 CtrlIdx, Eth_BufIdxType BufIdx, Eth_FrameType FrameType, boolean TxConfirmation, uint16 LenByte, const uint8* PhysAddrPtr)"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Description: Triggers transmission of a previously filled transmit buffer.\n\nSync/Async: Synchronous\nParameters(in)\n    CtrlIdx: Index of the controller\n    BufIdx: Index of the buffer resource\n    FrameType: Ethernet frame type\n    TxConfirmation: Activates transmission confirmation\n    LenByte: Data length in byte\n    PhysAddrPtr: Physical target address (MAC address) in network byte order\nParameters(inout)\n    None\nParameters(out)\n    None\nReturn value: Std_ReturnType\n    E_OK: success\n    E_NOT_OK: transmission failed\n"})}),"\n",(0,i.jsx)(t.h4,{id:"void-eth_receiveuint8-ctrlidx-uint8-fifoidx-eth_rxstatustype-rxstatusptr",children:"void Eth_Receive(uint8 CtrlIdx, uint8 FifoIdx, Eth_RxStatusType* RxStatusPtr)"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Description: Receive a frame from the related fifo.\n\nSync/Async: Synchronous\nParameters(in)\n    CtrlIdx: Index of the controller\n    FifoIdx: Specifies the related fifo\nParameters(inout)\n    None\nParameters(out)\n    RxStatusPtr: Indicates whether a frame has been received and if so, whether more frames are available for the related fifo.\nReturn value: None\n"})}),"\n",(0,i.jsx)(t.h4,{id:"void-eth_txconfirmationuint8-ctrlidx",children:"void Eth_TxConfirmation(uint8 CtrlIdx)"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Description: Triggers frame transmission confirmation.\n\nSync/Async: Synchronous\nParameters(in)\n    CtrlIdx: Index of the controller\nParameters(inout)\n    None\nParameters(out)\n    None\nReturn value: None\n"})}),"\n",(0,i.jsx)(t.h4,{id:"std_returntype-eth_enablesnapshotuint8-ctrlidx-gmac_pps_source-ppssource",children:"Std_ReturnType Eth_EnableSnapshot(uint8 CtrlIdx, GMAC_PPS_SOURCE PpsSource)"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Description: Set snapshot source.\n\nSync/Async: Asynchronous\nParameters(in)\n    CtrlIdx: Index of the ETH controller\n    PpsSource: Index of the PPS Source\nParameters(inout)\n    None\nParameters(out)\n    None\nReturn value: Std_ReturnType\n    E_OK: success\n    E_NOT_OK: failed\n"})}),"\n",(0,i.jsx)(t.h4,{id:"std_returntype-eth_getsnapshottimeuint8-ctrlidx-eth_timestamptype--timestampptr",children:"Std_ReturnType Eth_GetSnapshotTime(uint8 CtrlIdx, Eth_TimeStampType * TimeStampPtr)"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Description: Get snapshot time of PHC.\n\nSync/Async: Asynchronous\nParameters(in)\n    CtrlIdx: Index of the ETH controller\n    TimeStampPtr: Snapshot Time of PHC\nParameters(inout)\n    None\nParameters(out)\n    None\nReturn value: Std_ReturnType\n    E_OK: success\n    E_NOT_OK: failed\n"})})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>d,x:()=>o});var r=n(96540);const i={},s=r.createContext(i);function d(e){const t=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);