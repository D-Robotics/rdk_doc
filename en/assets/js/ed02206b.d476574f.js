"use strict";(self.webpackChunkrdk_doc=self.webpackChunkrdk_doc||[]).push([[98720],{12813:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>o,default:()=>_,frontMatter:()=>d,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"Advanced_development/linux_development/driver_development_s100/driver_spi_dev","title":"SPI Debugging Guide","description":"SPI Hardware Support","source":"@site/i18n/en/docusaurus-plugin-content-docs-docs_s/current/07_Advanced_development/02_linux_development/04_driver_development_s100/07_driver_spi_dev.md","sourceDirName":"07_Advanced_development/02_linux_development/04_driver_development_s100","slug":"/Advanced_development/linux_development/driver_development_s100/driver_spi_dev","permalink":"/rdk_doc/en/rdk_s/Advanced_development/linux_development/driver_development_s100/driver_spi_dev","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1770785005000,"sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"tutorialSidebar","previous":{"title":"Introduction to the IPC Module","permalink":"/rdk_doc/en/rdk_s/Advanced_development/linux_development/driver_development_s100/driver_ipc"},"next":{"title":"PWM Driver Debugging Guide","permalink":"/rdk_doc/en/rdk_s/Advanced_development/linux_development/driver_development_s100/driver_pwm"}}');var s=n(74848),i=n(28453);const d={sidebar_position:7},o="SPI Debugging Guide",a={},l=[{value:"SPI Hardware Support",id:"spi-hardware-support",level:2},{value:"Software Architecture",id:"software-architecture",level:2},{value:"Code Paths",id:"code-paths",level:2},{value:"Hobot SPI Protocol Code",id:"hobot-spi-protocol-code",level:3},{value:"Linux SPI Framework Code",id:"linux-spi-framework-code",level:3},{value:"SPI Device Tree Code",id:"spi-device-tree-code",level:3},{value:"SPI Device Tree Configuration Explanation",id:"spi-device-tree-configuration-explanation",level:3},{value:"SPI Verification and Debugging",id:"spi-verification-and-debugging",level:2},{value:"Test Environment Preparation",id:"test-environment-preparation",level:3},{value:"SPI Internal Loopback Test",id:"spi-internal-loopback-test",level:3},{value:"SPI External Loopback Test",id:"spi-external-loopback-test",level:3}];function c(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"spi-debugging-guide",children:"SPI Debugging Guide"})}),"\n",(0,s.jsx)(t.h2,{id:"spi-hardware-support",children:"SPI Hardware Support"}),"\n",(0,s.jsx)(t.p,{children:"The S100 Acore supports two SPI interfaces, and SPI0 and SPI1 can only operate as SPI Masters."}),"\n",(0,s.jsx)(t.h2,{id:"software-architecture",children:"Software Architecture"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/02_linux_development/driver_development_s100/image-spi_software.png",alt:"image-spi_software"})}),"\n",(0,s.jsx)(t.p,{children:"The above figure illustrates the SPI software architecture. From bottom to top, it can be divided into the hardware IP layer, kernel layer, and user space layer. Each layer is introduced below."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Hardware IP Layer"}),": This layer represents the SPI hardware."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Kernel Layer"}),": This layer can be further subdivided into three sub-layers:","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"SPI Driver Layer"}),": Primarily implements operations for the SPI hardware IP and also implements interfaces defined by the SPI framework."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"SPI Framework Layer"}),": Acts as an adaptation layer for the SPI driver. It defines a set of interfaces that the driver layer must implement for the lower layer and provides generic interfaces to the upper layer, abstracting hardware details."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"SPI Char Device Layer"}),": Provides device nodes for user space, facilitating data exchange between user space and kernel space. Currently, the kernel\u2019s built-in ",(0,s.jsx)(t.code,{children:"spidev"})," character device is used."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Application Layer"}),": Consists of various applications that interact with kernel space by calling character device drivers to exchange data."]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"code-paths",children:"Code Paths"}),"\n",(0,s.jsx)(t.h3,{id:"hobot-spi-protocol-code",children:"Hobot SPI Protocol Code"}),"\n",(0,s.jsxs)(t.p,{children:["All Hobot SPI driver-related code is located under the ",(0,s.jsx)(t.strong,{children:"$project/hobot-drivers/spi"})," directory."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-{.text}",children:"oops@tiger$ tree . -L 1\n\n\u251c\u2500\u2500 Kconfig                       # Kconfig-related files\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500spi_drv                        # SPI driver-related files\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Description of the ",(0,s.jsx)(t.strong,{children:"$project/hobot-drivers/spi/spi_drv"})," directory:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-{.text}",children:"oops@tiger$ tree . -L 1\n\u251c\u2500\u2500 Makefile\n\u251c\u2500\u2500 spi-dw.c                       # Core SPI driver code\n\u251c\u2500\u2500 spi-dw.h\n\u251c\u2500\u2500 spi-dw-mmio.c                  # SPI driver MMIO code\n\u2514\u2500\u2500 spi-dw-mmio-dma.c              # SPI driver DMA code\n"})}),"\n",(0,s.jsx)(t.h3,{id:"linux-spi-framework-code",children:"Linux SPI Framework Code"}),"\n",(0,s.jsxs)(t.p,{children:["All Linux SPI protocol-related code resides in the ",(0,s.jsx)(t.strong,{children:"$project/kernel/drivers/spi"})," directory."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-{.text}",children:"oops@tiger$ tree kernel/drivers/spi/\ndrivers/spi/\n\u251c\u2500\u2500 spi.c                             # SPI framework code\n\noops@tiger$\n"})}),"\n",(0,s.jsx)(t.h3,{id:"spi-device-tree-code",children:"SPI Device Tree Code"}),"\n",(0,s.jsx)(t.p,{children:"The following DTS files in S100 involve SPI-related configurations:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-C",children:"|-- drobot-s100-pinctrl.dtsi       # SPI pinctrl configuration\n|-- drobot-s100-soc.dtsi           # SPI device node configuration\n|-- drobot-s100-pdma.dtsi          # SPI PDMA usage configuration\n"})}),"\n",(0,s.jsx)(t.h3,{id:"spi-device-tree-configuration-explanation",children:"SPI Device Tree Configuration Explanation"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-dts",children:'spi0: spi@39800000 {\n\t\tcompatible = "hobot,hb-dw-spi";\n\t\treg-io-width = <4>;\n\t\t#address-cells = <1>;\n\t\t#size-cells = <0>;\n\t\treg = <0x0 0x39800000 0x0 0x1000>;\n\t\tinterrupts = <GIC_SPI PERISYS_SPI0_SSI_INTR PERISYS_SPI0_SSI_INTR_TRIG_TYPE>;\n\t\tstatus = "okay";\n\t\tnum-cs = <2>;\n\t\tresets = <&smc_reset RST_IDX_IP_PERI_SPIM0>,\n\t\t\t\t\t\t\t\t<&smc_reset RST_IDX_IP_PERI_SPIM0_APB>;\n\t\treset-names = "spi_reset";\n\t\tclocks = <&scmi_smc_clk CLK_IDX_TOP_PERI_SPI_M0>;\n\t\tclock-names = "spi_pclk";\n\t\tpower-domains = <&scmi_smc_pd PD_IDX_LSPERI_TOP>;\n\t\tfreq-pclk = <200000000>;\n\t\tsample-delay = <1>;\n\t\tpinctrl-names = "default";\n\t\tpinctrl-0 = <&peri_spi0>;\n\t\tdmas = <&pdma0 8                        /* read channel */\n\t\t\t\t\t\t&pdma0 9        >;              /* write channel */\n\t\tdma-names = "rx", "tx";\n\t\tspidev@0 {\n\t\t\t\tcompatible = "rohm,dh2228fv";\n\t\t\t\tspi-max-frequency = <50000000>;\n\t\t\t\treg = <0>;\n\t\t};\n};\n\nspi1: spi@39810000 {\n\t\tcompatible = "hobot,hb-dw-spi";\n\t\treg-io-width = <4>;\n\t\t#address-cells = <1>;\n\t\t#size-cells = <0>;\n\t\treg = <0x0 0x39810000 0x0 0x1000>;\n\t\tinterrupts = <GIC_SPI PERISYS_SPI1_SSI_INTR PERISYS_SPI1_SSI_INTR_TRIG_TYPE>;\n\t\tstatus = "okay";\n\t\tnum-cs = <2>;\n\t\tresets = <&smc_reset RST_IDX_IP_PERI_SPIM1>,\n\t\t\t\t\t\t\t\t<&smc_reset RST_IDX_IP_PERI_SPIM1_APB>;\n\t\treset-names = "spi_reset";\n\t\tclocks = <&scmi_smc_clk CLK_IDX_TOP_PERI_SPI_M1>;\n\t\tclock-names = "spi_pclk";\n\t\tpower-domains = <&scmi_smc_pd PD_IDX_LSPERI_TOP>;\n\t\tfreq-pclk = <200000000>;\n\t\tsample-delay = <1>;\n\t\tpinctrl-names = "default";\n\t\tpinctrl-0 = <&peri_spi1>;\n\t\tdmas = <&pdma0 10                       /* read channel */\n\t\t\t\t\t\t&pdma0 11       >;              /* write channel */\n\t\tdma-names = "rx", "tx";\n\t\tspidev@0 {\n\t\t\t\tcompatible = "rohm,dh2228fv";\n\t\t\t\tspi-max-frequency = <50000000>;\n\t\t\t\treg = <0>;\n\t\t};\n};\n\n'})}),"\n",(0,s.jsx)(t.p,{children:"Key newly added configuration items for S100 SPI are explained below:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"sample-delay"}),": When the SPI controller operates as a master, this value specifies the sampling delay for received data. If bit misalignment occurs in received data, adjust this value accordingly."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"num-cs"}),": When the SPI controller operates as a master, this specifies the number of chip selects (CS) supported. The S100 SPI supports up to two chip selects in master mode."]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"spi-verification-and-debugging",children:"SPI Verification and Debugging"}),"\n",(0,s.jsx)(t.p,{children:"This section introduces how to verify basic SPI functionality on the S100, including environment setup, execution of test commands, and locations of test code."}),"\n",(0,s.jsx)(t.h3,{id:"test-environment-preparation",children:"Test Environment Preparation"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"spidev_test"})," is an open-source SPI testing utility. Users can directly obtain and compile it from the following directory in the Linux source code:"]}),"\n",(0,s.jsxs)(t.p,{children:["Source location: ",(0,s.jsx)(t.code,{children:"kernel/tools/spi/spidev_test.c"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Common parameters for ",(0,s.jsx)(t.code,{children:"spidev_test"})," are explained below:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:'root@ubuntu:/map# ./spidev_test -h\n./spidev_test: invalid option -- \'h\'\nUsage: ./spidev_test [-DsbdlHOLC3vpNR24SI]\n   -D --device   device to use (default /dev/spidev1.1)\n   -s --speed    max speed (Hz)\n   -d --delay    delay (usec)\n   -b --bpw      bits per word\n   -i --input    input data from a file (e.g. "test.bin")\n   -o --output   output data to a file (e.g. "results.bin")\n   -l --loop     loopback\n   -H --cpha     clock phase\n   -O --cpol     clock polarity\n   -L --lsb      least significant bit first\n   -C --cs-high  chip select active high\n   -3 --3wire    SI/SO signals shared\n   -v --verbose  Verbose (show tx buffer)\n   -p            Send data (e.g. "1234\\xde\\xad")\n   -N --no-cs    no chip select\n   -R --ready    slave pulls low to pause\n   -2 --dual     dual transfer\n   -4 --quad     quad transfer\n   -8 --octal    octal transfer\n   -S --size     transfer size\n   -I --iter     iterations\n'})}),"\n",(0,s.jsx)(t.h3,{id:"spi-internal-loopback-test",children:"SPI Internal Loopback Test"}),"\n",(0,s.jsx)(t.p,{children:"The SPI internal loopback test is supported only when operating as an SPI Master. The principle involves the SPI hardware IP\u2019s TX FIFO sending data directly to the RX FIFO to form a loopback."}),"\n",(0,s.jsx)(t.p,{children:"Example test command and results:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:'root@ubuntu:/map# ./spidev_test -D /dev/spidev1.0 -s 1000000 -S 100 -l -v -p "\\x01\\x02\\x03\\x04"\nspi mode: 0x20\nbits per word: 8\nmax speed: 1000000 Hz (1000 kHz)\nTX | 01 02 03 04 __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  |....|\nRX | 01 02 03 04 __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  |....|\n'})}),"\n",(0,s.jsx)(t.h3,{id:"spi-external-loopback-test",children:"SPI External Loopback Test"}),"\n",(0,s.jsx)(t.p,{children:"SPI external loopback test refers to connecting an SPI Master to an SPI Slave."}),"\n",(0,s.jsx)(t.p,{children:"The Master can be selected as SPI1, and the SPI Slave should be an external SPI device (chosen by the customer)."}),"\n",(0,s.jsx)(t.p,{children:"The command for sending test data from the S100 side is as follows:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:'root@ubuntu:/map# ./spidev_test -D /dev/spidev1.0 -s 1000000 -S 100  -v -p "\\x01\\x02\\x03\\x04"\nspi mode: 0x0\nbits per word: 8\nmax speed: 1000000 Hz (1000 kHz)\nTX | 01 02 03 04 __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  |....|\nRX | FF FF FF FF __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  |....|\n'})}),"\n",(0,s.jsx)(t.p,{children:"The Slave device will receive the data sent by the Master on the S100 side."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Note: When performing the external loopback test, the SPI Slave program must be executed first, followed by the SPI Master program. If the SPI Master program is executed before the SPI Slave program, data loss may occur due to desynchronization between the Master and Slave."})})]})}function _(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>d,x:()=>o});var r=n(96540);const s={},i=r.createContext(s);function d(e){const t=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);