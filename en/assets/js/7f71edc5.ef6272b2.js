"use strict";(self.webpackChunkrdk_doc=self.webpackChunkrdk_doc||[]).push([[423],{28453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>c});var r=i(96540);const s={},d=r.createContext(s);function t(e){const n=r.useContext(d);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),r.createElement(d.Provider,{value:n},e.children)}},76713:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"Advanced_development/linux_development/driver_development_x5/driver_i2c_dev","title":"I2C Debugging Guide","description":"Foreword","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/07_Advanced_development/02_linux_development/driver_development_x5/driver_i2c_dev.md","sourceDirName":"07_Advanced_development/02_linux_development/driver_development_x5","slug":"/Advanced_development/linux_development/driver_development_x5/driver_i2c_dev","permalink":"/rdk_doc/en/Advanced_development/linux_development/driver_development_x5/driver_i2c_dev","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1762784650000,"sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"UART Driver Debugging Guide","permalink":"/rdk_doc/en/Advanced_development/linux_development/driver_development_x5/driver_uart_dev"},"next":{"title":"LCD Driver Debugging Guide","permalink":"/rdk_doc/en/Advanced_development/linux_development/driver_development_x5/driver_lcd"}}');var s=i(74848),d=i(28453);const t={sidebar_position:3},c="I2C Debugging Guide",l={},o=[{value:"Foreword",id:"foreword",level:2},{value:"X5&#39;s I2C Controller",id:"x5s-i2c-controller",level:2},{value:"Driver Code",id:"driver-code",level:2},{value:"Kernel Configuration Location",id:"kernel-configuration-location",level:3},{value:"Kernel DTS Node Configuration",id:"kernel-dts-node-configuration",level:3},{value:"I2C Usage",id:"i2c-usage",level:2},{value:"Kernel Space",id:"kernel-space",level:3},{value:"User Space",id:"user-space",level:3}];function a(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,d.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"i2c-debugging-guide",children:"I2C Debugging Guide"})}),"\n",(0,s.jsx)(n.h2,{id:"foreword",children:"Foreword"}),"\n",(0,s.jsx)(n.p,{children:"The X5 chip provides a standard I2C bus, where the I2C bus controller transmits information between devices connected to the bus via the serial data line (SDA) and the serial clock line (SCL). Each device has a unique address (whether it is a microcontroller\u2014MCU, LCD controller, memory, or keyboard interface), and can act as both a transmitter and a receiver (depending on the device's function)."}),"\n",(0,s.jsx)(n.p,{children:"The I2C controller supports the following features:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Supports three speed modes:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Standard mode (0-100Kb/s)"}),"\n",(0,s.jsx)(n.li,{children:"Fast mode (0-400Kb/s) & Fast mode plus (0-1000Kb/s)"}),"\n",(0,s.jsx)(n.li,{children:"High-speed mode (0-3.4Mb/s)"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Supports master-slave configuration"}),"\n",(0,s.jsx)(n.li,{children:"Supports 7-bit and 10-bit addressing modes"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"x5s-i2c-controller",children:"X5's I2C Controller"}),"\n",(0,s.jsx)(n.p,{children:"The X5 provides a total of 8 I2C controllers, 7 of which (I2C0 to I2C6) are located in the LSIO subsystem, and 1 (I2C7) is located in the DSP subsystem. Out of these 8 controllers, only I2C4 supports high-speed mode."}),"\n",(0,s.jsx)(n.h2,{id:"driver-code",children:"Driver Code"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"drivers/i2c/i2c-dev.c             # I2C Character Device Interface Code\ndrivers/i2c/i2c-core-base.c       # I2C Framework Code\ndrivers/i2c/busses/i2c-designware-platdrv.c # I2C Driver Source Code\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"kernel-configuration-location",children:"Kernel Configuration Location"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"/* arch/arm64/configs/hobot_x5_soc_defconfig */\nCONFIG_I2C_CHARDEV=y              # I2C Driver User-Space Configuration Macro\nCONFIG_I2C_DESIGNWARE_PLATFORM=y  # DW I2C Driver Configuration Macro\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"kernel-dts-node-configuration",children:"Kernel DTS Node Configuration"}),"\n",(0,s.jsxs)(n.p,{children:["The X5 chip supports a total of 8 I2C buses. The device tree definition for the X5 I2C controller is located in the SDK package's kernel folder at ",(0,s.jsx)(n.code,{children:"arch/arm64/boot/dts/hobot/x5.dtsi"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)("font",{color:"red",children:"Note:"})," The nodes in ",(0,s.jsx)(n.code,{children:"x5.dtsi"})," primarily declare SoC-level features and are not specific to any particular circuit board, so they generally do not need to be modified."]}),"\n",(0,s.jsx)(n.h2,{id:"i2c-usage",children:"I2C Usage"}),"\n",(0,s.jsxs)(n.p,{children:["Detailed instructions for using I2C can be found in the Linux Kernel's ",(0,s.jsx)(n.code,{children:"Documentation/i2c"})," folder. This document mainly highlights special parts of the X3J3 I2C driver interface."]}),"\n",(0,s.jsx)(n.h3,{id:"kernel-space",children:"Kernel Space"}),"\n",(0,s.jsx)(n.p,{children:"The X3J3 I2C driver in Kernel Space provides an interface for setting the I2C transfer frequency. The usage is as follows:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"I2C Speed Configuration"})}),"\n",(0,s.jsxs)(n.p,{children:["The default I2C speed is 100K, and it supports the following speeds: 100k, 200k, 400k, 1M, and 3.4M. The speed can be modified by adjusting the relevant I2C node parameters, such as ",(0,s.jsx)(n.code,{children:"clock-frequency"}),", in the DTS."]}),"\n",(0,s.jsx)(n.p,{children:"For example, to modify the operating speed of the i2c4 controller:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If 3.4 MHz is required, configure the following parameters in the corresponding ",(0,s.jsx)(n.code,{children:"i2c4"})," node in the board's DTS:"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:'...\n&i2c4 {\n\tstatus = "okay";\n\tpinctrl-names = "default";\n\tpinctrl-0 = <&pinctrl_i2c4>;\n\tclock-frequency = <3400000>;\n\ti2c-scl-falling-time-ns = <78>;\n\ti2c-sda-falling-time-ns = <78>;\n}\n...\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If you need to use 1MHz, configure the following parameters in the corresponding ",(0,s.jsx)(n.code,{children:"i2c4"})," node in the board's DTS:"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:'...\n&i2c4 {\n\tstatus = "okay";\n\tpinctrl-names = "default";\n\tpinctrl-0 = <&pinctrl_i2c4>;\n\tclock-frequency = <1000000>;\n\ti2c-scl-falling-time-ns = <60>;\n\ti2c-sda-falling-time-ns = <60>;\n}\n...\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If you need to use 400kHz, configure the following parameters in the corresponding ",(0,s.jsx)(n.code,{children:"i2c4"})," node in the board's DTS:"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:'...\n&i2c4 {\n\tstatus = "okay";\n\tpinctrl-names = "default";\n\tpinctrl-0 = <&pinctrl_i2c4>;\n\tclock-frequency = <400000>;\n\ti2c-scl-falling-time-ns = <190>;\n}\n...\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)("font",{color:"red",children:"Note:"}),' The parameters "i2c-scl-falling-time-ns" and "i2c-sda-falling-time-ns" may need to be adjusted using an oscilloscope depending on the PCB design. The above configurations assume that the I2C IO has pull-up enabled and that a 1k pull-up resistor is used on the board.']}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"I2C DMA Configuration"})}),"\n",(0,s.jsx)(n.p,{children:"To configure I2C to use DMA, refer to the following DTS configuration:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dts",children:'&i2c4 {\n    dma-enable = <1>;  // Enable DMA for I2C\n};\n\n```c\n&i2c4 {\n \tstatus = "okay";\n \tpinctrl-names = "default";\n \tpinctrl-0 = <&pinctrl_i2c4>;\n\tdma-names = "tx", "rx";\n\tdmas = <&axi_dmac 19>, <&axi_dmac 18>;\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"})," I2C7 is located in the DSP subsystem. In the DTS, DMA needs to be bound to the DSP subsystem's DMA:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:'&i2c4 {\n \tstatus = "okay";\n \tpinctrl-names = "default";\n \tpinctrl-0 = <&pinctrl_i2c4>;\n\tdma-names = "tx", "rx";\n\tdmas = <&dsp_axi_dma 31>, <&dsp_axi_dma 30>;\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"I2C DMA Handshake List:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"I2C"}),(0,s.jsx)(n.th,{children:"RX"}),(0,s.jsx)(n.th,{children:"TX"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"I2C0"}),(0,s.jsx)(n.td,{children:"10"}),(0,s.jsx)(n.td,{children:"11"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"I2C1"}),(0,s.jsx)(n.td,{children:"12"}),(0,s.jsx)(n.td,{children:"13"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"I2C2"}),(0,s.jsx)(n.td,{children:"14"}),(0,s.jsx)(n.td,{children:"15"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"I2C3"}),(0,s.jsx)(n.td,{children:"16"}),(0,s.jsx)(n.td,{children:"17"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"I2C4"}),(0,s.jsx)(n.td,{children:"18"}),(0,s.jsx)(n.td,{children:"19"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"I2C5"}),(0,s.jsx)(n.td,{children:"39"}),(0,s.jsx)(n.td,{children:"40"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"I2C6"}),(0,s.jsx)(n.td,{children:"41"}),(0,s.jsx)(n.td,{children:"42"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"I2C7"}),(0,s.jsx)(n.td,{children:"30"}),(0,s.jsx)(n.td,{children:"31"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"user-space",children:"User Space"}),"\n",(0,s.jsxs)(n.p,{children:["Normally, I2C devices are controlled by the kernel driver, but all devices on the bus can also be accessed from user space via the ",(0,s.jsx)(n.code,{children:"/dev/i2c-%d"})," interface. For detailed information, refer to the ",(0,s.jsx)(n.code,{children:"Documentation/i2c/dev-interface"})," file in the Kernel."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Open Source Tool: i2c-tools"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"i2c-tools"})," is a set of open-source tools that have been cross-compiled and included in the rootfs of the X3J3 system software. Customers can use these tools directly:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"i2cdetect"})," \u2014 Used to list all I2C buses and the devices on them."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"i2cdump"})," \u2014 Displays all register values of an I2C device."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"i2cget"})," \u2014 Reads the value of a specific register of an I2C device."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"i2cset"})," \u2014 Writes a value to a specific register of an I2C device."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"i2ctransfer"})," \u2014 Allows reading and writing multiple registers of an I2C device."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,d.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}}}]);