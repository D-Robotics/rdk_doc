"use strict";(self.webpackChunkrdk_doc=self.webpackChunkrdk_doc||[]).push([[1703],{19046:(t,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>o,default:()=>j,frontMatter:()=>i,metadata:()=>e,toc:()=>c});const e=JSON.parse('{"id":"Advanced_development/toolchain_development/intermediate/supported_op_list","title":"supported_op_list","description":"Supported Operator Lists and Restrictions","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/07_Advanced_development/04_toolchain_development/intermediate/supported_op_list.md","sourceDirName":"07_Advanced_development/04_toolchain_development/intermediate","slug":"/Advanced_development/toolchain_development/intermediate/supported_op_list","permalink":"/rdk_doc/en/Advanced_development/toolchain_development/intermediate/supported_op_list","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1771043926000,"sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Principles and Steps of PTQ","permalink":"/rdk_doc/en/Advanced_development/toolchain_development/intermediate/ptq_process"},"next":{"title":"On-board Model Application Development Guide","permalink":"/rdk_doc/en/Advanced_development/toolchain_development/intermediate/runtime_sample"}}');var d=n(74848),r=n(28453);const i={sidebar_position:3},o=void 0,l={},c=[{value:"Supported Operator Lists and Restrictions",id:"supported_op_list_and_restrictions",level:2},{value:"Limitations and Notes",id:"limitations-and-notes",level:3},{value:"RDK X3 List of supported Caffe operators",id:"rdk-x3-list-of-supported-caffe-operators",level:2},{value:"RDK X3 List of supported ONNX operators",id:"rdk-x3-list-of-supported-onnx-operators",level:2},{value:"RDK Ultra Supported Caffe Operators List",id:"rdk-ultra-supported-caffe-operators-list",level:2},{value:"RDK Ultra-supported ONNX Operators List",id:"rdk-ultra-supported-onnx-operators-list",level:2}];function x(t){const s={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...t.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(s.h2,{id:"supported_op_list_and_restrictions",children:"Supported Operator Lists and Restrictions"}),"\n",(0,d.jsx)(s.h3,{id:"limitations-and-notes",children:"Limitations and Notes"}),"\n",(0,d.jsxs)(s.p,{children:["This section primarily covers the operators supported by the D-Robotics Processor for both ",(0,d.jsx)(s.code,{children:"Caffe"})," and ",(0,d.jsx)(s.code,{children:"ONNX"}),". Operators not listed are currently unsupported due to hardware limitations on the BPU."]}),"\n",(0,d.jsx)(s.p,{children:(0,d.jsx)(s.strong,{children:"Terminology:"})}),"\n",(0,d.jsxs)(s.ul,{children:["\n",(0,d.jsxs)(s.li,{children:[(0,d.jsx)(s.strong,{children:"BPU Acceleration"}),": Operators that the D-Robotics Processor can accelerate under certain constraints; if not met, they will be computed on the CPU."]}),"\n",(0,d.jsxs)(s.li,{children:[(0,d.jsx)(s.strong,{children:"CPU Computation"}),": Operators already optimized on D-Robotics's ARM CPU, supporting ONNX opsets 10 and 11."]}),"\n",(0,d.jsxs)(s.li,{children:[(0,d.jsx)(s.strong,{children:"CPU Computation\u203b"}),": Temporary CPU operators not yet integrated."]}),"\n"]}),"\n",(0,d.jsx)(s.p,{children:(0,d.jsx)(s.strong,{children:"Additional Considerations:"})}),"\n",(0,d.jsxs)(s.ul,{children:["\n",(0,d.jsxs)(s.li,{children:["\n",(0,d.jsx)(s.p,{children:"For all BPU in RDK X3, there is a general restriction: input_batch \u2264 128."}),"\n"]}),"\n",(0,d.jsxs)(s.li,{children:["\n",(0,d.jsx)(s.p,{children:"On RDK Ultra BPU, restrictions apply:"}),"\n",(0,d.jsxs)(s.ol,{children:["\n",(0,d.jsx)(s.li,{children:"Input and output dimensions must be 4D; support for non-four-dimensional ops is indicated explicitly."}),"\n",(0,d.jsx)(s.li,{children:"Shape: H, W, C \u2208 [1, 65536], N \u2264 4096; and N x C x H x W \u2264 1GB."}),"\n",(0,d.jsx)(s.li,{children:"Supports Caffe 1.0 base operators and common extended operators, as well as ONNX opsets 10 and 11. Ops not meeting BPU acceleration constraints fallback to ARM CPU."}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(s.li,{children:["\n",(0,d.jsxs)(s.p,{children:["Operators like ",(0,d.jsx)(s.code,{children:"Cast"}),", ",(0,d.jsx)(s.code,{children:"Constant"}),", ",(0,d.jsx)(s.code,{children:"Dropout"}),", ",(0,d.jsx)(s.code,{children:"Reshape"}),", ",(0,d.jsx)(s.code,{children:"Squeeze"}),", ",(0,d.jsx)(s.code,{children:"Unsqueeze"}),", and ",(0,d.jsx)(s.code,{children:"Shape"})," (OPs) cannot run directly on the BPU, but algorithmic toolchains may optimize them in some cases (e.g., constant folding) for support."]}),"\n"]}),"\n",(0,d.jsxs)(s.li,{children:["\n",(0,d.jsx)(s.p,{children:"Operators marked as PyTorch are officially unsupported opsets 11 ops, which D-Robotics's algorithm toolchain provides a script to export from PyTorch to custom ONNX ops."}),"\n"]}),"\n",(0,d.jsxs)(s.li,{children:["\n",(0,d.jsxs)(s.p,{children:["Tensorflow-onnx conversion tool (",(0,d.jsx)(s.a,{href:"https://github.com/onnx/tensorflow-onnx",children:"https://github.com/onnx/tensorflow-onnx"}),") supports converting TensorFlow 1.x operators to stable ONNX opsets 6-11, but TensorFlow 2.x support is still experimental."]}),"\n"]}),"\n",(0,d.jsxs)(s.li,{children:["\n",(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.strong,{children:"Quantization Details"}),": A compliant operator may still run on CPU due to being a passively quantized OP. The algorithm toolchain designs quantization logic based on the OP's computation characteristics and BPU low-level logic. For more information on active, passive, and manual quantization, see the \"",(0,d.jsx)(s.a,{href:"https://developer.d-robotics.cc/forumDetail/118364000835765793",children:"Quantization Logic in Algorithm Toolchain"}),'" chapter.']}),"\n"]}),"\n"]}),"\n",(0,d.jsx)(s.h2,{id:"rdk-x3-list-of-supported-caffe-operators",children:"RDK X3 List of supported Caffe operators"}),"\n",(0,d.jsxs)(s.table,{children:[(0,d.jsx)(s.thead,{children:(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.th,{children:(0,d.jsx)(s.strong,{children:"Caffe Operator Name"})}),(0,d.jsx)(s.th,{children:(0,d.jsx)(s.strong,{children:"CPU Computing/BPU Acceleration"})}),(0,d.jsx)(s.th,{children:(0,d.jsx)(s.strong,{children:"X3 BPU Constraints"})}),(0,d.jsx)(s.th,{children:(0,d.jsx)(s.strong,{children:"CPU Constraints"})})]})}),(0,d.jsxs)(s.tbody,{children:[(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Convolution"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsxs)(s.td,{children:["Kernel Size: HxW = [1, 7]x[1, 7] for BPU",(0,d.jsx)("br",{})," ",(0,d.jsx)(s.code,{children:"Channel limit: <= 2048 (for non-dilated, group, depthwise conv), or <= 4096 for standard convs"}),(0,d.jsx)("br",{})," No stride limit",(0,d.jsx)("br",{})," Dilation: only powers of 2 allowed, divisible by stride",(0,d.jsx)("br",{})," ",(0,d.jsx)(s.code,{children:"h_dilated <= w_dilated"}),(0,d.jsx)("br",{})," ",(0,d.jsx)(s.code,{children:"Total kernel size: HxWxC <= 32768"}),(0,d.jsx)("br",{})," axis not supported (default: 1)"]}),(0,d.jsxs)(s.td,{children:["4D Conv only",(0,d.jsx)("br",{})," auto_pad not supported",(0,d.jsx)("br",{}),"Type constraints: float, int32, int8",(0,d.jsx)("br",{}),"Pads constraint: [Hstart, Wstart, Hend, Wend] (4 elements) with Hstart == Hend and Wstart == Wend"]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Deconvolution"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsxs)(s.td,{children:["Kernel Size: HxW = [2, 14]x[2, 14]",(0,d.jsx)("br",{}),(0,d.jsx)(s.code,{children:"Channel limit: C <= 2048"}),(0,d.jsx)("br",{}),"Padding: HxW = [0, (Kernel_H-1)/2]x[0, (Kernel_W-1)/2]",(0,d.jsx)("br",{}),(0,d.jsx)(s.code,{children:"Stride: Stride \u2208 {2, 4}, stride_h \u2264 stride_w"}),(0,d.jsx)("br",{}),"Dilation: (1, 1)",(0,d.jsx)("br",{}),"No axis support"]}),(0,d.jsxs)(s.td,{children:["output_shape and output_padding unsupported",(0,d.jsx)("br",{}),"auto_pad: NOTSET only",(0,d.jsx)("br",{}),"No axis support"]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"MaxUnpool"}),(0,d.jsx)(s.td,{children:"CPU Computing"}),(0,d.jsx)(s.td,{children:"---"}),(0,d.jsxs)(s.td,{children:["from_type constraints: X - float only, I - Tensor(int64)",(0,d.jsx)("br",{}),"to_type constraints: float only"]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Pooling"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsxs)(s.td,{children:["Four types: MaxPooling, AveragePooling, GlobalMaxPooling, GlobalAveragePooling",(0,d.jsx)("br",{}),"Constraints: ",(0,d.jsx)("br",{}),(0,d.jsx)(s.code,{children:"MaxPooling: Kernel Size = [1, 64]x[1, 64], Stride = [1, 185], Padding >= 0"}),(0,d.jsx)("br",{}),"AveragePooling: HxW = [1, 7]x[1, 7], Stride \u2208 ",185,(0,d.jsx)("br",{}),(0,d.jsx)(s.code,{children:"GlobalAveragePooling: HxW <= 8192 for NCHW input"}),(0,d.jsx)("br",{}),"GlobalMaxPooling: HxW = [1, 1024]x[1, 1024] for NCHW input"]}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"SPP"}),(0,d.jsx)(s.td,{children:"CPU Computing"}),(0,d.jsx)(s.td,{children:"Not supported"}),(0,d.jsxs)(s.td,{children:[(0,d.jsx)(s.code,{children:"pyramid_height: 2^n pooling, n < 7"}),(0,d.jsx)("br",{}),(0,d.jsx)(s.code,{children:"pooling kernel size <= 255"}),(0,d.jsx)("br",{}),"pool option: ",1]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"InnerProduct"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsxs)(s.td,{children:["Converted to Conv",(0,d.jsx)("br",{}),"Constraints: ",(0,d.jsx)("br",{}),(0,d.jsx)(s.code,{children:"For NCHW input, if HW < 7, Gemm limits same as Conv"}),(0,d.jsx)("br",{}),(0,d.jsx)(s.code,{children:"H = W = 1: C limit <= 16384; otherwise, C limit <= 2048"}),(0,d.jsx)("br",{}),(0,d.jsx)(s.code,{children:"Low-precision int8 output after BPU node: H x W/8 x C/4 \u2264 1024"}),(0,d.jsx)("br",{}),(0,d.jsx)(s.code,{children:"High-precision int32 output: H x W/8 x C/4 < 2048"}),(0,d.jsx)("br",{}),"No axis support"]}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"LRN"}),(0,d.jsx)(s.td,{children:"CPU Computing"}),(0,d.jsx)(s.td,{children:"Not supported"}),(0,d.jsxs)(s.td,{children:["local_size supported",(0,d.jsx)("br",{}),"alpha, beta supported",(0,d.jsx)("br",{}),"norm_region: ACROSS_CHANNELS, WITHIN_CHANNEL (optional)",(0,d.jsx)("br",{}),"k supported"]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"MVN"}),(0,d.jsx)(s.td,{children:"CPU Computing"}),(0,d.jsx)(s.td,{children:"Not supported"}),(0,d.jsxs)(s.td,{children:[(0,d.jsx)(s.code,{children:" normalize_variance: {0, 1} (optional)"}),(0,d.jsx)("br",{}),(0,d.jsx)(s.code,{children:"across_channels: {0, 1} (optional)"}),(0,d.jsx)("br",{}),"Float32 only"]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"BatchNorm"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsx)(s.td,{children:"Unlimited"}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ELU"}),(0,d.jsx)(s.td,{children:"CPU Computing"}),(0,d.jsx)(s.td,{children:"Not supported"}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"BNLL"}),(0,d.jsx)(s.td,{children:"CPU Computing"}),(0,d.jsx)(s.td,{children:"Not supported"}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"PReLU"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsx)(s.td,{children:"Unlimited"}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ReLU/LeakyReLu"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsx)(s.td,{children:"Unlimited"}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Sigmoid"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsxs)(s.td,{children:[(0,d.jsx)(s.code,{children:"For 1CHW tensor: min(8W4C-aligned shape, 32C-aligned shape) \u2264 8192"}),(0,d.jsx)("br",{}),"8W4C: pad W to multiples of 8, C to multiples of 4",(0,d.jsx)("br",{}),"32C: pad C to multiples of 32",(0,d.jsx)("br",{}),"Use the smaller aligned shape"]}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"TanH"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsx)(s.td,{children:"Unlimited"}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Eltwise"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsxs)(s.td,{children:["Operation supports Add and Mul, no Sub",(0,d.jsx)("br",{}),(0,d.jsx)(s.code,{children:"Add: M \u2264 2048 channels"}),(0,d.jsx)("br",{}),"Supported cases: ",(0,d.jsx)("br",{}),"1. NCHW vs NCHW",(0,d.jsx)("br",{}),"2. NCHW vs NC11 (inputs must be op outputs)",(0,d.jsx)("br",{}),(0,d.jsx)(s.code,{children:"Mul: Both inputs must be 4D, C \u2264 2048"}),(0,d.jsx)("br",{}),"Supported shapes: ",(0,d.jsx)("br",{}),"1. (1xCxHxW vs 1xCxHxW)",(0,d.jsx)("br",{}),"2. (1xCxHxW vs 1xCx1x1)",(0,d.jsx)("br",{}),"3. (1xCxHxW vs 1x1x1x1)"]}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Bias"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsx)(s.td,{children:"Refer to Eltwise (Add) constraints"}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Scale"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsx)(s.td,{children:"Refer to Eltwise (Mul) constraints"}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"AbsVal"}),(0,d.jsx)(s.td,{children:"CPU Computing"}),(0,d.jsx)(s.td,{children:"Not supported"}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Exp"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsx)(s.td,{children:"Unlimited"}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Log"}),(0,d.jsx)(s.td,{children:"CPU Computing"}),(0,d.jsx)(s.td,{children:"Not supported"}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Power"}),(0,d.jsx)(s.td,{children:"BPU"}),(0,d.jsx)(s.td,{children:"Unlimited"}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Threshold"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"Not supported"}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Reduction"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"Not supported"}),(0,d.jsxs)(s.td,{children:["Operation supports SUM, ASUM, SUMSQ, MEAN. ",(0,d.jsx)("br",{}),"Axis supports. ",(0,d.jsx)("br",{}),"Only supports Float32 calculations."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Softmax"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"Not supported"}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ArgMax"}),(0,d.jsx)(s.td,{children:"BPU"}),(0,d.jsxs)(s.td,{children:[(0,d.jsx)(s.code,{children:"Only supports axis=1 and c<=64."})," ",(0,d.jsx)("br",{}),"Does not support top_k != 1"]}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Concat"}),(0,d.jsx)(s.td,{children:"BPU"}),(0,d.jsxs)(s.td,{children:["Input/Output Channel: ",(0,d.jsx)(s.code,{children:"C<=2048"})]}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Split"}),(0,d.jsx)(s.td,{children:"BPU"}),(0,d.jsx)(s.td,{children:"Unlimited"}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Slice"}),(0,d.jsx)(s.td,{children:"BPU"}),(0,d.jsx)(s.td,{children:"Unlimited"}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Reshape"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"Not supported (can be fused in some scenarios)"}),(0,d.jsxs)(s.td,{children:["Shape supports up to [1,4] shape_dim configurations. ",(0,d.jsx)("br",{}),"Axis supports [-4,3]. No support for N dimensions. Default value is 0, follows Caffe rules."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Flatten"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"Not supported (can be fused in some scenarios)"}),(0,d.jsx)(s.td,{children:"Axis range [-4,3], default is 1, -4 and 0 have the same meaning. Only supports End_axis == -1."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Crop"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"Not supported"}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Dropout"}),(0,d.jsx)(s.td,{children:"BPU"}),(0,d.jsx)(s.td,{children:"Unlimited"}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"LSTM"}),(0,d.jsx)(s.td,{children:"BPU"}),(0,d.jsx)(s.td,{children:"Only supports batch=1"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Normalize"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"Not supported"}),(0,d.jsx)(s.td,{children:"Type constraint: only supports float type."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"PassThrough"}),(0,d.jsx)(s.td,{children:"BPU"}),(0,d.jsxs)(s.td,{children:["Supports mode=DCR and mode=CRD. ",(0,d.jsx)("br",{}),"Only supports rearrangement in H and W directions with blocksize=2."]}),(0,d.jsx)(s.td,{children:"Type constraint: only supports float type."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"CReLU"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"Not supported"}),(0,d.jsx)(s.td,{children:"Type constraint: only supports float type."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"RReLU"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"Not supported"}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Permute"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"Not supported"}),(0,d.jsxs)(s.td,{children:["- Supports nhwc2nchw, perm: [0, 3, 1, 2]. ",(0,d.jsx)("br",{})," - Supports nchw2nhwc, perm: [0, 2, 3, 1]. ",(0,d.jsx)("br",{})," - Supports specified perm dimension conversions, data types: float, int8, int32."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"MatMul"}),(0,d.jsx)(s.td,{children:"BPU"}),(0,d.jsxs)(s.td,{children:["Optimized for specific scenarios: ",(0,d.jsx)("br",{}),"- K vs KxN, K vs 1xKxN, K vs 1x1xKxN",(0,d.jsx)("br",{}),"- MxK vs K, MxK vs KxN, MxK vs 1x1xKxN",(0,d.jsx)("br",{}),"- 1xMxK vs K, 1xMxK vs 1xKxN",(0,d.jsx)("br",{}),"- 1x1xMxK vs K, 1x1xMxK vs 1xKxN, 1x1xMxK vs 1x1xKxN",(0,d.jsx)("br",{}),"- BxMxK vs KxN (B>=1)",(0,d.jsx)("br",{}),"- 1xBxMxK vs KxN (B>=1)",(0,d.jsx)("br",{}),"- AxBxMxK vs KxN (A>1, B>1)",(0,d.jsx)("br",{}),"For the opposite scenario: ",(0,d.jsx)("br",{}),"- 1xBxMxK vs 1x1xKxN (B>1)",(0,d.jsx)("br",{}),"Optimized for two featuremaps: ",(0,d.jsx)("br",{}),"- 1xBxMxK vs 1x1xKxN (B>=1)"]}),(0,d.jsx)(s.td,{children:"Type constraint: only supports float type."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Upsample"}),(0,d.jsx)(s.td,{children:"BPU"}),(0,d.jsxs)(s.td,{children:[(0,d.jsx)(s.code,{children:"Input featuremap must be 4D NCHW, resize only on H and W dimensions, factors must be 2^N."})," ",(0,d.jsx)("br",{}),(0,d.jsx)(s.code,{children:"Supports different factors for H and W, but H_factor <= W_factor required."})]}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ROIPooling"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"Not supported"}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"PSROIPooling"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"Not supported"}),(0,d.jsx)(s.td,{children:"None"})]})]})]}),"\n",(0,d.jsx)(s.h2,{id:"rdk-x3-list-of-supported-onnx-operators",children:"RDK X3 List of supported ONNX operators"}),"\n",(0,d.jsxs)(s.table,{children:[(0,d.jsx)(s.thead,{children:(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.th,{children:(0,d.jsx)(s.strong,{children:"ONNX Operator Name"})}),(0,d.jsx)(s.th,{children:(0,d.jsx)(s.strong,{children:"CPU Computing/BPU Acceleration"})}),(0,d.jsx)(s.th,{children:(0,d.jsx)(s.strong,{children:"X3 BPU Constraints"})}),(0,d.jsx)(s.th,{children:(0,d.jsx)(s.strong,{children:"CPU Constraints"})})]})}),(0,d.jsxs)(s.tbody,{children:[(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Abs"}),(0,d.jsx)(s.td,{children:"CPU Calculation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Type constraint: only supports float type."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Acos"}),(0,d.jsx)(s.td,{children:"CPU Calculation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Type constraint: only supports float type."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Acosh"}),(0,d.jsx)(s.td,{children:"CPU Calculation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Type constraint: only supports float type."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Add"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsxs)(s.td,{children:[(0,d.jsx)(s.code,{children:"M <= 2048, supported cases:"}),(0,d.jsx)("br",{}),"1. NCHW and NCHW shapes for both inputs.",(0,d.jsx)("br",{}),"2. NCHW and NC11 shapes (both inputs need to be outputs of other ops).",(0,d.jsx)("br",{}),"3. Integrated into the previous conv in ResNet's shortcut structure for acceleration."]}),(0,d.jsxs)(s.td,{children:["- Supports same shape inputs calculation.",(0,d.jsx)("br",{}),"- Supports scalar input 1 or input 2 calculation.",(0,d.jsx)("br",{}),"- Supports broadcast calculation with a max dimension of 5."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"And"}),(0,d.jsx)(s.td,{children:"CPU Calculation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsxs)(s.td,{children:["- Supports same shape inputs calculation.",(0,d.jsx)("br",{}),"- Supports scalar input 1 or input 2 calculation.",(0,d.jsx)("br",{}),"- Supports broadcast calculation with a max dimension of 5."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ArgMax"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsxs)(s.td,{children:["1. Four-dimensional input (NCHW).",(0,d.jsx)("br",{}),"2. Only supports argmax along the C dimension (axis=1).",(0,d.jsx)("br",{}),"3.",(0,d.jsx)(s.code,{children:"C <= 64"})]}),(0,d.jsx)(s.td,{children:"Type constraint: only supports float type."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ArgMin"}),(0,d.jsx)(s.td,{children:"CPU Calculation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Type constraint: only supports float type."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Asin"}),(0,d.jsx)(s.td,{children:"CPU Calculation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Type constraint: only supports float type."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Asinh"}),(0,d.jsx)(s.td,{children:"CPU Calculation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Type constraint: only supports float type."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Atan"}),(0,d.jsx)(s.td,{children:"CPU Calculation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Type constraint: only supports float type."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Atanh"}),(0,d.jsx)(s.td,{children:"CPU Calculation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Type constraint: only supports float type."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"AveragePool"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsxs)(s.td,{children:["Kernel HxW: [1, 7]x[1, 7], Stride \u2208",185]}),(0,d.jsxs)(s.td,{children:["auto_pad attribute not supported.",(0,d.jsx)("br",{}),"Only supports four-dimensional tensors."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"BatchNormalization"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsx)(s.td,{children:"Optimized to fuse with previous conv"}),(0,d.jsxs)(s.td,{children:["Type constraint: only supports float type.",(0,d.jsx)("br",{}),"Supports channel-first data layout (dim=1)."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"BitShift"}),(0,d.jsx)(s.td,{children:"CPU Calculation(*)"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Cast"}),(0,d.jsx)(s.td,{children:"CPU Calculation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsxs)(s.td,{children:["from_type supports double, float, bool, int64, uint32, int32, uint16, int16, uint8, int8.",(0,d.jsx)("br",{}),"to_type supports double, float, bool, int64, uint32, int32, uint16, int16, uint8, int8."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Ceil"}),(0,d.jsx)(s.td,{children:"CPU Calculation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Type constraint: only supports float type."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Clip"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsx)(s.td,{children:"Unlimited"}),(0,d.jsxs)(s.td,{children:["Type constraint: only supports float type.",(0,d.jsx)("br",{}),"Default min parameter when two inputs are provided."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Compress"}),(0,d.jsx)(s.td,{children:"CPU Calculation(*)"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Concat"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"Input/Output Channel: C<=2048"})}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ConcatFromSequence"}),(0,d.jsx)(s.td,{children:"CPU Calculation(*)"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Constant"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsx)(s.td,{children:"Optimized through constant folding"}),(0,d.jsxs)(s.td,{children:["No support for sparse_tensor attribute.",(0,d.jsx)("br",{}),"Type constraint: only supports float type."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ConstantOfShape"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsx)(s.td,{children:"Optimized through constant folding"}),(0,d.jsx)(s.td,{children:"Supported types: float, int32, int8."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Conv"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsxs)(s.td,{children:["Kernel HxW: [1, 7]x[1, 7].",(0,d.jsx)("br",{}),(0,d.jsx)(s.code,{children:"Input/output Channel (for one group): <= 2048 (relaxed to <=4096 for non-dilated, group, depthwise conv)."}),(0,d.jsx)("br",{}),"Stride: Unrestricted (except stride=1 for Conv followed by Add in ResNet shortcut-connecting).",(0,d.jsx)("br",{}),"Dilation: Only powers of 2 allowed, divisible by stride.",(0,d.jsx)("br",{}),(0,d.jsx)(s.code,{children:"h_dilated \u2264 w_dilated."}),(0,d.jsx)("br",{}),(0,d.jsx)(s.code,{children:"Total kernel size limit: HxWxC \u2264 32768"})]}),(0,d.jsxs)(s.td,{children:["Only supports 4D Convolution.",(0,d.jsx)("br",{}),"auto_pad attribute not supported.",(0,d.jsx)("br",{}),"Type constraint: float, int32, int8.",(0,d.jsx)("br",{}),"Pads constraint: [Hstart, Wstart, Hend, Wend] (4 elements) with Hstart==Hend and Wstart==Wend."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ConvInteger"}),(0,d.jsx)(s.td,{children:"CPU Calculation(*)"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ConvTranspose"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsxs)(s.td,{children:["Kernel HxW: [2, 14]x[2, 14].",(0,d.jsx)("br",{}),(0,d.jsx)(s.code,{children:"Input/output Channel: C <= 2048."}),(0,d.jsx)("br",{}),"Padding HxW: [0,(Kernel_H-1)/2]x[0,(Kernel_W-1)/2].",(0,d.jsx)("br",{}),"Stride: ",4,".",(0,d.jsx)("br",{}),(0,d.jsx)(s.code,{children:"stride_h \u2264 stride_w"}),".",(0,d.jsx)("br",{}),"Dilation: (1, 1) only"]}),(0,d.jsxs)(s.td,{children:["auto_pad attribute not supported.",(0,d.jsx)("br",{}),"Type constraint: float, int32, int8."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Cos"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"Limited to CxHxW <= 8192 for 1CHW tensor"})}),(0,d.jsx)(s.td,{children:"Type constraint: only supports float type."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Cosh"}),(0,d.jsx)(s.td,{children:"CPU Calculation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Type constraint: only supports float type."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"CumSum"}),(0,d.jsx)(s.td,{children:"CPU Calculation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]})]})]}),"\n",(0,d.jsxs)(s.table,{children:[(0,d.jsx)(s.thead,{children:(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.th,{children:"Operator: from_type:"}),(0,d.jsx)(s.th,{children:"Description: BPU Acceleration"}),(0,d.jsx)(s.th,{children:"Supported Modes"}),(0,d.jsx)(s.th,{children:"Input Shape Constraints"}),(0,d.jsx)(s.th,{children:"Output Type Constraints"})]})}),(0,d.jsxs)(s.tbody,{children:[(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"DepthToSpace"}),(0,d.jsx)(s.td,{children:"BPU acceleration"}),(0,d.jsx)(s.td,{children:"Supports DCR and CRD modes."}),(0,d.jsx)(s.td,{children:"Only supports rearrangement along H and W dimensions with blockSize=2."}),(0,d.jsxs)(s.td,{children:[(0,d.jsx)("br",{}),"- from_type: only float types allowed.",(0,d.jsx)("br",{}),"- 4D Tensor computation only.",(0,d.jsx)("br",{}),"- to_type: only float types allowed.",(0,d.jsx)("br",{}),"- 4D Tensor computation only."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"DequantizeLinear"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Det"}),(0,d.jsx)(s.td,{children:"CPU computation\u203b"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Div"}),(0,d.jsx)(s.td,{children:"BPU acceleration"}),(0,d.jsxs)(s.td,{children:["1. Supports featuremap inputs only (no constant inputs).",(0,d.jsx)("br",{}),"2. Input shape constraints refer to Mul operator."]}),(0,d.jsxs)(s.td,{children:["- Same input shape supported.",(0,d.jsx)("br",{}),"- Supports scalar input1 or input2.",(0,d.jsx)("br",{}),"- Broadcast calculation up to 5 dimensions."]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Dropout"}),(0,d.jsx)(s.td,{children:"BPU acceleration"}),(0,d.jsx)(s.td,{children:"Not computed in inference, removed by optimization."}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Einsum"}),(0,d.jsx)(s.td,{children:"CPU computation\u203b"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Elu"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Type constraint: only float types."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Equal"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsxs)(s.td,{children:["- Same input shape supported.",(0,d.jsx)("br",{}),"- Supports scalar input1 or input2.",(0,d.jsx)("br",{}),"- Broadcast calculation up to 5 dimensions."]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Erf"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Type constraint: supports float and double types."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Exp"}),(0,d.jsx)(s.td,{children:"BPU acceleration"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Type constraint: only float types."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Expand"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"EyeLike"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Flatten"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Floor"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Type constraint: only float types."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"GRU"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsxs)(s.td,{children:["- direction attribute supports forward only.",(0,d.jsx)("br",{}),"- Type constraint: only float types.",(0,d.jsx)("br",{}),"- Input count must be 3, 4, or 6.",(0,d.jsx)("br",{}),"- Output count is 2."]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Gather"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsxs)(s.td,{children:["from_type:",(0,d.jsx)("br",{}),"- input: types supported: float, int64, int32, int8, uint64, uint32, uint8.",(0,d.jsx)("br",{}),"- indices: type supported: int32, int64.",(0,d.jsx)("br",{}),"- to_type: types supported: float, int64, int32, int8, uint64, uint32, uint8."]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"GatherElements"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"GatherND"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsxs)(s.td,{children:["from_type:",(0,d.jsx)("br",{}),"- input: types supported: float, int32, int8.",(0,d.jsx)("br",{}),"- indices: tensor(int64).",(0,d.jsx)("br",{}),"- to_type: types supported: float, int32, int8."]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Gemm"}),(0,d.jsx)(s.td,{children:"BPU acceleration"}),(0,d.jsx)(s.td,{children:"Converted to Conv implementation."}),(0,d.jsxs)(s.td,{children:[(0,d.jsx)("br",{}),"- ",(0,d.jsx)(s.code,{children:"HW <= 7 for both H and W if both are <= 7."}),(0,d.jsx)("br",{}),"- ",(0,d.jsx)(s.code,{children:"C <= 16384 if H/W = 1; otherwise, C <= 2048."}),(0,d.jsx)("br",{}),"- ",(0,d.jsx)(s.code,{children:"Low-precision int8 output if followed by BPU-supported node: H x W/8 x C/4 <= 1024."}),(0,d.jsx)("br",{}),"- ",(0,d.jsx)(s.code,{children:"High-precision int32 output if followed by non-BPU-supported node: H x W/8 x C/4 < 2048."}),(0,d.jsx)("br",{}),"- Type constraint: only float types."]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"GlobalAveragePool"}),(0,d.jsx)(s.td,{children:"BPU acceleration"}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"Input HxW must be <= 8192 for NCHW shape."})}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"GlobalLpPool"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsxs)(s.td,{children:["Type constraint: supports float and double types.",(0,d.jsx)("br",{}),"- 4D Tensor computation only."]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"GlobalMaxPool"}),(0,d.jsx)(s.td,{children:"BPU acceleration"}),(0,d.jsx)(s.td,{children:"Input HxW range: [1, 1024]x[1, 1024] for NCHW shape."}),(0,d.jsxs)(s.td,{children:["Type constraint: only float types.",(0,d.jsx)("br",{}),"- 4D Tensor only."]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Greater"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsxs)(s.td,{children:["- Same input shape supported.",(0,d.jsx)("br",{}),"- Supports scalar input1 or input2.",(0,d.jsx)("br",{}),"- Broadcast calculation up to 5 dimensions."]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"HardSigmoid"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Type constraint: only float types."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Hardmax"}),(0,d.jsx)(s.td,{children:"CPU computation\u203b"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Identity"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"If"}),(0,d.jsx)(s.td,{children:"CPU computation\u203b"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"InstanceNormalization"}),(0,d.jsx)(s.td,{children:"CPU Calculation"}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"IsInf"}),(0,d.jsx)(s.td,{children:"CPU Calculation"}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{children:"Only supports float type."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"IsNaN"}),(0,d.jsx)(s.td,{children:"CPU Calculation"}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{children:"Only supports float type."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"LRN"}),(0,d.jsx)(s.td,{children:"CPU Calculation"}),(0,d.jsx)(s.td,{children:"Only supports 4D Tensors and float type."}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"LSTM"}),(0,d.jsx)(s.td,{children:"BPU Accelerated"}),(0,d.jsx)(s.td,{children:"Supports batch_size=1 only."}),(0,d.jsx)(s.td,{children:"No attribute settings supported. Only supports inputs of 3, 4, or 8, and outputs of 2. Float type only."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"LeakyRelu"}),(0,d.jsx)(s.td,{children:"BPU Accelerated"}),(0,d.jsx)(s.td,{children:"N/A"}),(0,d.jsx)(s.td,{children:"N/A"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Less"}),(0,d.jsx)(s.td,{children:"CPU Calculation"}),(0,d.jsx)(s.td,{children:"Supports same input shape, scalar input1 or input2, and broadcast"}),(0,d.jsx)(s.td,{children:"Supports up to 5-dimensional broadcast with same input shapes, and scalar inputs."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"LessOrEqual"}),(0,d.jsx)(s.td,{children:"CPU Calculation"}),(0,d.jsx)(s.td,{children:"Same as 'Less'"}),(0,d.jsx)(s.td,{children:"Same as 'Less'."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Log"}),(0,d.jsx)(s.td,{children:"CPU Calculation"}),(0,d.jsx)(s.td,{children:"Only supports float type."}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"LogSoftmax"}),(0,d.jsx)(s.td,{children:"CPU Calculation"}),(0,d.jsx)(s.td,{children:"Only supports float type."}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Loop"}),(0,d.jsx)(s.td,{children:"CPU Calculation"}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"LpNormalization"}),(0,d.jsx)(s.td,{children:"CPU Calculation"}),(0,d.jsx)(s.td,{children:"p-norm only supports 1 or 2, double or float type."}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"LpPool"}),(0,d.jsx)(s.td,{children:"CPU Calculation"}),(0,d.jsx)(s.td,{children:"auto_pad not supported, double or float type, and 4D computation"}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"MatMulInteger"}),(0,d.jsx)(s.td,{children:"CPU Calculation"}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"MatMul"}),(0,d.jsx)(s.td,{children:"BPU Accelerated"}),(0,d.jsxs)(s.td,{children:["For scenarios where the two inputs are featuremap and weight, which involve element-wise multiplication between a featuremap and a constant, the following can be optimized for execution on a BPU:",(0,d.jsx)("br",{}),"- K vs KxN, K vs 1xKxN, K vs 1x1xKxN",(0,d.jsx)("br",{}),"- MxK vs K, MxK vs KxN, MxK vs 1x1xKxN",(0,d.jsx)("br",{}),"- 1xMxK vs K, 1xMxK vs 1xKxN",(0,d.jsx)("br",{}),"- 1x1xMxK vs K, 1x1xMxK vs 1xKxN, 1x1xMxK vs 1x1xKxN",(0,d.jsx)("br",{}),"- BxMxK vs KxN (where B >= 1)",(0,d.jsx)("br",{}),"- 1xBxMxK vs KxN (where B >= 1)",(0,d.jsx)("br",{}),"- AxBxMxK vs KxN (where A > 1 and B > 1)",(0,d.jsx)("br",{}),"For situations where both inputs are featuremaps (i.e., element-wise multiplication of featuremaps), the following can be optimized for the BPU:",(0,d.jsx)("br",{}),"- 1xBxMxK vs 1x1xKxN (where B >= 1)"]}),(0,d.jsx)(s.td,{children:"Only supports float type. Optimizations apply to specific input shapes: see details below."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Max"}),(0,d.jsx)(s.td,{children:"CPU Calculation"}),(0,d.jsx)(s.td,{children:"Supports multiple inputs, same shape, scalar inputs, and broadcast"}),(0,d.jsx)(s.td,{children:"Up to 5-dimensional broadcast, supports scalar inputs."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"MaxPool"}),(0,d.jsx)(s.td,{children:"BPU Accelerated"}),(0,d.jsx)(s.td,{children:"Kernel size [1-64]x[1-64], stride [1-185], padding >= 0, no dilation"}),(0,d.jsx)(s.td,{children:"dilation only supports 1x1, data row-major storage, no auto_pad or storage_order support, 4D Tensors only."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"MaxRoiPool"}),(0,d.jsx)(s.td,{children:"CPU Calculation"}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Mean"}),(0,d.jsx)(s.td,{children:"CPU Calculation"}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Min"}),(0,d.jsx)(s.td,{children:"CPU Calculation"}),(0,d.jsx)(s.td,{children:"Same as 'Max'"}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Mod"}),(0,d.jsx)(s.td,{children:"CPU Calculation"}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Mul"}),(0,d.jsx)(s.td,{children:"BPU Accelerated"}),(0,d.jsxs)(s.td,{children:[(0,d.jsx)(s.code,{children:"4D inputs with C <= 2048, specific shape rules apply"}),(0,d.jsx)("br",{}),"1. (1xCxHxW vs 1xCxHxW)\u3002",(0,d.jsx)("br",{}),"2. (1xCxHxW vs 1xCx1x1)\u3002",(0,d.jsx)("br",{}),"3. (1xCxHxW vs 1x1x1x1) \u3002"]}),(0,d.jsx)(s.td,{children:"Same broadcast constraints as 'Mul'. Input values must not be 0."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Multinomial"}),(0,d.jsx)(s.td,{children:"CPU Calculation"}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Neg"}),(0,d.jsx)(s.td,{children:"CPU Calculation"}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"NonZero"}),(0,d.jsx)(s.td,{children:"CPU Calculation"}),(0,d.jsx)(s.td,{children:"Supports float, int32, or int8 types, 1D or 4D computations"}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Not"}),(0,d.jsx)(s.td,{children:"CPU Calculation"}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"OneHot"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Or"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsxs)(s.td,{children:["Supports same input shape calculation. ",(0,d.jsx)("br",{}),"Supports scalar inputs. ",(0,d.jsx)("br",{}),"Broadcasting up to 5 dimensions."]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"PRelu"}),(0,d.jsx)(s.td,{children:"BPU"}),(0,d.jsxs)(s.td,{children:["- Type constraints: Only supports float type.",(0,d.jsx)("br",{}),"- from_type: X and slope.",(0,d.jsx)("br",{}),"- to_type: Y."]}),(0,d.jsxs)(s.td,{children:["- X's shape is data_shape, slope's is slope_shape.",(0,d.jsx)("br",{}),"- data_shape == slope_shape.",(0,d.jsx)("br",{}),"- slope_shape.ProdSize() == 1.",(0,d.jsx)("br",{}),"- NCHW layout for 4D tensors with equal N and C dimensions.",(0,d.jsx)("br",{}),"- HxW with 1x1 (slope_shape).",(0,d.jsx)("br",{}),"- HxW with Hx1 (slope_shape).",(0,d.jsx)("br",{}),"- HxW with 1xW (slope_shape).",(0,d.jsx)("br",{}),"- Special case: 4D X and 3D slope, with data_shape[1] == slope_shape[0], slope_shape[1] == 1, slope_shape[2] == 1."]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Pad"}),(0,d.jsx)(s.td,{children:"BPU"}),(0,d.jsxs)(s.td,{children:["Supports mode=Constant. ",(0,d.jsx)("br",{}),"Only supports padding on H, W dimensions."]}),(0,d.jsxs)(s.td,{children:["Pad-10: ",(0,d.jsx)("br",{}),"- Type constraint: float only.",(0,d.jsx)("br",{}),"- 4D NCHW tensors.",(0,d.jsx)("br",{}),"- pads constraint: len(pads) == 8, pads[i] >= 0, pads[0] = pads[1] = pads[4] = pads[5] = 0.",(0,d.jsx)("br",{}),"Pad-11: ",(0,d.jsx)("br",{}),"- from_type: data (float), pads (int64 tensor), optional constant_value (float).",(0,d.jsx)("br",{}),"- 4D tensor, 2D or 3D padding only.",(0,d.jsx)("br",{}),"- to_type: float only."]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Pow"}),(0,d.jsx)(s.td,{children:"BPU"}),(0,d.jsx)(s.td,{children:"Supports exponent as a single value."}),(0,d.jsxs)(s.td,{children:["- Type constraints: double, float, int64, int32.",(0,d.jsx)("br",{}),"- Supports same shape, scalar inputs, and broadcasting up to 5 dimensions.",(0,d.jsx)("br",{}),"- X and Y must be of the same type."]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"QLinearConv"}),(0,d.jsx)(s.td,{children:"CPU\u203b"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"QLinearMatMul"}),(0,d.jsx)(s.td,{children:"CPU\u203b"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"QuantizeLinear"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"RNN"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsxs)(s.td,{children:["- Type constraint: float only.",(0,d.jsx)("br",{}),"- direction attribute: forward only.",(0,d.jsx)("br",{}),"- Input constraints: X, W, R required, B, sequence_lens, initial_h unsupported.",(0,d.jsx)("br",{}),"- Output constraint: Y_h output, shape [num_directions, batch_size, hidden_size]."]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"RandomNormal"}),(0,d.jsx)(s.td,{children:"CPU\u203b"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"RandomNormalLike"}),(0,d.jsx)(s.td,{children:"CPU\u203b"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"RandomUniform"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"RandomUniformLike"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Range"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"Type constraints: float, int64, int32, int16."}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Reciprocal"}),(0,d.jsx)(s.td,{children:"BPU"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ReduceL1"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ReduceL2"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ReduceLogSum"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Only supports float, double data types."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ReduceLogSumExp"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Type constraints: float, double."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ReduceMax"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Axes support: 0, 1, or equal to input dimensions."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ReduceMean"}),(0,d.jsx)(s.td,{children:"BPU"}),(0,d.jsx)(s.td,{children:"Input featuremap must be 4D, axes=[2, 3]."}),(0,d.jsx)(s.td,{children:"Axes support: 0, 1, or equal to input dimensions."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ReduceMin"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ReduceProd"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ReduceSum"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Axes support: 0, 1, or equal to input dimensions."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ReduceSumSquare"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Axes support: 0, 1, or equal to input dimensions."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Relu"}),(0,d.jsx)(s.td,{children:"BPU"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Reshape"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Resize"}),(0,d.jsx)(s.td,{children:"BPU"}),(0,d.jsxs)(s.td,{children:["1. Input must be NCHW 4D and only resize in H and W dimensions. ROI input supported in ONNX opset=11 (manual modification required for PyTorch models to add ROI input, which only accepts constant inputs and works with tf_crop_and_resize mode).",(0,d.jsx)("br",{}),"2. Mode supports nearest and linear.",(0,d.jsx)("br",{}),"3. Supports scaling up and down.",(0,d.jsx)("br",{}),"4. For nearest mode, scaling factors should be powers of 2 (e.g., 2, 4, 8, 16, 32) and H_factor must be less than or equal to W_factor.",(0,d.jsx)("br",{}),"5. coordinate_transformation_mode supports half_pixel, pytorch_half_pixel, asymmetric, align_corners, and tf_crop_and_resize. When using tf_crop_and_resize, ensure ROI input coordinates are integers.",(0,d.jsx)("br",{}),"resize-10",(0,d.jsx)("br",{}),"- Use opset10 when input is 2.",(0,d.jsx)("br",{}),"- Input is a 4D Tensor.",(0,d.jsx)("br",{}),"resize-11",(0,d.jsx)("br",{}),"- Use opset11 when input is greater than 2.",(0,d.jsx)("br",{}),"- Input is a 4D Tensor.",(0,d.jsx)("br",{}),"- coordinate_transformation_mode supports half_pixel, asymmetric, align_corners, and pytorch_half_pixel for nearest and linear modes, and half_pixel only for cubic mode.",(0,d.jsx)("br",{}),"- extrapolation_value not supported."]}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ReverseSequence"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"RoiAlign"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Round"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Scan"}),(0,d.jsx)(s.td,{children:"CPU\u203b"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Scatter (deprecated)"}),(0,d.jsx)(s.td,{children:"CPU\u203b"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ScatterElements"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsxs)(s.td,{children:["from_type: float, int32, int8",(0,d.jsx)("br",{}),"indices: int32 only",(0,d.jsx)("br",{}),"updates: float, int32, int8",(0,d.jsx)("br",{}),"to_type: float, int32, int8"]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ScatterND"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsxs)(s.td,{children:["from_type: float, int32, int8",(0,d.jsx)("br",{}),"updates: float, int32, int8",(0,d.jsx)("br",{}),"to_type: float, int32, int8"]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Selu"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Only supports float types."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"SequenceAt"}),(0,d.jsx)(s.td,{children:"CPU\u203b"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"SequenceConstruct"}),(0,d.jsx)(s.td,{children:"CPU\u203b"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"SequenceEmpty"}),(0,d.jsx)(s.td,{children:"CPU\u203b"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"SequenceErase"}),(0,d.jsx)(s.td,{children:"CPU\u203b"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"SequenceInsert"}),(0,d.jsx)(s.td,{children:"CPU\u203b"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"SequenceLength"}),(0,d.jsx)(s.td,{children:"CPU\u203b"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Shape"}),(0,d.jsx)(s.td,{children:"BPU"}),(0,d.jsx)(s.td,{children:"Optimized to numerical storage via constant folding."}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Shrink"}),(0,d.jsx)(s.td,{children:"CPU\u203b"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Sigmoid"}),(0,d.jsx)(s.td,{children:"BPU"}),(0,d.jsxs)(s.td,{children:[(0,d.jsx)(s.code,{children:"Limited to 1CHW tensors where CxHxW <= 8192."}),(0,d.jsx)("br",{}),"8W4C: pad W to multiples of 8 and C to multiples of 4.",(0,d.jsx)("br",{}),"32C: pad C to multiples of 32.",(0,d.jsx)("br",{}),(0,d.jsx)(s.code,{children:"Choose the smallest aligned shape between the two and ensure <= 8192."})]}),(0,d.jsx)(s.td,{children:"Only supports float types."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Sign"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"None"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Sin"}),(0,d.jsx)(s.td,{children:"BPU"}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"Limited to 1CHW tensors where CxHxW <= 8192."})}),(0,d.jsx)(s.td,{children:"Only supports float types."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Sinh"}),(0,d.jsx)(s.td,{children:"CPU"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Only supports float types."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Size"}),(0,d.jsx)(s.td,{children:"BPU"}),(0,d.jsx)(s.td,{children:"Optimized to numerical storage via constant folding."}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Slice"}),(0,d.jsx)(s.td,{children:"BPU"}),(0,d.jsx)(s.td,{children:"Unlimited"}),(0,d.jsx)(s.td,{children:"None"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Softmax"}),(0,d.jsx)(s.td,{children:"BPU"}),(0,d.jsx)(s.td,{children:"Runs on CPU by default. Can be set to BPU for 4D inputs with axis=1 and as model output, using run_on_bpu."}),(0,d.jsx)(s.td,{children:"Only supports float types."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Softplus"}),(0,d.jsx)(s.td,{children:"BPU acceleration"}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"Supports CxHxW <= 8192 for a tensor of input dimension 1CHW."})}),(0,d.jsx)(s.td,{children:"Only supports float type."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Softsign"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Only supports float type."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"SpaceToDepth"}),(0,d.jsx)(s.td,{children:"BPU acceleration"}),(0,d.jsxs)(s.td,{children:["Supports DCR and CRD modes. ",(0,d.jsx)("br",{}),"Restrictions: H and W permutation, blocksize=2 only."]}),(0,d.jsx)(s.td,{children:"Only supports float type."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Split"}),(0,d.jsx)(s.td,{children:"BPU acceleration"}),(0,d.jsx)(s.td,{children:"Restrictions: NCHW input, divisible lengths, axis=1,2,3."}),(0,d.jsx)(s.td,{children:"Only supports float type."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"SplitToSequence"}),(0,d.jsx)(s.td,{children:"CPU computation(*)"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Sqrt"}),(0,d.jsx)(s.td,{children:"BPU acceleration"}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"Supports CxHxW <= 8192 for a tensor of input dimension 1CHW."})}),(0,d.jsx)(s.td,{children:"Only supports float type."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Squeeze"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"Removed by constant folding optimization if in constant substructure."}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"StringNormalizer"}),(0,d.jsx)(s.td,{children:"CPU computation(*)"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Sub"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Supports same shape, scalar inputs, broadcast up to 5 dimensions."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Sum"}),(0,d.jsx)(s.td,{children:"BPU acceleration"}),(0,d.jsx)(s.td,{children:"Same restrictions as Add."}),(0,d.jsx)(s.td,{children:"Only supports float type."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Tan"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Only supports float type."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Tanh"}),(0,d.jsx)(s.td,{children:"BPU acceleration"}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"Supports CxHxW <= 8192 for a tensor of input dimension 1CHW."})}),(0,d.jsx)(s.td,{children:"Only supports float type."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"TfIdfVectorizer"}),(0,d.jsx)(s.td,{children:"CPU computation(*)"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ThresholdedRelu"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Only supports float type."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Tile"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Supports float, int64, int32, uint64, uint32 types."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"TopK"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Only supports float type, opset-10."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Transpose"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"Supports nhwc2nchw, perm=[0, 3, 1, 2], nchw2nhwc, perm=[0, 2, 3, 1]."}),(0,d.jsx)(s.td,{children:"Supports float, int8, int32 types."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Unique"}),(0,d.jsx)(s.td,{children:"CPU computation(*)"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Unsqueeze"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"Removed by constant folding optimization if in constant substructure."}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Upsample (replace resize)"}),(0,d.jsx)(s.td,{children:"BPU acceleration"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsxs)(s.td,{children:["Upsample-10 for input=2, 4D Tensor.",(0,d.jsx)("br",{}),"Upsample-11 for input>2, 4D Tensor."]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Where"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsxs)(s.td,{children:["Supports float and int64 types. ",(0,d.jsx)("br",{}),"Shape constraints detailed in the description."]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Xor"}),(0,d.jsx)(s.td,{children:"CPU computation(*)"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Function"}),(0,d.jsx)(s.td,{children:"CPU computation(*)"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Celu"}),(0,d.jsx)(s.td,{children:"CPU computation(*)"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"DynamicQuantizeLinear"}),(0,d.jsx)(s.td,{children:"CPU computation(*)"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"GreaterOrEqual"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Supports same shape, scalar inputs, broadcast up to 5 dimensions."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"MeanVarianceNormalization"}),(0,d.jsx)(s.td,{children:"CPU computation(*)"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"GridSample (PyTorch)"}),(0,d.jsx)(s.td,{children:"CPU computation(*)"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]})]})]}),"\n",(0,d.jsx)(s.h2,{id:"rdk-ultra-supported-caffe-operators-list",children:"RDK Ultra Supported Caffe Operators List"}),"\n",(0,d.jsxs)(s.table,{children:[(0,d.jsx)(s.thead,{children:(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.th,{children:(0,d.jsx)(s.strong,{children:"Caffe Operator Name"})}),(0,d.jsx)(s.th,{children:(0,d.jsx)(s.strong,{children:"CPU Computation/BPU Acceleration"})}),(0,d.jsx)(s.th,{children:(0,d.jsx)(s.strong,{children:"RDK Ultra BPU Constraints"})}),(0,d.jsx)(s.th,{children:(0,d.jsx)(s.strong,{children:"CPU Constraints"})})]})}),(0,d.jsxs)(s.tbody,{children:[(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Convolution"}),(0,d.jsx)(s.td,{children:"BPU Accelerated"}),(0,d.jsxs)(s.td,{children:["- ",(0,d.jsx)(s.code,{children:"Kernel width and height: <= 32"}),(0,d.jsx)("br",{})," - ",(0,d.jsx)(s.code,{children:"Input/output channels (for one group): <= 8192 (or <= 65536 if last in quantized graph)"}),(0,d.jsx)("br",{})," - ",(0,d.jsx)(s.code,{children:"Stride: Unrestricted, stride for Conv followed by Add (ResNet shortcut-connection) should be {1, 2}"}),(0,d.jsx)("br",{})," - ",(0,d.jsx)(s.code,{children:"Dilation: <= 16"}),(0,d.jsx)("br",{})," - ",(0,d.jsx)(s.code,{children:"Only supports dilation=1 when dilation != 1"}),(0,d.jsx)("br",{})," - ",(0,d.jsx)(s.code,{children:"Axis default: 1"}),(0,d.jsx)("br",{})]}),(0,d.jsxs)(s.td,{children:["- 4D Convolution only",(0,d.jsx)("br",{})," - auto_pad attribute not supported",(0,d.jsx)("br",{})," - Type constraints: float, int32, int8",(0,d.jsx)("br",{})," - Pads attribute constraint: [Hstart, Wstart, Hend, Wend] (4 elements) with Hstart==Hend and Wstart==Wend."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Deconvolution"}),(0,d.jsx)(s.td,{children:"BPU Accelerated"}),(0,d.jsxs)(s.td,{children:["- ",(0,d.jsx)(s.code,{children:"kernel >= stride"}),(0,d.jsx)("br",{})," - ",(0,d.jsx)(s.code,{children:"Input/output featuremaps <= 2048"}),(0,d.jsx)("br",{})," - ",(0,d.jsx)(s.code,{children:"pad <= kernel"})," / stride",(0,d.jsx)("br",{})," - out_pad < 2",(0,d.jsx)("br",{})," - ",(0,d.jsx)(s.code,{children:"stride: 14 >= stride >= 1"}),", but stride_h and stride_w cannot both be 1",(0,d.jsx)("br",{})," - Axis configuration not supported"]}),(0,d.jsxs)(s.td,{children:["- Shape constraint: 4D Tensor computation only",(0,d.jsx)("br",{})," - Type constraint: float only",(0,d.jsx)("br",{})," - Attribute constraints: dilations, group, output_padding, pads, strides attributes",(0,d.jsx)("br",{})," - Pads attribute constraint: [hstart, wstart, hend, wend] must satisfy (hstart==hend and wstart==wend)."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"MaxUnpool"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"---"}),(0,d.jsxs)(s.td,{children:["- from_type constraints: X - float, I - Tensor(int64)",(0,d.jsx)("br",{})," - to_type constraints: float only"]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Pooling"}),(0,d.jsx)(s.td,{children:"BPU Accelerated"}),(0,d.jsxs)(s.td,{children:["- Four types: MaxPooling, AveragePooling, GlobalMaxPooling, GlobalAveragePooling",(0,d.jsx)("br",{})," - ",(0,d.jsx)(s.code,{children:"Constraints: MaxPooling - int16 input/output, kernel <= 256, stride <= 256, padding <= 256"}),(0,d.jsx)("br",{})," - AveragePooling - same as MaxPooling",(0,d.jsx)("br",{})," - GlobalAveragePooling - unlimited",(0,d.jsx)("br",{})," - GlobalMaxPooling - H, W \u2208 [1, 256]"]}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"SPP"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"Not supported"}),(0,d.jsxs)(s.td,{children:["- ",(0,d.jsx)(s.code,{children:"Supports pyramid_height with 2^n pooling, n < 7"}),(0,d.jsx)("br",{})," - ",(0,d.jsx)(s.code,{children:"pooling kernel <= 255"}),(0,d.jsx)("br",{})," - ",(0,d.jsx)(s.code,{children:"pool option, configurable values: {0, 1}"})]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"InnerProduct"}),(0,d.jsx)(s.td,{children:"BPU Accelerated"}),(0,d.jsxs)(s.td,{children:["Converted to Conv with Conv constraints",(0,d.jsx)("br",{})," - Axis configuration not supported"]}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"LRN"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"Not supported"}),(0,d.jsxs)(s.td,{children:["- local_size supported",(0,d.jsx)("br",{})," - alpha, beta, norm_region supported (configurable values: ACROSS_CHANNELS, WITHIN_CHANNEL)",(0,d.jsx)("br",{})," - k supported"]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"MVN"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"Not supported"}),(0,d.jsxs)(s.td,{children:["- normalize_variance: configurable values ",1,(0,d.jsx)("br",{})," - across_channels: configurable values ",1,(0,d.jsx)("br",{})," - Float32 computation only"]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"BatchNorm"}),(0,d.jsx)(s.td,{children:"BPU Accelerated"}),(0,d.jsx)(s.td,{children:"Unlimited"}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ELU"}),(0,d.jsx)(s.td,{children:"BPU Accelerated"}),(0,d.jsxs)(s.td,{children:["- int16 input/output support",(0,d.jsx)("br",{})," - Input/output dimensions up to 10D, max dimension [1, 4096], others [1, 65536]"]}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"BNLL"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"Not supported"}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"PReLU"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsxs)(s.td,{children:["- type constraint: float only",(0,d.jsx)("br",{})," - from_type: X and slope",(0,d.jsx)("br",{})," - to_type: Y",(0,d.jsx)("br",{})," - Shape constraints: X = data_shape, slope = slope_shape",(0,d.jsx)("br",{}),"   - data_shape == slope_shape",(0,d.jsx)("br",{}),"   - slope_shape.ProdSize() == 1",(0,d.jsx)("br",{}),"   - 4D NCHW layout for X and slope, N, C dimensions must be equal",(0,d.jsx)("br",{}),"     - HxW or 1x1 for slope_shape",(0,d.jsx)("br",{}),"     - Hx1 or 1xH for slope_shape",(0,d.jsx)("br",{}),"     - 1xW or Wx1 for slope_shape",(0,d.jsx)("br",{}),"   - Special case: 4D X and 3D slope with data_shape[1] = slope_shape[0] and slope_shape[1] = 1, slope_shape[2] = 1"]}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ReLU/LeakyReLU"}),(0,d.jsx)(s.td,{children:"BPU Accelerated"}),(0,d.jsxs)(s.td,{children:["- int16 input/output support",(0,d.jsx)("br",{})," - Input/output dimensions up to 10D, max dimension [1, 4096], others [1, 65536]"]}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Sigmoid"}),(0,d.jsx)(s.td,{children:"BPU Accelerated"}),(0,d.jsxs)(s.td,{children:["- int16 input/output support",(0,d.jsx)("br",{})," - Input/output dimensions up to 10D, max dimension [1, 4096], others [1, 65536]"]}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"TanH"}),(0,d.jsx)(s.td,{children:"BPU Accelerated"}),(0,d.jsxs)(s.td,{children:["- int16 input/output support",(0,d.jsx)("br",{})," - Input/output dimensions up to 10D, max dimension [1, 4096], others [1, 65536]"]}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Eltwise"}),(0,d.jsx)(s.td,{children:"BPU Accelerated"}),(0,d.jsxs)(s.td,{children:["Supports Add, Sub, Mul operations",(0,d.jsx)("br",{})," - int16 input/output support",(0,d.jsx)("br",{})," - Feature map and constant inputs, at most one constant",(0,d.jsx)("br",{})," - Broadcasting except first dimension",(0,d.jsx)("br",{})," - 2D, 3D, 4D, and 5D dimensions supported, with general limitations (see notes)",(0,d.jsx)("br",{})," - Different input dimensions supported, 5D inputs must meet: merge adjacent dimensions to 4D (e.g., NHWD1 and N1WDC), broadcast dimensions cannot be adjacent (e.g., NHWD1 and N11DC due to broadcast on H, W, and C)"]}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Bias"}),(0,d.jsx)(s.td,{children:"BPU Accelerated"}),(0,d.jsx)(s.td,{children:"Refer to Eltwise (Add) constraints"}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Scale"}),(0,d.jsx)(s.td,{children:"BPU Accelerated"}),(0,d.jsx)(s.td,{children:"Refer to Eltwise (Mul) constraints"}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"AbsVal"}),(0,d.jsx)(s.td,{children:"BPU Accelerated"}),(0,d.jsxs)(s.td,{children:["- int16 input/output support",(0,d.jsx)("br",{})," - Input/output dimensions up to 10D, max dimension [1, 4096], others [1, 65536]"]}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Exp"}),(0,d.jsx)(s.td,{children:"BPU Accelerated"}),(0,d.jsxs)(s.td,{children:["- int16 input/output support",(0,d.jsx)("br",{})," - Input/output dimensions up to 10D, max dimension [1, 4096], others [1, 65536]"]}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Log"}),(0,d.jsx)(s.td,{children:"BPU Accelerated"}),(0,d.jsxs)(s.td,{children:["- int16 input/output support",(0,d.jsx)("br",{})," - Input/output dimensions up to 10D, max dimension [1, 4096], others [1, 65536]"]}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Power"}),(0,d.jsx)(s.td,{children:"BPU Op"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 input and output.",(0,d.jsx)("br",{}),"2. Input and output support up to 10 dimensions, with max dimension \u2208 [1, 4096], others \u2208 [1, 65536].",(0,d.jsx)("br",{}),"3. Second input only supports scalar."]}),(0,d.jsx)(s.td,{children:"-"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Threshold"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"Not supported"}),(0,d.jsx)(s.td,{children:"-"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Reduction"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"Not supported. Operation supports SUM, ASUM, SUMSQ, MEAN, Max, LogSum, Min, Prod; Axis supports; Only supports Float32 computation."}),(0,d.jsx)(s.td,{children:"-"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Softmax"}),(0,d.jsx)(s.td,{children:"BPU Op"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 input and output.",(0,d.jsx)("br",{}),"2. Defaults to CPU execution. Can run on BPU for 4D inputs with axis=1,2,3 if specified by run_on_bpu."]}),(0,d.jsx)(s.td,{children:"-"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ArgMax"}),(0,d.jsx)(s.td,{children:"BPU Op"}),(0,d.jsxs)(s.td,{children:[(0,d.jsx)(s.code,{children:"1. Only supports axis=1, c<=64."}),(0,d.jsx)("br",{}),(0,d.jsx)(s.code,{children:"2. Does not support top_k \u2260 1."}),(0,d.jsx)("br",{}),(0,d.jsx)(s.code,{children:"3. Supports int16 input and output."})]}),(0,d.jsx)(s.td,{children:"-"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Concat"}),(0,d.jsx)(s.td,{children:"BPU Op"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 input and output.",(0,d.jsx)("br",{}),"2. Does not support N-dimensional concat."]}),(0,d.jsx)(s.td,{children:"-"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Split"}),(0,d.jsx)(s.td,{children:"BPU Op"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 input and output.",(0,d.jsx)("br",{}),"2. Length of the original input must be a multiple of each split tensor length.",(0,d.jsx)("br",{}),"3. Supports any dimension except N.",(0,d.jsx)("br",{}),"4. Split count should be divisible.",(0,d.jsx)("br",{}),"5. Supports non-four-dimensional input and output."]}),(0,d.jsx)(s.td,{children:"-"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Slice"}),(0,d.jsx)(s.td,{children:"BPU Op"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 input and output.",(0,d.jsx)("br",{}),"2. Unlimited, supports non-four-dimensional input and output."]}),(0,d.jsx)(s.td,{children:"-"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Reshape"}),(0,d.jsx)(s.td,{children:"BPU Op"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 input and output.",(0,d.jsx)("br",{}),"2. Supports up to 10-dimensional input and output."]}),(0,d.jsx)(s.td,{children:"Shape supports [1,4] shape_dim configurations; Axis supports [-4,3], does not support N dimensions, default 0 follows Caffe rules; num_axes supports [-1,3], default -1 means all axes from axis start."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Flatten"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"Not supported (can be fused in some scenarios)"}),(0,d.jsx)(s.td,{children:"Axis range [-4,3], default is 1, with -4 and 0 having the same meaning. Only supports End_axis == -1."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Crop"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"Not supported"}),(0,d.jsx)(s.td,{children:"-"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Dropout"}),(0,d.jsx)(s.td,{children:"BPU Op"}),(0,d.jsx)(s.td,{children:"Unlimited"}),(0,d.jsx)(s.td,{children:"-"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"LSTM"}),(0,d.jsx)(s.td,{children:"BPU Op"}),(0,d.jsx)(s.td,{children:"Only supports batch=1"}),(0,d.jsx)(s.td,{children:"-"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Normalize"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"Not supported"}),(0,d.jsx)(s.td,{children:"Type constraint: only supports float types."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"PassThrough"}),(0,d.jsx)(s.td,{children:"BPU Op"}),(0,d.jsx)(s.td,{children:"Supports mode=DCR and mode=CRD. Only supports reordering along H and W directions with blocksize=2, e.g., NxCxHxW -> Nx(4C)x(H/2)x(W/2)."}),(0,d.jsx)(s.td,{children:"Type constraint: only supports float types."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"CReLU"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"Not supported"}),(0,d.jsx)(s.td,{children:"Type constraint: only supports float types."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"RReLU"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"Not supported"}),(0,d.jsx)(s.td,{children:"None"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Permute"}),(0,d.jsx)(s.td,{children:"BPU Op"}),(0,d.jsxs)(s.td,{children:["1. Supports arbitrary input dimensions.",(0,d.jsx)("br",{}),"2. Supports conversion of any other dimension except batch dimension (first dimension)."]}),(0,d.jsxs)(s.td,{children:["- Supports nhwc2nchw, perm: [0, 3, 1, 2].",(0,d.jsx)("br",{}),"- Supports nchw2nhwc, perm: [0, 2, 3, 1].",(0,d.jsx)("br",{}),"- Supports permutation of specified dimensions, data types supported: float, int8, int32."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"MatMul"}),(0,d.jsx)(s.td,{children:"BPU Op"}),(0,d.jsxs)(s.td,{children:["C = MatMul(A, B), with dimension constraints for A and B:",(0,d.jsx)("br",{}),"- Both A and B can have non-four-dimensional inputs but must meet these conditions:",(0,d.jsx)("br",{}),"  - Dimensions of A and B must be the same.",(0,d.jsx)("br",{}),"  - The lowest two dimensions M, K \u2208 [1, 8192], higher dimensions \u2208 [1, 4096].",(0,d.jsx)("br",{}),"  Note: HDMK vs HDKN, MK/KN refers to the lowest two dimensions.",(0,d.jsx)("br",{}),"- Broadcasting is supported under these conditions:",(0,d.jsx)("br",{}),"  - All other dimensions than the lowest two of A and B are either 1 or do not require broadcasting.",(0,d.jsx)("br",{}),"    - Supported example: HDMK vs H1KN",(0,d.jsx)("br",{}),"    - Unsupported example: H1MK vs 1DKN",(0,d.jsx)("br",{}),"  - A cannot have both broadcasting and non-broadcasting values in dimensions beyond its lowest two.",(0,d.jsx)("br",{}),"    - Supported example: 11MK vs HDKN",(0,d.jsx)("br",{}),"    - Unsupported example: H1MK vs HDKN",(0,d.jsx)("br",{}),"  - If B has both broadcasting and non-broadcasting values in higher dimensions, non-broadcasting values must be contiguous.",(0,d.jsx)("br",{}),"    - Supported example: BHDMK vs B11KN",(0,d.jsx)("br",{}),"    - Unsupported example: BHDMK vs B1DKN",(0,d.jsx)("br",{}),"- Broadcasting rules:",(0,d.jsx)("br",{}),"- If A and B have unequal values in a given dimension, the 1 is considered the broadcasting value, and the non-1 is not.",(0,d.jsx)("br",{}),"- If A and B have equal values in a given dimension, both are considered non-broadcasting values (e.g., HDMK vs H1KN, 1 is the broadcasting value, H is not)."]}),(0,d.jsx)(s.td,{children:"Type constraint: only supports float types."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Upsample"}),(0,d.jsx)(s.td,{children:"BPU Op"}),(0,d.jsx)(s.td,{children:"Requires four-dimensional NCHW input, resize only supported on H and W dimensions; factor cannot be less than 2."}),(0,d.jsx)(s.td,{children:"-"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ROIPooling"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"Not supported"}),(0,d.jsx)(s.td,{children:"-"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"PSROIPooling"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"Not supported"}),(0,d.jsx)(s.td,{children:"-"})]})]})]}),"\n",(0,d.jsx)(s.h2,{id:"rdk-ultra-supported-onnx-operators-list",children:"RDK Ultra-supported ONNX Operators List"}),"\n",(0,d.jsxs)(s.table,{children:[(0,d.jsx)(s.thead,{children:(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.th,{children:(0,d.jsx)(s.strong,{children:"ONNX Operator Name"})}),(0,d.jsx)(s.th,{children:(0,d.jsx)(s.strong,{children:"CPU/CPU Acceleration"})}),(0,d.jsx)(s.th,{children:(0,d.jsx)(s.strong,{children:"RDK Ultra BPU Constraints"})}),(0,d.jsx)(s.th,{children:(0,d.jsx)(s.strong,{children:"CPU Constraints"})})]})}),(0,d.jsxs)(s.tbody,{children:[(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Abs"}),(0,d.jsx)(s.td,{children:"BPU Accelerated"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 input/output.",(0,d.jsx)("br",{}),"2. Input/output dimensions up to 10D, with max dimensions in [1, 4096] and others in [1, 65536]."]}),(0,d.jsx)(s.td,{children:"Type constraint: only supports float types."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Acos"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Type constraint: only supports float types."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Acosh"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Type constraint: only supports float types."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Add"}),(0,d.jsx)(s.td,{children:"BPU Accelerated"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 input/output.",(0,d.jsx)("br",{}),"2. Input can be featuremaps or constants, with at most one constant input.",(0,d.jsx)("br",{}),"3. Supports broadcast except for the first dimension, including NHWC and N1WC broadcasting.",(0,d.jsx)("br",{}),"4. Dimensions supported: 2D, 3D, 4D, and 5D, with general restrictions (see notes).",(0,d.jsx)("br",{}),"5. In ResNet's shortcut connection, Add is fused into the preceding conv for acceleration."]}),(0,d.jsxs)(s.td,{children:["- Supports computation with same input shape.",(0,d.jsx)("br",{}),"- Supports scalar inputs as either input 1 or 2.",(0,d.jsx)("br",{}),"- Supports broadcast up to 5D."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"And"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsxs)(s.td,{children:["- Supports same input shape calculation.",(0,d.jsx)("br",{}),"- Supports scalar inputs as either input 1 or 2.",(0,d.jsx)("br",{}),"- Supports broadcast up to 5D."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ArgMax"}),(0,d.jsx)(s.td,{children:"BPU Accelerated"}),(0,d.jsxs)(s.td,{children:["1. 4D input format NCHW.",(0,d.jsx)("br",{}),(0,d.jsx)(s.code,{children:"2. Only supports argmax along the C axis (axis=1).<br/>3. C <= 64."}),(0,d.jsx)("br",{}),"4. Supports int16 input/output."]}),(0,d.jsx)(s.td,{children:"Type constraint: only supports float types."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ArgMin"}),(0,d.jsx)(s.td,{children:"BPU Accelerated"}),(0,d.jsx)(s.td,{children:"Similar to ArgMax constraints"}),(0,d.jsx)(s.td,{children:"Type constraint: only supports float types."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Asin"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Type constraint: only supports float types."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Asinh"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Type constraint: only supports float types."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Atan"}),(0,d.jsx)(s.td,{children:"BPU Accelerated"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 input/output.",(0,d.jsx)("br",{}),"2. Input/output dimensions up to 10D, with max dimensions in [1, 4096] and others in [1, 65536]."]}),(0,d.jsx)(s.td,{children:"Type constraint: only supports float types."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Atanh"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Type constraint: only supports float types."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"AveragePool"}),(0,d.jsx)(s.td,{children:"BPU Accelerated"}),(0,d.jsxs)(s.td,{children:[(0,d.jsx)(s.code,{children:"Kernel <= 256."}),(0,d.jsx)("br",{}),(0,d.jsx)(s.code,{children:"Stride <= 256.<br/>Padding <= 256. "})]}),(0,d.jsxs)(s.td,{children:["No support for auto_pad attribute.",(0,d.jsx)("br",{}),"Only supports 4D Tensors."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"BatchNormalization"}),(0,d.jsx)(s.td,{children:"BPU Accelerated"}),(0,d.jsx)(s.td,{children:"No limitations."}),(0,d.jsxs)(s.td,{children:["Type constraint: only supports float types.",(0,d.jsx)("br",{}),"Supports channel-first data layout (dimension 1 is channel)."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"BitShift"}),(0,d.jsx)(s.td,{children:"CPU Computation\u203b"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Cast"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsxs)(s.td,{children:["from_type supports: double, float, bool, int64, uint32, int32, uint16, int16, uint8, int8.",(0,d.jsx)("br",{}),"to_type supports: double, float, bool, int64, uint32, int32, uint16, int16, uint8, int8."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Ceil"}),(0,d.jsx)(s.td,{children:"BPU Accelerated"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 input/output.",(0,d.jsx)("br",{}),"2. Input/output dimensions up to 10D, with max dimensions in [1, 4096] and others in [1, 65536]."]}),(0,d.jsx)(s.td,{children:"Type constraint: only supports float types."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Clip"}),(0,d.jsx)(s.td,{children:"BPU Accelerated"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 input/output.",(0,d.jsx)("br",{}),"2. Input/output dimensions up to 10D, with max dimensions in [1, 4096] and others in [1, 65536].",(0,d.jsx)("br",{}),"Opset 6: min, max as attributes, dtype only supports float.",(0,d.jsx)("br",{}),"Opset 11: min, max as inputs, second input is min when there are two; dtype supports float, double."]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Compress"}),(0,d.jsx)(s.td,{children:"CPU Computation\u203b"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Concat"}),(0,d.jsx)(s.td,{children:"BPU Accelerated"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 input/output.",(0,d.jsx)("br",{}),"2. Does not support N-dimensional concatenation."]}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ConcatFromSequence"}),(0,d.jsx)(s.td,{children:"CPU Computation\u203b"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Constant"}),(0,d.jsx)(s.td,{children:"BPU Accelerated"}),(0,d.jsx)(s.td,{children:"Optimized via constant folding"}),(0,d.jsx)(s.td,{children:"No support for sparse_tensor attribute."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ConstantOfShape"}),(0,d.jsx)(s.td,{children:"BPU Accelerated"}),(0,d.jsx)(s.td,{children:"Optimized via constant folding"}),(0,d.jsx)(s.td,{children:"Supported types: float, int32, int8."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Conv"}),(0,d.jsx)(s.td,{children:"BPU Accelerated"}),(0,d.jsxs)(s.td,{children:["Supports 4D (conv2d) and 5D (conv3d) inputs.",(0,d.jsx)("br",{}),"4D conv2d: Kernel size range: N,C \u2208 [1, 8192]; H,W \u2208 [1, 31].",(0,d.jsx)("br",{}),"C",(0,d.jsx)(s.em,{children:"H"}),"W \u2264 65535.",(0,d.jsx)("br",{}),"Channel limits: 1 group, C \u2264 8192 (or 65536 if last operator in quantized graph).",(0,d.jsx)("br",{}),"Stride: H,W \u2208 [1, 256] (except for shortcut-connected conv, stride=1,2); dilation: H,W \u2208 [1, 16], with H and W factors dividing input Tensor dimensions.",(0,d.jsx)("br",{}),"Padding: H,W \u2208 [0, 256].",(0,d.jsx)("br",{}),"5D conv3d: NCDHW limits: N \u2208 [1, 128]; H,W,D,C \u2208 [1, 65536].",(0,d.jsx)("br",{}),"Kernel size: N,C \u2208 [1, 65536]; H,W \u2208 [1, 31], D \u2208 [1, 8191].",(0,d.jsx)("br",{}),"Padding: DHW: H,W \u2208 [0, 256], D \u2208 [0, kernel_d/2].",(0,d.jsx)("br",{}),"Stride: H, W must be 1 or 2.",(0,d.jsx)("br",{}),"Group and dilation not supported.",(0,d.jsx)("br",{}),"Size limit: 1GB; D",(0,d.jsx)(s.em,{children:"C \u2264 4096 for D"}),"H",(0,d.jsxs)(s.em,{children:["alignCeil(W, 256)",(0,d.jsx)(s.em,{children:"D"}),"C < 1GB.",(0,d.jsx)("br",{}),"Weight limit: D"]}),"C \u2264 8192."]}),(0,d.jsxs)(s.td,{children:["Only supports 4D convolutions.",(0,d.jsx)("br",{}),"No support for auto_pad attribute.",(0,d.jsx)("br",{}),"Supported types: float, int32, int8.",(0,d.jsx)("br",{}),"Pads constraint: [Hstart, Wstart, Hend, Wend] (4 elements) with Hstart==Hend and Wstart==Wend."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ConvInteger"}),(0,d.jsx)(s.td,{children:"CPU Computation\u203b"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ConvTranspose"}),(0,d.jsx)(s.td,{children:"BPU Accelerated"}),(0,d.jsxs)(s.td,{children:["Input/output featuremap limits: N \u2208 [1, 128], H,W \u2208 [1, 65536], C \u2208 [1, 2048].",(0,d.jsx)("br",{}),"Size limit: 1GB.",(0,d.jsx)("br",{}),"Weight size limits: N,C \u2208 [1, 2048], H,W \u2208 [1, 14], HW \u2260 1.",(0,d.jsx)("br",{}),"Size: [1, 65535].",(0,d.jsx)("br",{}),"Padding: For odd strides, H,W \u2208 [0, kernel / stride); even strides, H,W \u2208 [0, kernel / stride].",(0,d.jsx)("br",{}),"Out_pad: H,W \u2208 ",1,".",(0,d.jsx)("br",{}),"Stride: 1-14, not both stride_h and stride_w equal to 1. n \u2208 ",1,"."]}),(0,d.jsxs)(s.td,{children:["Shape Constraint: Only supports 4D Tensors for computation.",(0,d.jsx)("br",{}),"Type Constraint: Only supports float types.",(0,d.jsx)("br",{}),"Attribute Constraints:",(0,d.jsx)("br",{}),"- Supports only dilations, group, output_padding, pads, and strides attributes.",(0,d.jsx)("br",{}),"- The pads attribute constraint is that [hstart, wstart, hend, wend] must satisfy (hstart==hend and wstart==wend)."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Cos"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsxs)(s.td,{children:["1. This operator supports int16 input and output.",(0,d.jsx)("br",{}),"2. Input and output support dimensions up to 10, with the highest dimension \u2208 [1, 4096], and other dimensions \u2208 [1, 65536].",(0,d.jsx)("br",{}),"Type Constraint: Only supports float types."]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Cosh"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"CumSum"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Axis: Type Constraint is only for int32 types."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"DepthToSpace"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsxs)(s.td,{children:["Supports modes DCR and CRD.",(0,d.jsx)("br",{}),"Only rearrangement of H and W directions is supported, and blocksize=2 rearrangement only.",(0,d.jsx)("br",{}),"Example: NxCxHxW -> Nx(C/4)x(2H)x(2W), where the number of channels must be a multiple of 4."]}),(0,d.jsxs)(s.td,{children:["From_Type Constraints:",(0,d.jsx)("br",{}),"- Type Constraint: Only supports float types.",(0,d.jsx)("br",{}),"- Limited to 4D Tensor computation.",(0,d.jsx)("br",{}),"To_Type Constraints:",(0,d.jsx)("br",{}),"- Type Constraint: Only supports float types.",(0,d.jsx)("br",{}),"- Limited to 4D Tensor computation."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"DequantizeLinear"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Det"}),(0,d.jsx)(s.td,{children:"CPU Computation\u203b"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Div"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsxs)(s.td,{children:["1. Only supports featuremap inputs (not constant inputs);",(0,d.jsx)("br",{}),"2. Input shape constraints refer to the Mul operator.",(0,d.jsx)("br",{}),"- Supports same-input-shape computation.",(0,d.jsx)("br",{}),"- Supports computation when input 1 is a scalar or input 2 is a scalar.",(0,d.jsx)("br",{}),"- Supports broadcast computation with a maximum dimension of 5."]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Dropout"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsx)(s.td,{children:"Does not participate in inference computations and will be removed during optimization."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Einsum"}),(0,d.jsx)(s.td,{children:"CPU Computation\u203b"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Elu"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsxs)(s.td,{children:["1. This operator supports int16 input and output.",(0,d.jsx)("br",{}),"2. Input and output support dimensions up to 10, with the highest dimension \u2208 [1, 4096], and other dimensions \u2208 [1, 65536].",(0,d.jsx)("br",{}),"Type Constraint: Only supports float types."]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Equal"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 input.",(0,d.jsx)("br",{}),"2. Input and output dimensions support 2-5 dimensions.",(0,d.jsx)("br",{}),"3. Supports broadcast across all dimensions, broadcast for fin0 or fin1 input allowed, but not mutual broadcasting. 5D broadcast has the following restrictions:",(0,d.jsx)("br",{}),"- Must merge adjacent dimensions to reduce to 4D (including dimension N), e.g., NHWDC and NH1D1 can merge the NH dimension.",(0,d.jsx)("br",{}),"- Broadcasted dimensions cannot merge with adjacent ones, e.g., NHWDC and N1W1C are unsupported due to inability to merge adjacent dimensions.",(0,d.jsx)("br",{}),"4. Runs on CPU by default; can be specified to run on BPU with run_on_bpu."]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Erf"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Type Constraint: Supports float and double data types."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Exp"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 input and output.",(0,d.jsx)("br",{}),"2. Input and output support dimensions up to 10, with the highest dimension \u2208 [1, 4096], and other dimensions \u2208 [1, 65536].",(0,d.jsx)("br",{}),"Type Constraint: Only supports float types."]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Expand"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 input and output.",(0,d.jsx)("br",{}),"2. Input and output support dimensions up to 10, with one differing dimension between input and output.",(0,d.jsx)("br",{}),"3. Only allows one differing dimension between input and output."]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"EyeLike"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Flatten"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsx)(s.td,{children:"Constraints similar to Reshape."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Floor"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 input and output.",(0,d.jsx)("br",{}),"2. Input and output support dimensions up to 10, with the highest dimension \u2208 [1, 4096], and other dimensions \u2208 [1, 65536].",(0,d.jsx)("br",{}),"Type Constraint: Only supports float types."]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"GRU"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsxs)(s.td,{children:["Direction Attribute: Only supports forward type.",(0,d.jsx)("br",{}),"Type Constraint: Only supports float types."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Gather"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsxs)(s.td,{children:["1. All ranks of input/output/indices must be less than or equal to 4.",(0,d.jsx)("br",{}),"2. Indices support:",(0,d.jsx)("br",{}),"   - When indices are feature (other op outputs), type constraint is only for int32.",(0,d.jsx)("br",{}),"   - When indices are weight (model constants), type constraint supports int32 and int64.",(0,d.jsx)("br",{}),"From_Type Constraints:",(0,d.jsx)("br",{}),"- input: Type constraint supports float, int64, int32, int8, uint64, uint32, uint8.",(0,d.jsx)("br",{}),"- indices: Type constraint supports int32, int64.",(0,d.jsx)("br",{}),"To_Type Constraints:",(0,d.jsx)("br",{}),"- Type constraint supports float, int64, int32, int8, uint64, uint32, uint8."]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"GatherElements"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 input and output.",(0,d.jsx)("br",{}),"2. Input/indices/output dimensions support up to 10 dimensions.",(0,d.jsx)("br",{}),"3. Indices type constraint supports int16/int32/int64."]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"GatherND"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsxs)(s.td,{children:["From_Type Constraints:",(0,d.jsx)("br",{}),"- input: Type constraint supports float, int32, int8.",(0,d.jsx)("br",{}),"- indices: tensor(int64).",(0,d.jsx)("br",{}),"To_Type Constraints: Type constraint supports float, int32, int8."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Gemm"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsx)(s.td,{children:"Gemm will be converted to Conv implementation, with boundary constraints referring to Conv."}),(0,d.jsx)(s.td,{children:"Type Constraint: Only supports float types."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"GlobalAveragePool"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsx)(s.td,{children:"No limitations."}),(0,d.jsxs)(s.td,{children:["- Type Constraint: Only supports float types.",(0,d.jsx)("br",{}),"- Limited to 4D Tensors."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"GlobalLpPool"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsxs)(s.td,{children:["- Type Constraint: Supports float and double types.",(0,d.jsx)("br",{}),"- Limited to 4D Tensor computation."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"GlobalMaxPool"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsx)(s.td,{children:"H, W \u2208 [1, 256]."}),(0,d.jsxs)(s.td,{children:["- Type Constraint: Only supports float types.",(0,d.jsx)("br",{}),"- Limited to 4D Tensors."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Greater"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 input.",(0,d.jsx)("br",{}),"2. Input and output dimensions support 2-5 dimensions.",(0,d.jsx)("br",{}),"3. Same as Equal operator constraints.",(0,d.jsx)("br",{}),"4. Runs on CPU by default; can be specified to run on BPU with run_on_bpu."]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"HardSigmoid"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 input and output.",(0,d.jsx)("br",{}),"2. Input and output support dimensions up to 10, with the highest dimension \u2208 [1, 4096], and other dimensions \u2208 [1, 65536].",(0,d.jsx)("br",{}),"Type Constraint: Only supports float types."]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Hardmax"}),(0,d.jsx)(s.td,{children:"CPU Computation\u203b"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Identity"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"If"}),(0,d.jsx)(s.td,{children:"CPU Computation\u203b"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"InstanceNormalization"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsxs)(s.td,{children:["- Type constraint only supports float types.",(0,d.jsx)("br",{}),"- Supports data layout with the first dimension as channels."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"IsInf"}),(0,d.jsx)(s.td,{children:"CPU Computation\u203b"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"IsNaN"}),(0,d.jsx)(s.td,{children:"CPU Computation\u203b"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"LRN"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsxs)(s.td,{children:["- Type constraint only supports float types.",(0,d.jsx)("br",{}),"- Only supports four-dimensional Tensors."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"LSTM"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsx)(s.td,{children:"Supports batch_size=1 only. If using multiple batches, ensure LSTM's batch is 1 during ONNX export and configure the parameter input_batch=1 in the YAML."}),(0,d.jsxs)(s.td,{children:["- Type constraint only supports float types.",(0,d.jsx)("br",{}),"- Attribute constraint: direction attribute only supports forward.",(0,d.jsx)("br",{}),"- Input constraints:",(0,d.jsx)("br",{}),"   - Supports X, W, R inputs;",(0,d.jsx)("br",{}),"   - Supports X, W, R, B inputs (sequence_lens is empty or default);",(0,d.jsx)("br",{}),"   - Supports X, W, R, B, sequence_lens, initial_h, initial_c, P inputs (sequence_lens is empty or default)."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"LeakyRelu"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 input and output.",(0,d.jsx)("br",{}),"2. Input and output dimensions support 1-10 dimensions, with the highest dimension \u2208 [1, 4096], others \u2208 [1, 65536]."]}),(0,d.jsx)(s.td,{children:"Type constraint: only supports float types."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Less"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 input.",(0,d.jsx)("br",{}),"2. Input/output dimensions support 2-5 dimensions.",(0,d.jsx)("br",{}),"3. Runs on CPU by default; can be specified to run on BPU using run_on_bpu."]}),(0,d.jsxs)(s.td,{children:["- Supports same shape inputs calculation.",(0,d.jsx)("br",{}),"- Supports scalar input1 or scalar input2 calculation.",(0,d.jsx)("br",{}),"- Supports broadcast calculation with a max dimension of 5."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"LessOrEqual"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsx)(s.td,{children:"In opset11, single LessOrEqual not supported; Greater + Not operator is used instead, with the same limitations as Greater."}),(0,d.jsxs)(s.td,{children:["- Supports same shape inputs calculation.",(0,d.jsx)("br",{}),"- Supports scalar input1 or scalar input2 calculation.",(0,d.jsx)("br",{}),"- Supports broadcast calculation with a max dimension of 5."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Log"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 input and output.",(0,d.jsx)("br",{}),"2. Input and output dimensions support 1-10 dimensions, with the highest dimension \u2208 [1, 4096], others \u2208 [1, 65536]."]}),(0,d.jsx)(s.td,{children:"Type constraint: only supports float types."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"LogSoftmax"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Type constraint: only supports float types."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Loop"}),(0,d.jsx)(s.td,{children:"CPU Computation\u203b"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"LpNormalization"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsxs)(s.td,{children:["- p-norm only supports 1 or 2.",(0,d.jsx)("br",{}),"- Type constraint supports double and float types."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"LpPool"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsxs)(s.td,{children:["- auto_pad attribute not supported.",(0,d.jsx)("br",{}),"- Type constraint supports double and float types.",(0,d.jsx)("br",{}),"- Limited to 4-dimensional computation."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"MatMulInteger"}),(0,d.jsx)(s.td,{children:"CPU Computation\u203b"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"MatMul"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsxs)(s.td,{children:["C = MatMul(A, B), with input A and B dimension restrictions:",(0,d.jsx)("br",{}),"- Non-quadruple dimensional inputs allowed but must meet these constraints:",(0,d.jsx)("br",{}),"  - A and B must have identical dimensions.",(0,d.jsx)("br",{}),"  - The lowest two dimensions M, K \u2208 [1, 8192], higher dimensions \u2208 [1, 4096].",(0,d.jsx)("br",{}),"  Note: HDMK vs HDKN, MK/KN refers to the lowest two dimensions.",(0,d.jsx)("br",{}),"- Broadcast is supported under these conditions:",(0,d.jsx)("br",{}),"  - For A and B, all dimensions except the lowest two must be either 1 or non-broadcastable values.",(0,d.jsx)("br",{}),"    - Examples: HDMK vs H1KN",(0,d.jsx)("br",{}),"    - Counterexample: H1MK vs 1DKN",(0,d.jsx)("br",{}),"  - A's higher dimensions cannot contain both broadcastable and non-broadcastable values.",(0,d.jsx)("br",{}),"    - Examples: 11MK vs HDKN",(0,d.jsx)("br",{}),"    - Counterexample: H1MK vs HDKN",(0,d.jsx)("br",{}),"  - If B's higher dimensions contain both broadcastable and non-broadcastable values, non-broadcastable ones must be consecutive high dimensions.",(0,d.jsx)("br",{}),"    - Examples: BHDMK vs B11KN",(0,d.jsx)("br",{}),"    - Counterexample: BHDMK vs B1DKN",(0,d.jsx)("br",{}),"- Type constraint: only supports float types."]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Max"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 input and output.",(0,d.jsx)("br",{}),"2. Input/output dimensions support 2-5 dimensions.",(0,d.jsx)("br",{}),"3. Supports broadcast across all dimensions, broadcast for fin0 or fin1 individually, not mutual broadcast. Restrictions for 5D broadcast:",(0,d.jsx)("br",{}),"- Can merge adjacent dimensions to 4D (including dimension N), e.g., NHWDC and NH1D1 can merge NH.",(0,d.jsx)("br",{}),"- Broadcast dimensions cannot merge with adjacent ones, e.g., NHWDC and N1W1C unsupported due to no adjacent dimension merge.",(0,d.jsx)("br",{}),"- Other details in the documentation."]}),(0,d.jsxs)(s.td,{children:["- Supports 1-\u221e inputs.",(0,d.jsx)("br",{}),"- Supports same shape inputs calculation.",(0,d.jsx)("br",{}),"- Supports scalar input1 or scalar input2 calculation.",(0,d.jsx)("br",{}),"- Supports broadcast calculation with a max dimension of 5."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"MaxPool"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsxs)(s.td,{children:["Supports int16 input and output.",(0,d.jsx)("br",{}),"Kernel size \u2264 256.",(0,d.jsx)("br",{}),"Stride \u2264 256.",(0,d.jsx)("br",{}),"Padding \u2264 256.",(0,d.jsx)("br",{}),"MaxPool does not support dilation."]}),(0,d.jsxs)(s.td,{children:["1. Dilation only supports 1x1.",(0,d.jsx)("br",{}),"2. Data row-major storage only.",(0,d.jsx)("br",{}),"3. auto_pad attribute not supported.",(0,d.jsx)("br",{}),"4. storage_order attribute not supported.",(0,d.jsx)("br",{}),"5. Limited to four-dimensional Tensor computation."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"MaxRoiPool"}),(0,d.jsx)(s.td,{children:"CPU Computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"No specific constraints."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Mean"}),(0,d.jsx)(s.td,{children:"CPU Computation\u203b"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Min"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 input and output.",(0,d.jsx)("br",{}),"2. Input/output dimensions support 2-5 dimensions.",(0,d.jsx)("br",{}),"3. Similar to Max, but with different broadcast and dimension merge rules.",(0,d.jsx)("br",{}),"4. Runs on CPU by default; can be moved to BPU using run_on_bpu."]}),(0,d.jsx)(s.td,{children:"- Similar to Max, but with different input constraints."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Mod"}),(0,d.jsx)(s.td,{children:"CPU Computation\u203b"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Mul"}),(0,d.jsx)(s.td,{children:"BPU Acceleration"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 input and output.",(0,d.jsx)("br",{}),"2. Input types support feature maps and constants, with at most one constant input.",(0,d.jsx)("br",{}),"3. Supports broadcast except the first dimension, mutual broadcast between inputs, like NH1C and N1WC.",(0,d.jsx)("br",{}),"4. Dimensions up to 5D, with general restrictions (see notes). Supports different input dimensions, with specific restrictions for 5D input.",(0,d.jsx)("br",{}),"(1) Merge adjacent dimensions to 4D, e.g., NHWD1 and N1WDC can merge W and D.",(0,d.jsx)("br",{}),"(2) Cannot merge broadcast dimensions with adjacent ones, e.g., NHWD1 and N11DC unsupported due to H, W, and C being broadcast dimensions."]}),(0,d.jsxs)(s.td,{children:["- Supports same shape inputs calculation.",(0,d.jsx)("br",{}),"- Supports scalar input1 or scalar input2 calculation.",(0,d.jsx)("br",{}),"- Supports broadcast calculation with a max dimension of 5."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Multinomial"}),(0,d.jsx)(s.td,{children:"CPU Computation\u203b"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]})]})]}),"\n",(0,d.jsxs)(s.table,{children:[(0,d.jsx)(s.thead,{children:(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.th,{children:"Operation"}),(0,d.jsx)(s.th,{children:"Implementation"}),(0,d.jsx)(s.th,{children:"Notes"}),(0,d.jsx)(s.th,{children:"Limitations"})]})}),(0,d.jsxs)(s.tbody,{children:[(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Neg"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Not"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"OneHot"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Or"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsxs)(s.td,{children:["- Supports same-input-shape computation.",(0,d.jsx)("br",{}),"- Supports when Input 1 is a scalar or Input 2 is a scalar.",(0,d.jsx)("br",{}),"- Supports broadcast calculation with a maximum dimension of 5."]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"PRelu"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsxs)(s.td,{children:["- Type constraint: only supports float types.",(0,d.jsx)("br",{}),"- from_type: X and slope.",(0,d.jsx)("br",{}),"- to_type: Y.",(0,d.jsx)("br",{}),"- Constraints for X's shape (data_shape):",(0,d.jsx)("br",{}),"  - data_shape == slope_shape.",(0,d.jsx)("br",{}),"  - slope_shape.ProdSize() == 1.",(0,d.jsx)("br",{}),"  - N, C dimensions must be equal in 4D NCHW layout.",(0,d.jsx)("br",{}),"  - HxW with 1x1 (slope_shape), Hx1 (slope_shape), or 1xW (slope_shape).",(0,d.jsx)("br",{}),"- Special case: 4D X and 3D slope with data_shape[1] == slope_shape[0] == 1 and slope_shape[2] == 1."]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Pad"}),(0,d.jsx)(s.td,{children:"BPU acceleration"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 input and output.",(0,d.jsx)("br",{}),"2. Supports mode: Constant.",(0,d.jsx)("br",{}),"3. Supports padding in all dimensions."]}),(0,d.jsxs)(s.td,{children:[(0,d.jsx)("br",{}),"Pad-10:",(0,d.jsx)("br",{}),"  - Type constraint: float only.",(0,d.jsx)("br",{}),"  - 4D NCHW tensors only.",(0,d.jsx)("br",{}),"  - Constraint on pads attribute:",(0,d.jsx)("br",{}),"    - len(pads) == 8",(0,d.jsx)("br",{}),"    - pads[i] >= 0",(0,d.jsx)("br",{}),"    - pads[0] == pads[1] == pads[4] == pads[5] == 0.",(0,d.jsx)("br",{}),"Pad-11:",(0,d.jsx)("br",{}),"  - from_type: data - float only.",(0,d.jsx)("br",{}),"  - pads: tensor(int64)",(0,d.jsx)("br",{}),"  - constant_value (optional) - float only.",(0,d.jsx)("br",{}),"  - to_type: float only.",(0,d.jsx)("br",{}),"  - 4D Tensor only.",(0,d.jsx)("br",{}),"  - Supports 2D or 3D padding only."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Pow"}),(0,d.jsx)(s.td,{children:"BPU acceleration"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 input and output.",(0,d.jsx)("br",{}),"2. Input/output support 1-10 dimensions, max dim \u2208 [1, 4096], others \u2208 [1, 65536].",(0,d.jsx)("br",{}),"3. Second input must be a scalar."]}),(0,d.jsxs)(s.td,{children:["- Type constraints: double, float, int64, int32.",(0,d.jsx)("br",{}),"- Supports same-input-shape calculation.",(0,d.jsx)("br",{}),"- Supports scalar inputs for either Input 1 or Input 2.",(0,d.jsx)("br",{}),"- Supports broadcast calculation with a maximum dimension of 5.",(0,d.jsx)("br",{}),"- Requires X and Y to have the same type."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"QLinearConv"}),(0,d.jsx)(s.td,{children:"CPU computation\u203b"}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"QLinearMatMul"}),(0,d.jsx)(s.td,{children:"CPU computation\u203b"}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"QuantizeLinear"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"RNN"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsxs)(s.td,{children:["- Type constraint: float only.",(0,d.jsx)("br",{}),"- Attribute constraint: direction attribute supports forward only.",(0,d.jsx)("br",{}),"- Input constraint: X, W, R inputs only, no optional inputs like B, sequence_lens, initial_h allowed.",(0,d.jsx)("br",{}),"- Output constraint: Only Y_h output supported, shape [num_directions, batch_size, hidden_size]."]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"RandomNormal"}),(0,d.jsx)(s.td,{children:"CPU computation\u203b"}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"RandomNormalLike"}),(0,d.jsx)(s.td,{children:"CPU computation\u203b"}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"RandomUniform"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"RandomUniformLike"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Range"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"Type constraints: float, int64, int32, int16."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Reciprocal"}),(0,d.jsx)(s.td,{children:"BPU acceleration"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 input and output.",(0,d.jsx)("br",{}),"2. Input/output support 1-10 dimensions, max dim \u2208 [1, 4096], others \u2208 [1, 65536]."]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ReduceL1"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ReduceL2"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ReduceLogSum"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ReduceLogSumExp"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"Type constraints: float, double."}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ReduceMax"}),(0,d.jsx)(s.td,{children:"BPU acceleration"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 input and output.",(0,d.jsx)("br",{}),"2. Input supports 2-5 dimensions, requires axes attribute with 1 axis, no reduction across more than 1 dimension.",(0,d.jsx)("br",{}),"3. Reduced dimension size \u2208 [1, 8192].",(0,d.jsx)("br",{}),"4. keepdims == 1 only.",(0,d.jsx)("br",{})]}),(0,d.jsx)(s.td,{children:"Axes supported: 0, 1, or equal to input data dimensions."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ReduceMean"}),(0,d.jsx)(s.td,{children:"BPU acceleration"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 input and output.",(0,d.jsx)("br",{}),"2. Input supports 2-5 dimensions, requires axes attribute with 1 axis, no reduction across more than 1 dimension.",(0,d.jsx)("br",{}),"3. Special case: Supports HW reduction when reduce_dim = 2.",(0,d.jsx)("br",{}),"4. keepdims == 1 only.",(0,d.jsx)("br",{})]}),(0,d.jsx)(s.td,{children:"Axes supported: 0, 1, or equal to input data dimensions."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ReduceMin"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ReduceProd"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ReduceSum"}),(0,d.jsx)(s.td,{children:"BPU acceleration"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 input and output.",(0,d.jsx)("br",{}),"2. Input supports 2-5 dimensions, requires axes attribute with 1 axis, no reduction across more than 1 dimension."]}),(0,d.jsx)(s.td,{children:"Axes supported: 0, 1, or equal to input data dimensions."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ReduceSumSquare"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Relu"}),(0,d.jsx)(s.td,{children:"BPU acceleration"}),(0,d.jsx)(s.td,{children:"Unlimited"}),(0,d.jsx)(s.td,{children:"Only supports float type."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Reshape"}),(0,d.jsx)(s.td,{children:"BPU acceleration"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 inputs and outputs.",(0,d.jsx)("br",{}),"2. Supports 1-10 dimensional inputs and outputs."]}),(0,d.jsx)(s.td,{children:"None."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Resize"}),(0,d.jsx)(s.td,{children:"BPU acceleration"}),(0,d.jsxs)(s.td,{children:["1. NCHW input featuremaps, resize only on H and W dimensions. onnx opset=11 supports ROI input (PyTorch models need manual modification to add ROI input, which only accepts constant inputs).",(0,d.jsx)("br",{}),"2. Mode supports nearest and linear.",(0,d.jsx)("br",{}),"3. Supports scaling up or down.",(0,d.jsx)("br",{}),(0,d.jsx)(s.code,{children:"4. For nearest mode, scale factors must be powers of 2 (e.g., 2, 4, 8, 16, 32) with H_factor <= W_factor."}),(0,d.jsx)("br",{}),"5. onnx opset=11 supports half_pixel, pytorch_half_pixel, asymmetric, align_corners, and tf_crop_and_resize. ROI input is only effective in tf_crop_and_resize mode, requiring integer boundary coordinates after conversion.",(0,d.jsx)("br",{}),"6. extrapolation_value not supported."]}),(0,d.jsx)(s.td,{})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ReverseSequence"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"RoiAlign"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Round"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Scan"}),(0,d.jsx)(s.td,{children:"CPU computation*"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Scatter (deprecated)"}),(0,d.jsx)(s.td,{children:"CPU computation*"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ScatterElements"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsxs)(s.td,{children:["from_type: supports float, int32, int8.",(0,d.jsx)("br",{}),"indices: only supports int32 type.",(0,d.jsx)("br",{}),"updates: supports float, int32, int8.",(0,d.jsx)("br",{}),"to_type: supports float, int32, int8."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ScatterND"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsxs)(s.td,{children:["from_type: supports float, int32, int8.",(0,d.jsx)("br",{}),"updates: supports float, int32, int8.",(0,d.jsx)("br",{}),"to_type: supports float, int32, int8."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Selu"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"Only supports float type."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"SequenceAt"}),(0,d.jsx)(s.td,{children:"CPU computation*"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"SequenceConstruct"}),(0,d.jsx)(s.td,{children:"CPU computation*"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"SequenceEmpty"}),(0,d.jsx)(s.td,{children:"CPU computation*"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"SequenceErase"}),(0,d.jsx)(s.td,{children:"CPU computation*"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"SequenceInsert"}),(0,d.jsx)(s.td,{children:"CPU computation*"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"SequenceLength"}),(0,d.jsx)(s.td,{children:"CPU computation*"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Shape"}),(0,d.jsx)(s.td,{children:"BPU acceleration"}),(0,d.jsx)(s.td,{children:"Optimized through constant folding into numerical storage."}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Shrink"}),(0,d.jsx)(s.td,{children:"CPU computation*"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Sigmoid"}),(0,d.jsx)(s.td,{children:"BPU acceleration"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 inputs and outputs.",(0,d.jsx)("br",{}),"2. Supports 1-10 dimensional inputs, max dimension [1, 4096], others [1, 65536]."]}),(0,d.jsx)(s.td,{children:"Only supports float type."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Sign"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"Only supports float type."}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Sin"}),(0,d.jsx)(s.td,{children:"BPU acceleration"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 inputs and outputs.",(0,d.jsx)("br",{}),"2. Supports 1-10 dimensional inputs, max dimension [1, 4096], others [1, 65536]."]}),(0,d.jsx)(s.td,{children:"Only supports float type."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Sinh"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"Only supports float type."}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Size"}),(0,d.jsx)(s.td,{children:"BPU acceleration"}),(0,d.jsx)(s.td,{children:"Optimized through constant folding into numerical storage."}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Slice"}),(0,d.jsx)(s.td,{children:"BPU acceleration"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 inputs and outputs.",(0,d.jsx)("br",{}),"2. Unlimited, supports non-four-dimensional inputs and outputs."]}),(0,d.jsx)(s.td,{children:"No constraints."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Softmax"}),(0,d.jsx)(s.td,{children:"BPU acceleration"}),(0,d.jsxs)(s.td,{children:["- Supports int16 inputs and outputs.",(0,d.jsx)("br",{}),"- Runs on CPU by default, with differences between onnx::softmax and pytorch::softmax:",(0,d.jsx)("br",{}),"1. For onnx::softmax, can run on BPU if input is 4D and axis=3. Specify run_on_bpu.",(0,d.jsx)("br",{}),"2. For pytorch::softmax, can run on BPU for 4D inputs and axis=1, 2, 3. Specify run_on_bpu.",(0,d.jsx)("br",{})]}),(0,d.jsx)(s.td,{children:"Only supports float type."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Softplus"}),(0,d.jsx)(s.td,{children:"BPU acceleration"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 inputs and outputs.",(0,d.jsx)("br",{}),"2. Supports 1-10 dimensional inputs, max dimension [1, 4096], others [1, 65536]."]}),(0,d.jsx)(s.td,{children:"Only supports float type."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Softsign"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]})]})]}),"\n",(0,d.jsxs)(s.table,{children:[(0,d.jsx)(s.thead,{children:(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.th,{children:"Operator"}),(0,d.jsx)(s.th,{children:"Acceleration"}),(0,d.jsx)(s.th,{children:"Support modes and constraints"}),(0,d.jsx)(s.th,{children:"Type constraints"})]})}),(0,d.jsxs)(s.tbody,{children:[(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"SpaceToDepth"}),(0,d.jsx)(s.td,{children:"BPU accelerated"}),(0,d.jsx)(s.td,{children:"Supports DCR and CRD modes. Only reordering along H and W dimensions is allowed, with blocksize=2."}),(0,d.jsx)(s.td,{children:"float only"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Split"}),(0,d.jsx)(s.td,{children:"BPU accelerated"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 inputs and outputs.",(0,d.jsx)("br",{}),"2. Input length must be a multiple of each split tensor's length.",(0,d.jsx)("br",{}),"3. Supports arbitrary dimensions except N.",(0,d.jsx)("br",{}),"4. Split count must be divisible.",(0,d.jsx)("br",{}),"5. Non-four-dimensional inputs and outputs supported."]}),(0,d.jsx)(s.td,{children:"float only"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"SplitToSequence"}),(0,d.jsx)(s.td,{children:"CPU computation(*)"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Sqrt"}),(0,d.jsx)(s.td,{children:"BPU accelerated"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 inputs and outputs.",(0,d.jsx)("br",{}),"2. Input/output supports 1-10 dimensions, with max dimension in [1, 4096] and others in [1, 65536]."]}),(0,d.jsx)(s.td,{children:"float only"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Squeeze"}),(0,d.jsx)(s.td,{children:"BPU accelerated"}),(0,d.jsx)(s.td,{children:"Converted to Reshape op. BPU constraints apply."}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"StringNormalizer"}),(0,d.jsx)(s.td,{children:"CPU computation(*)"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Sub"}),(0,d.jsx)(s.td,{children:"BPU accelerated"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 inputs and outputs.",(0,d.jsx)("br",{}),"2. Feature map and constant inputs supported, up to one constant.",(0,d.jsx)("br",{}),"3. Broadcasting except first dimension, supports input broadcasting between NH1C and N1WC.",(0,d.jsx)("br",{}),"4. 2D-5D dimensions supported, with general restrictions (see notes). Supports different input dimensions; for 5D inputs, see restrictions below.",(0,d.jsx)("br",{}),"(1) Merge adjacent dimensions to 4D, e.g., NHWD1 and N1WDC.",(0,d.jsx)("br",{}),"(2) Cannot merge broadcasted dimensions with adjacent ones, e.g., NHWD1 and N11DC not supported due to H, W, and C being broadcasted dimensions."]}),(0,d.jsxs)(s.td,{children:["Same shape input support",(0,d.jsx)("br",{}),"Scalar input support",(0,d.jsx)("br",{}),"Broadcasting up to 5 dimensions."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Sum"}),(0,d.jsx)(s.td,{children:"BPU accelerated"}),(0,d.jsx)(s.td,{children:"Constraints same as Add"}),(0,d.jsx)(s.td,{children:"float only"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Tan"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"float only"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Tanh"}),(0,d.jsx)(s.td,{children:"BPU accelerated"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 inputs and outputs.",(0,d.jsx)("br",{}),"2. Input/output supports 1-10 dimensions, with max dimension in [1, 4096] and others in [1, 65536]."]}),(0,d.jsx)(s.td,{children:"float only"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"TfIdfVectorizer"}),(0,d.jsx)(s.td,{children:"CPU computation(*)"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ThresholdedRelu"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"float only"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Tile"}),(0,d.jsx)(s.td,{children:"BPU accelerated"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 inputs and outputs.",(0,d.jsx)("br",{}),"2. Only one dimension may have differing values between input and output."]}),(0,d.jsx)(s.td,{children:"float, int64, etc."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"TopK"}),(0,d.jsx)(s.td,{children:"BPU accelerated"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 inputs and outputs.",(0,d.jsx)("br",{}),"2. Input/indices/output dimensions: 1-10.",(0,d.jsx)("br",{}),"3. Indices type: int16/int32/int64.",(0,d.jsx)("br",{}),"4. Sorted parameter supports true only."]}),(0,d.jsx)(s.td,{children:"float only"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Transpose"}),(0,d.jsx)(s.td,{children:"BPU accelerated"}),(0,d.jsxs)(s.td,{children:["1. Supports int16 inputs and outputs.",(0,d.jsx)("br",{}),"2. Arbitrary input dimensions."]}),(0,d.jsxs)(s.td,{children:["nhwc2nchw, perm: [0, 3, 1, 2]",(0,d.jsx)("br",{}),"nchw2nhwc, perm: [0, 2, 3, 1]",(0,d.jsx)("br",{}),"Custom perm dimensions for float, int8, int32."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Unique"}),(0,d.jsx)(s.td,{children:"CPU computation(*)"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Unsqueeze"}),(0,d.jsx)(s.td,{children:"BPU accelerated"}),(0,d.jsx)(s.td,{children:"Converted to Reshape op. BPU constraints apply."}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Upsample (resize replacement)"}),(0,d.jsx)(s.td,{children:"BPU accelerated"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsxs)(s.td,{children:["Upsample-10",(0,d.jsx)("br",{}),"Input: 4D Tensor, opset10 when = 2",(0,d.jsx)("br",{}),"Upsample-11",(0,d.jsx)("br",{}),"Input: 4D Tensor, opset11 when > 2",(0,d.jsx)("br",{}),"Coordinate transformation modes: nearest, linear (half_pixel, asymmetric, align_corners, pytorch_half_pixel), cubic (half_pixel only)",(0,d.jsx)("br",{}),"Extrapolation_value unsupported."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Where"}),(0,d.jsx)(s.td,{children:"CPU computation"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"float, int64"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Xor"}),(0,d.jsx)(s.td,{children:"CPU computation(*)"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Function"}),(0,d.jsx)(s.td,{children:"CPU computation(*)"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"Celu"}),(0,d.jsx)(s.td,{children:"CPU computation(*)"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"DynamicQuantizeLinear"}),(0,d.jsx)(s.td,{children:"CPU computation(*)"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"GreaterOrEqual"}),(0,d.jsx)(s.td,{children:"BPU accelerated"}),(0,d.jsx)(s.td,{children:"Opset11 doesn't support standalone GreaterOrEqual; Less + Not on BPU for split conditions, with similar restrictions to Less."}),(0,d.jsx)(s.td,{children:"Same shape, scalar, broadcast up to 5D."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"MeanVarianceNormalization"}),(0,d.jsx)(s.td,{children:"CPU computation(*)"}),(0,d.jsx)(s.td,{children:"--"}),(0,d.jsx)(s.td,{children:"--"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"GridSample (PyTorch)"}),(0,d.jsx)(s.td,{children:"BPU accelerated"}),(0,d.jsxs)(s.td,{children:["1. Input dimensions: 4D, N \u2208 [1, 4096], C \u2208 [1, 65536], H, W \u2208 [1, 1024], H",(0,d.jsx)(s.em,{children:"W \u2264 720"}),"1024.",(0,d.jsx)("br",{}),"2. Mode: bilinear, nearest.",(0,d.jsx)("br",{}),"3. Padding_mode: zeros, border.",(0,d.jsx)("br",{}),"4. Opset16 ONNX operator, exported via horizon_nn.torch.export_onnx (not opset11 native). See example below."]}),(0,d.jsx)(s.td,{children:"--"})]})]})]})]})}function j(t={}){const{wrapper:s}={...(0,r.R)(),...t.components};return s?(0,d.jsx)(s,{...t,children:(0,d.jsx)(x,{...t})}):x(t)}},28453:(t,s,n)=>{n.d(s,{R:()=>i,x:()=>o});var e=n(96540);const d={},r=e.createContext(d);function i(t){const s=e.useContext(r);return e.useMemo(function(){return"function"==typeof t?t(s):{...s,...t}},[s,t])}function o(t){let s;return s=t.disableParentContext?"function"==typeof t.components?t.components(d):t.components||d:i(t.components),e.createElement(r.Provider,{value:s},t.children)}}}]);