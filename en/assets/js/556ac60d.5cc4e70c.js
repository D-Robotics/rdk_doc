"use strict";(self.webpackChunkrdk_doc=self.webpackChunkrdk_doc||[]).push([[35397],{28453:(n,e,i)=>{i.d(e,{R:()=>o,x:()=>l});var t=i(96540);const s={},r=t.createContext(s);function o(n){const e=t.useContext(r);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:o(n.components),t.createElement(r.Provider,{value:e},n.children)}},79433:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>a,contentTitle:()=>l,default:()=>p,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"Basic_Application/03_40pin_user_guide/gpio","title":"3.3.2 GPIO Application","description":"The development board comes pre-installed with the GPIO Python library Hobot.GPIO. Users can import the GPIO library using the following command:","source":"@site/i18n/en/docusaurus-plugin-content-docs-docs_s/current/03_Basic_Application/03_40pin_user_guide/02_gpio.md","sourceDirName":"03_Basic_Application/03_40pin_user_guide","slug":"/Basic_Application/03_40pin_user_guide/gpio","permalink":"/rdk_doc/en/rdk_s/Basic_Application/03_40pin_user_guide/gpio","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1769237656000,"sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"3.3.1 Pin Definitions and Applications","permalink":"/rdk_doc/en/rdk_s/Basic_Application/03_40pin_user_guide/01_40pin_define"},"next":{"title":"3.3.3 PWM Application","permalink":"/rdk_doc/en/rdk_s/Basic_Application/03_40pin_user_guide/pwm"}}');var s=i(74848),r=i(28453);const o={sidebar_position:2},l="3.3.2 GPIO Application",a={},d=[{value:"Setting Pin Numbering Mode",id:"setting-pin-numbering-mode",level:2},{value:"Warning Messages",id:"warning-messages",level:2},{value:"Pin Configuration",id:"pin-configuration",level:2},{value:"Input Operations",id:"input-operations",level:2},{value:"Output Operations",id:"output-operations",level:2},{value:"Cleaning Up Pin Usage",id:"cleaning-up-pin-usage",level:2},{value:"Checking Pin Status",id:"checking-pin-status",level:2},{value:"Edge Detection and Interrupts",id:"edge-detection-and-interrupts",level:2},{value:"wait_for_edge() Function",id:"wait_for_edge-function",level:3},{value:"event_detected() Function",id:"event_detected-function",level:3},{value:"Run a callback function when an edge event is detected",id:"run-a-callback-function-when-an-edge-event-is-detected",level:3},{value:"Disable interrupts",id:"disable-interrupts",level:3},{value:"Test Examples",id:"test-examples",level:2},{value:"hb_gpioinfo Tool Introduction",id:"hb_gpioinfo-tool-introduction",level:2}];function c(n){const e={a:"a",admonition:"admonition",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"332-gpio-application",children:"3.3.2 GPIO Application"})}),"\n",(0,s.jsxs)(e.p,{children:["The development board comes pre-installed with the GPIO Python library ",(0,s.jsx)(e.code,{children:"Hobot.GPIO"}),". Users can import the GPIO library using the following command:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-shell",children:'root@ubuntu:~# sudo python3\nPython 3.10.12 (main, Feb  4 2025, 14:57:36) [GCC 11.4.0] on linux\nType "help", "copyright", "credits" or "license" for more information.\n>>> import Hobot.GPIO as GPIO\n>>> GPIO.VERSION\n\'0.0.2\'\n>>> GPIO.model\n\'RDK_S100\'\n'})}),"\n",(0,s.jsx)(e.admonition,{type:"tip",children:(0,s.jsxs)(e.p,{children:["The pins mentioned below are for illustrative purposes only. Pin numbering may vary across different platforms; always refer to your specific hardware. Alternatively, you can directly use the code under the ",(0,s.jsx)(e.code,{children:"/app/40pin_samples/"})," directory, which has already been verified on the board."]})}),"\n",(0,s.jsx)(e.h2,{id:"setting-pin-numbering-mode",children:"Setting Pin Numbering Mode"}),"\n",(0,s.jsx)(e.p,{children:"The development board supports four pin numbering modes:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"BOARD"}),": Physical pin numbers that correspond directly to the silkscreen labels on the board."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"BCM"}),": GPIO naming convention defined by Broadcom SoC."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"CVM"}),": Uses strings instead of numbers, corresponding to signal names on the CVM/CVB connectors."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"SOC"}),": Numbers correspond to the internal GPIO pin numbers within the chip."]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["This document recommends using the ",(0,s.jsx)(e.code,{children:"BOARD"})," numbering mode. The numbering mode can be set as follows:",(0,s.jsx)(e.br,{}),"\n",(0,s.jsx)(e.strong,{children:"Note"}),": The mode can only be set once per session. To change it, you must first call ",(0,s.jsx)(e.code,{children:"GPIO.cleanup()"})," and then reconfigure the mode."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"GPIO.setmode(GPIO.BOARD)\n# or\nGPIO.setmode(GPIO.BCM)\n# or\nGPIO.setmode(GPIO.CVM)\n# or\nGPIO.setmode(GPIO.SOC)\n"})}),"\n",(0,s.jsx)(e.p,{children:"To query the current numbering mode:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"GPIO.getmode()\n"})}),"\n",(0,s.jsxs)(e.p,{children:["The program will output one of the following: ",(0,s.jsx)(e.code,{children:"BOARD"}),", ",(0,s.jsx)(e.code,{children:"BCM"}),", ",(0,s.jsx)(e.code,{children:"CVM"}),", ",(0,s.jsx)(e.code,{children:"SOC"}),", or ",(0,s.jsx)(e.code,{children:"None"}),"."]}),"\n",(0,s.jsx)(e.h2,{id:"warning-messages",children:"Warning Messages"}),"\n",(0,s.jsx)(e.p,{children:"Warning logs may appear in the following scenarios, though they do not affect normal functionality:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"The GPIO pin you are trying to use is already in use by another application."}),"\n",(0,s.jsxs)(e.li,{children:["You attempt to call ",(0,s.jsx)(e.code,{children:"GPIO.cleanup()"})," before setting the mode and channels."]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"To suppress warning messages, use the following command:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"GPIO.setwarnings(False)\n"})}),"\n",(0,s.jsx)(e.h2,{id:"pin-configuration",children:"Pin Configuration"}),"\n",(0,s.jsxs)(e.admonition,{type:"info",children:[(0,s.jsxs)(e.p,{children:["On the ",(0,s.jsx)(e.code,{children:"RDK S100"})," platform, ",(0,s.jsx)(e.code,{children:"40-pin"})," GPIO expansion is supported, with the following limitations:"]}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["One group of pins on the ",(0,s.jsx)(e.code,{children:"40-pin"})," header supports a multiplexed function (UART2 or I2C5)."]}),"\n",(0,s.jsxs)(e.li,{children:["PCM-related pins on the ",(0,s.jsx)(e.code,{children:"40-pin"})," header require toggling DIP switches to be enabled."]}),"\n"]}),(0,s.jsx)(e.p,{children:"For more details, refer to the diagram below:"}),(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"http://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/01_Quick_start/image/hardware_interface/image-rdk_100_funcreuse_40pin-en.jpg",alt:"image-rdk_100_funcreuse_40pin"})}),(0,s.jsxs)(e.p,{children:["For pin definitions, please refer to ",(0,s.jsx)(e.a,{href:"/rdk_doc/en/rdk_s/Basic_Application/03_40pin_user_guide/01_40pin_define#40pin_define",children:"Pin Configuration and Definitions"}),"."]})]}),"\n",(0,s.jsx)(e.p,{children:"Before using a GPIO pin, you must configure it as follows:"}),"\n",(0,s.jsx)(e.p,{children:"To set a pin as input:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"GPIO.setup(channel, GPIO.IN)\n"})}),"\n",(0,s.jsx)(e.p,{children:"To set a pin as output:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"GPIO.setup(channel, GPIO.OUT)\n"})}),"\n",(0,s.jsx)(e.p,{children:"You can also specify an initial value for an output channel, for example:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"GPIO.setup(channel, GPIO.OUT, initial=GPIO.HIGH)\n"})}),"\n",(0,s.jsx)(e.p,{children:"Additionally, the library supports configuring multiple output channels simultaneously, for example:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# Set GPIO pins (18, 12, 13) as outputs\nchannels = [18, 12, 13]\nGPIO.setup(channels, GPIO.OUT)\n"})}),"\n",(0,s.jsx)(e.h2,{id:"input-operations",children:"Input Operations"}),"\n",(0,s.jsx)(e.p,{children:"To read the value of a channel, use:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"GPIO.input(channel)\n"})}),"\n",(0,s.jsxs)(e.p,{children:["This command returns either ",(0,s.jsx)(e.code,{children:"0"})," or ",(0,s.jsx)(e.code,{children:"1"}),", where ",(0,s.jsx)(e.code,{children:"0"})," represents ",(0,s.jsx)(e.code,{children:"GPIO.LOW"})," and ",(0,s.jsx)(e.code,{children:"1"})," represents ",(0,s.jsx)(e.code,{children:"GPIO.HIGH"}),"."]}),"\n",(0,s.jsx)(e.h2,{id:"output-operations",children:"Output Operations"}),"\n",(0,s.jsx)(e.p,{children:"To set the output state of a channel, use:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"GPIO.output(channel, state)\n"})}),"\n",(0,s.jsxs)(e.p,{children:["Here, ",(0,s.jsx)(e.code,{children:"state"})," can be either ",(0,s.jsx)(e.code,{children:"GPIO.LOW"})," or ",(0,s.jsx)(e.code,{children:"GPIO.HIGH"}),"."]}),"\n",(0,s.jsx)(e.h2,{id:"cleaning-up-pin-usage",children:"Cleaning Up Pin Usage"}),"\n",(0,s.jsx)(e.p,{children:"It is recommended to clean up GPIO channels before exiting your program:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"GPIO.cleanup()\n"})}),"\n",(0,s.jsx)(e.p,{children:"To clean up only specific channels, use:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# Clean up a single channel\nGPIO.cleanup(channel)\n# Clean up a group of channels\nGPIO.cleanup((channel1, channel2))\nGPIO.cleanup([channel1, channel2])\n"})}),"\n",(0,s.jsx)(e.h2,{id:"checking-pin-status",children:"Checking Pin Status"}),"\n",(0,s.jsx)(e.p,{children:"This feature allows you to check the current function of a GPIO channel:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"GPIO.gpio_function(channel)\n"})}),"\n",(0,s.jsxs)(e.p,{children:["This function returns either ",(0,s.jsx)(e.code,{children:"IN"})," or ",(0,s.jsx)(e.code,{children:"OUT"}),"."]}),"\n",(0,s.jsx)(e.h2,{id:"edge-detection-and-interrupts",children:"Edge Detection and Interrupts"}),"\n",(0,s.jsxs)(e.p,{children:["An edge refers to a transition in an electrical signal\u2014either ",(0,s.jsx)(e.strong,{children:"from low to high"})," (rising edge) or ",(0,s.jsx)(e.strong,{children:"from high to low"})," (falling edge). Such transitions can be treated as events that trigger CPU interrupts."]}),"\n",(0,s.jsxs)(e.admonition,{type:"info",children:[(0,s.jsxs)(e.p,{children:["On the ",(0,s.jsx)(e.code,{children:"RDK S100"})," platform, pins labeled ",(0,s.jsx)(e.code,{children:"PERI_GPIO"})," on the ",(0,s.jsx)(e.code,{children:"40-pin"})," header ",(0,s.jsx)(e.strong,{children:"do not support interrupts"}),". Under the ",(0,s.jsx)(e.code,{children:"BOARD"})," numbering mode, these pins are numbered: ",(0,s.jsx)(e.strong,{children:"11"}),", ",(0,s.jsx)(e.strong,{children:"13"}),", ",(0,s.jsx)(e.strong,{children:"15"}),", ",(0,s.jsx)(e.strong,{children:"16"}),", ",(0,s.jsx)(e.strong,{children:"18"}),", ",(0,s.jsx)(e.strong,{children:"22"}),", ",(0,s.jsx)(e.strong,{children:"29"}),", ",(0,s.jsx)(e.strong,{children:"31"}),", ",(0,s.jsx)(e.strong,{children:"36"}),", and ",(0,s.jsx)(e.strong,{children:"37"}),"."]}),(0,s.jsxs)(e.p,{children:["For pin definitions, please refer to ",(0,s.jsx)(e.a,{href:"/rdk_doc/en/rdk_s/Basic_Application/03_40pin_user_guide/01_40pin_define#40pin_define",children:"Pin Configuration and Definitions"}),"."]})]}),"\n",(0,s.jsx)(e.p,{children:"The GPIO library provides three methods for detecting input events:"}),"\n",(0,s.jsx)(e.h3,{id:"wait_for_edge-function",children:"wait_for_edge() Function"}),"\n",(0,s.jsx)(e.p,{children:"This function blocks the calling thread until the specified edge transition is detected. Example usage:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"GPIO.wait_for_edge(channel, GPIO.RISING)\n"})}),"\n",(0,s.jsxs)(e.p,{children:["The second parameter specifies the edge type to detect and can be one of ",(0,s.jsx)(e.code,{children:"GPIO.RISING"}),", ",(0,s.jsx)(e.code,{children:"GPIO.FALLING"}),", or ",(0,s.jsx)(e.code,{children:"GPIO.BOTH"}),". You can also specify a timeout (in milliseconds):"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# Timeout in milliseconds\nGPIO.wait_for_edge(channel, GPIO.RISING, timeout=500)\n"})}),"\n",(0,s.jsxs)(e.p,{children:["If the signal changes within the timeout period, the function returns the channel number. If the timeout expires, it returns ",(0,s.jsx)(e.code,{children:"None"}),"."]}),"\n",(0,s.jsx)(e.h3,{id:"event_detected-function",children:"event_detected() Function"}),"\n",(0,s.jsx)(e.p,{children:"This function allows you to periodically check whether an event has occurred since the last call. It can be set up and used as follows:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'# Enable rising edge detection on the channel\nGPIO.add_event_detect(channel, GPIO.RISING)\nif GPIO.event_detected(channel):\n    print("Rising edge event detected")\n'})}),"\n",(0,s.jsxs)(e.p,{children:["You can detect events of ",(0,s.jsx)(e.code,{children:"GPIO.RISING"}),", ",(0,s.jsx)(e.code,{children:"GPIO.FALLING"}),", or ",(0,s.jsx)(e.code,{children:"GPIO.BOTH"}),"."]}),"\n",(0,s.jsx)(e.h3,{id:"run-a-callback-function-when-an-edge-event-is-detected",children:"Run a callback function when an edge event is detected"}),"\n",(0,s.jsx)(e.p,{children:"This feature can be used to register a callback function, which runs in a separate processing thread. Usage is as follows:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'# define callback function\ndef callback_fn(channel):\n    print("Callback called from channel %s" % channel)\n\n# enable rising detection\nGPIO.add_event_detect(channel, GPIO.RISING, callback=callback_fn)\n'})}),"\n",(0,s.jsx)(e.p,{children:"If needed, you can also add multiple callbacks as shown below:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'def callback_one(channel):\n    print("First Callback")\n\ndef callback_two(channel):\n    print("Second Callback")\n\nGPIO.add_event_detect(channel, GPIO.RISING)\nGPIO.add_event_callback(channel, callback_one)\nGPIO.add_event_callback(channel, callback_two)\n'})}),"\n",(0,s.jsx)(e.p,{children:"Since all callback functions run on the same thread, different callbacks are executed sequentially rather than concurrently."}),"\n",(0,s.jsx)(e.p,{children:"To prevent the callback function from being called multiple times by merging multiple events into a single event, you can optionally set a debounce time:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# bouncetime unit is ms\nGPIO.add_event_detect(channel, GPIO.RISING, callback=callback_fn, bouncetime=200)\n"})}),"\n",(0,s.jsx)(e.h3,{id:"disable-interrupts",children:"Disable interrupts"}),"\n",(0,s.jsx)(e.p,{children:"If edge detection is no longer needed, you can remove it as follows:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"GPIO.remove_event_detect(channel)\n"})}),"\n",(0,s.jsx)(e.h2,{id:"test-examples",children:"Test Examples"}),"\n",(0,s.jsxs)(e.p,{children:["Main test examples are provided under the ",(0,s.jsx)(e.code,{children:"/app/40pin_samples/"})," directory:"]}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Test Example Name"}),(0,s.jsx)(e.th,{children:"Description"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"simple_out.py"}),(0,s.jsxs)(e.td,{children:["Single pin ",(0,s.jsx)(e.code,{children:"output"})," test"]})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"simple_input.py"}),(0,s.jsxs)(e.td,{children:["Single pin ",(0,s.jsx)(e.code,{children:"input"})," test"]})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"button_led.py"}),(0,s.jsx)(e.td,{children:"One pin used as button input, another controls an LED"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"button_event.py"}),(0,s.jsx)(e.td,{children:"Capture rising and falling edge events on a pin"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"button_interrupt.py"}),(0,s.jsx)(e.td,{children:"Handle rising and falling edge events via interrupts"})]})]})]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["GPIO configured in ",(0,s.jsx)(e.code,{children:"output mode"}),", toggling output level every 1 second to control an LED blinking on and off. Test code: ",(0,s.jsx)(e.code,{children:"simple_out.py"}),":"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\nimport sys\nimport signal\nimport Hobot.GPIO as GPIO\nimport time\n\n\ndef signal_handler(signal, frame):\n    sys.exit(0)\n\n\n# Define the GPIO pin used as output_pin\n\n\ndef determine_pins():\n    board_id = GPIO.gpio_pin_data.parse_boardid()\n    if GPIO.gpio_pin_data.if_s100_40pin(board_id):\n        return 37\n    else:\n        return 26\n\n\ndef main():\n    output_pin = determine_pins()\n    # Set pin numbering mode to BOARD (physical pin numbers)\n    GPIO.setmode(GPIO.BOARD)\n    # Set as output mode, initialized to HIGH\n    GPIO.setup(output_pin, GPIO.OUT, initial=GPIO.HIGH)\n    # Track current pin state\n    curr_value = GPIO.HIGH\n    print(\"Starting demo now! Press CTRL+C to exit\")\n    try:\n        # Toggle LED every 1 second\n        while True:\n            time.sleep(1)\n            GPIO.output(output_pin, curr_value)\n            curr_value ^= GPIO.HIGH\n    finally:\n        GPIO.cleanup()\n\n\nif __name__ == '__main__':\n    signal.signal(signal.SIGINT, signal_handler)\n    main()\n"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["GPIO configured in ",(0,s.jsx)(e.code,{children:"input mode"}),", reading pin voltage level via busy polling. Test code: ",(0,s.jsx)(e.code,{children:"simple_input.py"}),":"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\nimport sys\nimport signal\nimport Hobot.GPIO as GPIO\nimport time\n\n\ndef signal_handler(signal, frame):\n    sys.exit(0)\n\n\n# Define the GPIO pin used as input_pin\n\n\nGPIO.setwarnings(False)\n\n\ndef determine_pins():\n    board_id = GPIO.gpio_pin_data.parse_boardid()\n    if GPIO.gpio_pin_data.if_s100_40pin(board_id):\n        return 37\n    else:\n        return 26\n\n\ndef main():\n    prev_value = None\n    input_pin = determine_pins()\n    # Set pin numbering mode to BOARD (physical pin numbers)\n    GPIO.setmode(GPIO.BOARD)\n    # Set as input mode\n    GPIO.setup(input_pin, GPIO.IN)\n\n    print("Starting demo now! Press CTRL+C to exit")\n    try:\n        while True:\n            # Read pin voltage level\n            value = GPIO.input(input_pin)\n            if value != prev_value:\n                if value == GPIO.HIGH:\n                    value_str = "HIGH"\n                else:\n                    value_str = "LOW"\n                print("Value read from pin {} : {}".format(input_pin, value_str))\n                prev_value = value\n            time.sleep(1)\n    finally:\n        GPIO.cleanup()\n\n\nif __name__==\'__main__\':\n    signal.signal(signal.SIGINT, signal_handler)\n    main()\n\n'})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["GPIO configured in input mode to capture rising and falling edge events. Test code: ",(0,s.jsx)(e.code,{children:"button_event.py"}),", which detects a falling edge on pin 24 and then controls the output of pin 23:"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\nimport sys\nimport signal\nimport Hobot.GPIO as GPIO\nimport time\n\n\ndef signal_handler(signal, frame):\n    sys.exit(0)\n\n\n# Define GPIO pins:\n# led_pin as output to light an LED\n# but_pin as input connected to a button\nBOARD_ID_PATH = "/sys/class/boardinfo/adc_boardid"\n\n\n# Disable warning messages\nGPIO.setwarnings(False)\n\n\ndef determine_pins():\n    board_id = GPIO.gpio_pin_data.parse_boardid()\n    if GPIO.gpio_pin_data.if_s100_40pin(board_id):\n        return 23, 24\n    else:\n        return 26, 27\n\n\ndef main():\n```led_pin, but_pin = determine_pins()\n    # Set pin numbering mode to BOARD (hardware numbering)\n    GPIO.setmode(GPIO.BOARD)\n    GPIO.setup(led_pin, GPIO.OUT)  # LED pin set as output\n    GPIO.setup(but_pin, GPIO.IN)  # button pin set as input\n\n    # Initial state for LEDs:\n    GPIO.output(led_pin, GPIO.LOW)\n\n    print("Starting demo now! Press CTRL+C to exit")\n    try:\n        while True:\n            print("Waiting for button event")\n            GPIO.wait_for_edge(but_pin, GPIO.FALLING)\n\n            # event received when button pressed\n            print("Button Pressed!")\n            GPIO.output(led_pin, GPIO.HIGH)\n            time.sleep(1)\n            GPIO.output(led_pin, GPIO.LOW)\n    finally:\n        GPIO.cleanup()  # cleanup all GPIOs\n\n\nif __name__ == \'__main__\':\n    signal.signal(signal.SIGINT, signal_handler)\n    main()\n\n'})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["Configure GPIO as input mode, enable GPIO interrupt functionality to respond to rising-edge and falling-edge events on the pin. The test code ",(0,s.jsx)(e.code,{children:"button_interrupt.py"})," implements the following:","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Pin 15 toggles HIGH/LOW with a period of 4 seconds and a 50% duty cycle (i.e., HIGH for 2 seconds, then LOW for 2 seconds), continuously running during program execution."}),"\n",(0,s.jsx)(e.li,{children:"Detect falling-edge interrupts on pin 24. The interrupt handler toggles pin 16 HIGH/LOW rapidly five times. When the user pulls pin 24 LOW, pin 16 will toggle with a 1-second period and 50% duty cycle (i.e., HIGH for 0.5 seconds, then LOW for 0.5 seconds), completing a total of 5 cycles."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\nimport sys\nimport signal\nimport Hobot.GPIO as GPIO\nimport time\n\n\ndef signal_handler(signal, frame):\n    sys.exit(0)\n\n\n# Define GPIO channels to use:\n# Pin 15 as output, can drive an LED\n# Pin 16 as output, can drive an LED\n# but_pin as input, can connect to a button\nled_pin_1 = 15  # BOARD numbering 15\nled_pin_2 = 16  # BOARD numbering 16\n\n# Disable warning messages\nGPIO.setwarnings(False)\n\n\ndef determine_pins():\n    board_id = GPIO.gpio_pin_data.parse_boardid()\n    if GPIO.gpio_pin_data.if_s100_40pin(board_id):\n        return 24\n    else:\n        return 27\n\n\n# When the button is pressed, LED 2 blinks rapidly 5 times\ndef blink(channel):\n    print("Blink LED 2")\n    for i in range(5):\n        GPIO.output(led_pin_2, GPIO.HIGH)\n        time.sleep(0.5)\n        GPIO.output(led_pin_2, GPIO.LOW)\n        time.sleep(0.5)\n\n\ndef main():\n    but_pin = determine_pins()\n    # Pin Setup:\n    GPIO.setmode(GPIO.BOARD)  # BOARD pin-numbering scheme\n    GPIO.setup([led_pin_1, led_pin_2], GPIO.OUT)  # LED pins set as output\n    GPIO.setup(but_pin, GPIO.IN)  # button pin set as input\n\n    # Initial state for LEDs:\n    GPIO.output(led_pin_1, GPIO.LOW)\n    GPIO.output(led_pin_2, GPIO.LOW)\n\n    # Register the blink function as the interrupt handler for falling-edge events on the button pin\n    GPIO.add_event_detect(but_pin, GPIO.FALLING, callback=blink, bouncetime=10)\n    # Start demo: LED1 blinks slowly\n    print("Starting demo now! Press CTRL+C to exit")\n    try:\n        while True:\n            # blink LED 1 slowly\n            GPIO.output(led_pin_1, GPIO.HIGH)\n            time.sleep(2)\n            GPIO.output(led_pin_1, GPIO.LOW)\n            time.sleep(2)\n    finally:\n        GPIO.cleanup()  # cleanup all GPIOs\n\n\nif __name__ == \'__main__\':\n    signal.signal(signal.SIGINT, signal_handler)\n    main()\n\n'})}),"\n",(0,s.jsx)(e.h2,{id:"hb_gpioinfo-tool-introduction",children:"hb_gpioinfo Tool Introduction"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"hb_gpioinfo"})," is a GPIO utility tool adapted for the RDK S100, which displays the correspondence between PinName and PinNum on the current development board. Example command output is shown below:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-shell",children:"sunrise@ubuntu:/root$ sudo hb_gpioinfo\n|--- ---------------- --------------------|\n|Idx|        Pin Name|            Pin Func|\n|--- ---------------- --------------------|\n|439|        GNSS_INT|                gpio|\n|--- ---------------- --------------------|\n|440|       PERI_RSTO|      Not Configured|\n|--- ---------------- --------------------|\n|441|        CAM_PINT|      Not Configured|\n|--- ---------------- --------------------|\n|442|          SD_1V8|        video_sd_1v8|\n|--- ---------------- --------------------|\n|443|      SD_BUS_POW|      Not Configured|\n|--- ---------------- --------------------|\n|444|     SENSOR0_ERR|      Not Configured|\n|--- ---------------- --------------------|\n|445|     SENSOR1_ERR|      Not Configured|\n|--- ---------------- --------------------|\n|446|     SENSOR2_ERR|      Not Configured|\n|--- ---------------- --------------------|\n|447|     SENSOR3_ERR|      Not Configured|\n|--- ---------------- --------------------|\n|448|     SENSOR4_ERR|      Not Configured|\n|--- ---------------- --------------------|\n|449|     SENSOR5_ERR|      Not Configured|\n|--- ---------------- --------------------|\n|450|     SENSOR6_ERR|      Not Configured|\n|--- ---------------- --------------------|\n|451|     SENSOR7_ERR|      Not Configured|\n|--- ---------------- --------------------|\n|452|     SENSOR8_ERR|      Not Configured|\n|--- ---------------- --------------------|\n|453|     SENSOR9_ERR|                gpio|\n|--- ---------------- --------------------|\n|454|    SENSOR10_ERR|      Not Configured|\n|--- ---------------- --------------------|\n|455|    SENSOR11_ERR|      Not Configured|\n|--- ---------------- --------------------|\n|456|     LPWM0_DOUT0|     cam_lpwm0_dout0|\n|--- ---------------- --------------------|\n|457|     LPWM0_DOUT1|     cam_lpwm0_dout1|\n|--- ---------------- --------------------|\n|458|     LPWM0_DOUT2|     cam_lpwm0_dout2|\n|--- ---------------- --------------------|\n|459|     LPWM0_DOUT3|     cam_lpwm0_dout3|\n|--- ---------------- --------------------|\n|460|     LPWM1_DOUT0|     cam_lpwm1_dout0|\n|--- ---------------- --------------------|\n|461|     LPWM1_DOUT1|     cam_lpwm1_dout1|\n|--- ---------------- --------------------|\n|462|     LPWM1_DOUT2|     cam_lpwm1_dout2|\n|--- ---------------- --------------------|\n|463|     LPWM1_DOUT3|     cam_lpwm1_dout3|\n|--- ---------------- --------------------|\n|464|        I2C0_SCL|        cam_i2c0_scl|\n|--- ---------------- --------------------|\n|465|        I2C0_SDA|        cam_i2c0_sda|\n|--- ---------------- --------------------|\n|466|        I2C1_SCL|        cam_i2c1_scl|\n|--- ---------------- --------------------|\n|467|        I2C1_SDA|        cam_i2c1_sda|\n|--- ---------------- --------------------|\n|468|        I2C2_SCL|        cam_i2c2_scl|\n|--- ---------------- --------------------|\n|469|        I2C2_SDA|        cam_i2c2_sda|\n|--- ---------------- --------------------|\n|470|        I2C3_SCL|        cam_i2c3_scl|\n|--- ---------------- --------------------|\n|471|        I2C3_SDA|        cam_i2c3_sda|\n|--- ---------------- --------------------|\n|472|        I2C4_SCL|        cam_i2c4_scl|\n|--- ---------------- --------------------|\n|473|        I2C4_SDA|        cam_i2c4_sda|\n|--- ---------------- --------------------|\n|474|       UART1_RXD|      peri_uart1_rxd|\n|--- ---------------- --------------------|\n|475|       PCM0_MCLK|      Not Configured|\n|--- ---------------- --------------------|\n|476|       PCM0_BCLK|      Not Configured|\n|--- ---------------- --------------------|\n|477|      PCM0_FSYNC|      Not Configured|\n|--- ---------------- --------------------|\n|478|      PCM0_DATA0|      Not Configured|\n|--- ---------------- --------------------|\n|479|      PCM0_DATA1|      Not Configured|\n|--- ---------------- --------------------|\n|480|   EMAC_MDC_HSI0|  peri_emac_mdc_hsi0|\n|--- ---------------- --------------------|\n|481|  EMAC_MDIO_HSI0| peri_emac_mdio_hsi0|\n|--- ---------------- --------------------|\n```|482|          SD_CLK|      Not Configured|\n|--- ---------------- --------------------|\n|483|          SD_CMD|      Not Configured|\n|--- ---------------- --------------------|\n|484|        SD_DATA0|      Not Configured|\n|--- ---------------- --------------------|\n|485|        SD_DATA1|      Not Configured|\n|--- ---------------- --------------------|\n|486|        SD_DATA2|      Not Configured|\n|--- ---------------- --------------------|\n|487|        SD_DATA3|      Not Configured|\n|--- ---------------- --------------------|\n|488|        SD_DATA4|      Not Configured|\n|--- ---------------- --------------------|\n|489|        SD_DATA5|      Not Configured|\n|--- ---------------- --------------------|\n|490|        SD_DATA6|      Not Configured|\n|--- ---------------- --------------------|\n|491|        SD_DATA7|      Not Configured|\n|--- ---------------- --------------------|\n|492|    SD_DATA_STRB|      Not Configured|\n|--- ---------------- --------------------|\n|493|        SD_DET_N|      Not Configured|\n|--- ---------------- --------------------|\n|494|        SD_WPROT|      Not Configured|\n|--- ---------------- --------------------|\n|495|        I2C5_SCL|       peri_i2c5_scl|\n|--- ---------------- --------------------|\n|496|        I2C5_SDA|       peri_i2c5_sda|\n|--- ---------------- --------------------|\n|497|       SPI0_CSN0|      peri_spi0_csn0|\n|--- ---------------- --------------------|\n|498|       SPI0_CSN1|      peri_spi0_csn1|\n|--- ---------------- --------------------|\n|499|       SPI0_MOSI|      peri_spi0_mosi|\n|--- ---------------- --------------------|\n|500|       SPI0_MISO|      peri_spi0_miso|\n|--- ---------------- --------------------|\n|501|       SPI0_SCLK|      peri_spi0_sclk|\n|--- ---------------- --------------------|\n|502|       SPI1_CSN0|      peri_spi1_csn0|\n|--- ---------------- --------------------|\n|503|       SPI1_CSN1|      peri_spi1_csn1|\n|--- ---------------- --------------------|\n|504|       SPI1_MOSI|      peri_spi1_mosi|\n|--- ---------------- --------------------|\n|505|       SPI1_MISO|      peri_spi1_miso|\n|--- ---------------- --------------------|\n|506|       SPI1_SCLK|      peri_spi1_sclk|\n|--- ---------------- --------------------|\n|507|       UART0_TXD|      peri_uart0_txd|\n|--- ---------------- --------------------|\n|508|       UART0_RXD|      peri_uart0_rxd|\n|--- ---------------- --------------------|\n|509|      UART0_RTSN|     peri_uart0_rtsn|\n|--- ---------------- --------------------|\n|510|      UART0_CTSN|     peri_uart0_ctsn|\n|--- ---------------- --------------------|\n|511|       UART1_TXD|      peri_uart1_txd|\n|--- ---------------- --------------------|\n|--- ---------------- --------------------|\n"})})]})}function p(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(c,{...n})}):c(n)}}}]);