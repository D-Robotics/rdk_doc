"use strict";(self.webpackChunkrdk_doc=self.webpackChunkrdk_doc||[]).push([[99020],{28453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>d});var t=r(96540);const s={},i=t.createContext(s);function a(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(i.Provider,{value:n},e.children)}},53063:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"Advanced_development/mcu_development/S100/mcu_adc","title":"ADC Usage Guide","description":"Hardware Support","source":"@site/i18n/en/docusaurus-plugin-content-docs-docs_s/current/07_Advanced_development/05_mcu_development/01_S100/07_mcu_adc.md","sourceDirName":"07_Advanced_development/05_mcu_development/01_S100","slug":"/Advanced_development/mcu_development/S100/mcu_adc","permalink":"/rdk_doc/en/rdk_s/Advanced_development/mcu_development/S100/mcu_adc","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1770017089000,"sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"tutorialSidebar","previous":{"title":"SPI Usage Guide","permalink":"/rdk_doc/en/rdk_s/Advanced_development/mcu_development/S100/mcu_spi"},"next":{"title":"IPC Usage Guide","permalink":"/rdk_doc/en/rdk_s/Advanced_development/mcu_development/S100/mcu_ipc"}}');var s=r(74848),i=r(28453);const a={sidebar_position:7},d="ADC Usage Guide",o={},c=[{value:"Hardware Support",id:"hardware-support",level:2},{value:"Software Driver",id:"software-driver",level:2},{value:"Usage Flow",id:"usage-flow",level:3},{value:"Key Differences",id:"key-differences",level:3},{value:"Code Paths",id:"code-paths",level:2},{value:"Application Examples",id:"application-examples",level:2},{value:"ADC Software-Triggered Single Conversion Application",id:"adc-software-triggered-single-conversion-application",level:3},{value:"Usage Example",id:"usage-example",level:4},{value:"ADC Software-Triggered Continuous Conversion Application",id:"adc-software-triggered-continuous-conversion-application",level:3},{value:"Key Configuration",id:"key-configuration",level:4},{value:"Usage Example",id:"usage-example-1",level:4},{value:"Non-interrupt Mode",id:"non-interrupt-mode",level:5},{value:"Interrupt Mode",id:"interrupt-mode",level:5},{value:"Application Programming Interface",id:"application-programming-interface",level:3},{value:"void Adc_Init(const Adc_ConfigType* ConfigPtr)",id:"void-adc_initconst-adc_configtype-configptr",level:4},{value:"Std_ReturnType Adc_SetupResultBuffer(Adc_GroupType Group, const Adc_ValueGroupType* DataBufferPtr)",id:"std_returntype-adc_setupresultbufferadc_grouptype-group-const-adc_valuegrouptype-databufferptr",level:4},{value:"void Adc_DeInit(void)",id:"void-adc_deinitvoid",level:4},{value:"void Adc_StartGroupConversion(Adc_GroupType Group)",id:"void-adc_startgroupconversionadc_grouptype-group",level:4},{value:"Std_ReturnType Adc_ReadGroup(Adc_GroupType Group, Adc_ValueGroupType* DataBufferPtr)",id:"std_returntype-adc_readgroupadc_grouptype-group-adc_valuegrouptype-databufferptr",level:4},{value:"void Adc_EnableHardwareTrigger(Adc_GroupType Group)",id:"void-adc_enablehardwaretriggeradc_grouptype-group",level:4},{value:"void Adc_DisableHardwareTrigger(Adc_GroupType Group)",id:"void-adc_disablehardwaretriggeradc_grouptype-group",level:4},{value:"void Adc_EnableGroupNotification(Adc_GroupType Group)",id:"void-adc_enablegroupnotificationadc_grouptype-group",level:4},{value:"void Adc_DisableGroupNotification(Adc_GroupType Group)",id:"void-adc_disablegroupnotificationadc_grouptype-group",level:4},{value:"Adc_StatusType Adc_GetGroupStatus(Adc_GroupType Group)",id:"adc_statustype-adc_getgroupstatusadc_grouptype-group",level:4},{value:"Adc_StreamNumSampleType Adc_GetStreamLastPointer(Adc_GroupType Group, Adc_ValueGroupType** PtrToSamplePtr)",id:"adc_streamnumsampletype-adc_getstreamlastpointeradc_grouptype-group-adc_valuegrouptype-ptrtosampleptr",level:4},{value:"void Adc_GetVersionInfo(Std_VersionInfoType* versioninfo)",id:"void-adc_getversioninfostd_versioninfotype-versioninfo",level:4},{value:"Std_ReturnType Adc_SetPowerState(Adc_PowerStateRequestResultType* Result)",id:"std_returntype-adc_setpowerstateadc_powerstaterequestresulttype-result",level:4},{value:"Std_ReturnType Adc_GetCurrentPowerState(Adc_PowerStateType* CurrentPowerState, Adc_PowerStateRequestResultType* Result)",id:"std_returntype-adc_getcurrentpowerstateadc_powerstatetype-currentpowerstate-adc_powerstaterequestresulttype-result",level:4},{value:"Std_ReturnType Adc_GetTargetPowerState(Adc_PowerStateType* TargetPowerState, Adc_PowerStateRequestResultType* Result)",id:"std_returntype-adc_gettargetpowerstateadc_powerstatetype-targetpowerstate-adc_powerstaterequestresulttype-result",level:4},{value:"Std_ReturnType Adc_PreparePowerState(Adc_PowerStateType PowerState, Adc_PowerStateRequestResultType* Result)",id:"std_returntype-adc_preparepowerstateadc_powerstatetype-powerstate-adc_powerstaterequestresulttype-result",level:4},{value:"Std_ReturnType Adc_PreparePowerState(Adc_PowerStateType PowerState, Adc_PowerStateRequestResultType* Result)",id:"std_returntype-adc_preparepowerstateadc_powerstatetype-powerstate-adc_powerstaterequestresulttype-result-1",level:4},{value:"void Adc_EnableWdgNotification(Adc_ChannelType ChannelId)",id:"void-adc_enablewdgnotificationadc_channeltype-channelid",level:4},{value:"void Adc_DisableWdgNotification(Adc_ChannelType ChannelId)",id:"void-adc_disablewdgnotificationadc_channeltype-channelid",level:4}];function l(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"adc-usage-guide",children:"ADC Usage Guide"})}),"\n",(0,s.jsx)(n.h2,{id:"hardware-support",children:"Hardware Support"}),"\n",(0,s.jsx)(n.p,{children:"The S100 ADC has one ADC hardware unit, containing a total of 15 channels: channel0 to channel13 and channel15."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"ADC measurable voltage range: 100 mV \u2013 1700 mV."}),"\n",(0,s.jsx)(n.li,{children:"Only one group is allowed under hardware-triggered or inject mode."}),"\n",(0,s.jsx)(n.li,{children:"ADC calibration must be performed when the temperature changes by more than 20\xb0C."}),"\n",(0,s.jsx)(n.li,{children:"ADC user interface usage must ensure that the power-on self-test has completed before proceeding."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"software-driver",children:"Software Driver"}),"\n",(0,s.jsx)(n.p,{children:"There are actually two sets of ADC drivers in the code, with the following differences:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Standard ADC Driver (Main ADC Driver)"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Located in the ",(0,s.jsx)(n.code,{children:"McalCdd/Adc"})," directory, includes a complete ADC module implementation with files such as ",(0,s.jsx)(n.code,{children:"Adc.h"}),", ",(0,s.jsx)(n.code,{children:"Adc.c"}),", ",(0,s.jsx)(n.code,{children:"Adc_Lld.h"}),", and ",(0,s.jsx)(n.code,{children:"Adc_Lld.c"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"Provides full ADC functionality."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Private ADC Driver"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Located in the ",(0,s.jsx)(n.code,{children:"McalCdd/Adc"})," directory, includes ",(0,s.jsx)(n.code,{children:"Adc_Private.h"})," and ",(0,s.jsx)(n.code,{children:"Adc_Private.c"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"Provides simplified interfaces specific for internal use."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"usage-flow",children:"Usage Flow"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Typical usage flow for the Standard ADC Driver:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"// 1. Initialize ADC module\nAdc_Init(&Adc_Config);\n// 2. Set up result buffer\nAdc_SetupResultBuffer(AdcGroup_0, dataBuffer);\n// 3. Start conversion\nAdc_StartGroupConversion(AdcGroup_0);\n// 4. Read results\nAdc_ReadGroup(AdcGroup_0, dataBuffer);\n// 5. Stop conversion\nAdc_StopGroupConversion(AdcGroup_0);\n// 6. De-initialize\nAdc_DeInit();\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Usage flow for the Private ADC Driver:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"// 1. Initialize ADC hardware\nAdc_Private_Init(0);\n// 2. Read result from a specific channel\nAdc_Private_ReadChannelResult(0, channel, &result);\n// 3. De-initialize\nAdc_Private_DeInit(0);\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"key-differences",children:"Key Differences"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Feature"}),(0,s.jsx)(n.th,{children:"Standard ADC Driver"}),(0,s.jsx)(n.th,{children:"Private ADC Driver"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Complexity"}),(0,s.jsx)(n.td,{children:"Full-featured ADC driver implementation"}),(0,s.jsx)(n.td,{children:"Simplified interface with limited features"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Configuration Method"}),(0,s.jsx)(n.td,{children:"Uses complete configuration structures (e.g., Adc_GroupsCfg)"}),(0,s.jsx)(n.td,{children:"Direct hardware register manipulation"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"API Richness"}),(0,s.jsx)(n.td,{children:"Provides comprehensive ADC APIs"}),(0,s.jsx)(n.td,{children:"Offers only basic initialization and read functions"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Interrupt Support"}),(0,s.jsx)(n.td,{children:"Full interrupt and callback mechanism"}),(0,s.jsx)(n.td,{children:"No interrupt usage"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Conversion Mode"}),(0,s.jsx)(n.td,{children:"Single and continuous conversions"}),(0,s.jsx)(n.td,{children:"Supports only single conversion"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Trigger Mode"}),(0,s.jsx)(n.td,{children:"Hardware and software triggers"}),(0,s.jsx)(n.td,{children:"Supports only software trigger"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Threshold Checking"}),(0,s.jsx)(n.td,{children:"Software and hardware threshold checking"}),(0,s.jsx)(n.td,{children:"No threshold checking support"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Injected Conversion"}),(0,s.jsx)(n.td,{children:"Supports both injected and normal conversions"}),(0,s.jsx)(n.td,{children:"Supports only normal conversion"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Error Handling"}),(0,s.jsx)(n.td,{children:"Comprehensive error detection and reporting"}),(0,s.jsx)(n.td,{children:"Basic error handling"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"code-paths",children:"Code Paths"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:(0,s.jsx)(n.strong,{children:"File Path"})}),(0,s.jsx)(n.th,{children:(0,s.jsx)(n.strong,{children:"Purpose"})})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"McalCdd/Adc/inc/Adc.h"})}),(0,s.jsx)(n.td,{children:"Public API interface for upper-layer calls."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"McalCdd/Adc/inc/Adc_Lld.h"})}),(0,s.jsx)(n.td,{children:"Declares low-level hardware operation functions."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"McalCdd/Adc/inc/Adc_Private.h"})}),(0,s.jsx)(n.td,{children:"Defines private structures, macros, and function declarations."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"McalCdd/Adc/src/Adc.c"})}),(0,s.jsx)(n.td,{children:"Implements public APIs, calling low-level functions."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"McalCdd/Adc/src/Adc_Lld.c"})}),(0,s.jsx)(n.td,{children:"Implements low-level hardware operations by directly configuring registers."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"McalCdd/Adc/src/Adc_Private.c"})}),(0,s.jsx)(n.td,{children:"Implements private functions supporting internal driver logic."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"McalCdd/Common/Register/inc/Adc_Register.h"})}),(0,s.jsx)(n.td,{children:"Defines ADC peripheral register addresses and bit fields."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Platform/Schm/SchM_Adc.h"})}),(0,s.jsx)(n.td,{children:"Manages ADC access permissions and resource protection (e.g., interrupt safety)."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Config/McalCdd/gen_s100_sip_B_mcu1/Adc/inc/Adc_PBcfg.h"})}),(0,s.jsx)(n.td,{children:"Defines board-level peripheral configuration parameters (e.g., channels, sampling rate)."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Config/McalCdd/gen_s100_sip_B_mcu1/Adc/inc/Adc_Cfg.h"})}),(0,s.jsx)(n.td,{children:"Provides general configuration macros or default parameters (e.g., max channel count, interrupt priority)."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Config/McalCdd/gen_s100_sip_B_mcu1/Adc/src/Adc_PBcfg.c"})}),(0,s.jsx)(n.td,{children:"Implements board-level configuration data (e.g., channel mapping, hardware parameters)."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"samples/Adc/src/Adc_Cmd.c"})}),(0,s.jsx)(n.td,{children:"Sample code for software-triggered single-shot ADC sampling using Adc_Private; suitable for simple scenarios."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"samples/Adc/src/Adc_SoftTrigerContinuous.c"})}),(0,s.jsx)(n.td,{children:"Sample code for software-triggered continuous ADC sampling using standard APIs; suitable for complex scenarios."})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"application-examples",children:"Application Examples"}),"\n",(0,s.jsx)(n.h3,{id:"adc-software-triggered-single-conversion-application",children:"ADC Software-Triggered Single Conversion Application"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"AdcTest"})," application performs a single-shot ADC sampling test on the device. Using the ",(0,s.jsx)(n.code,{children:"Adc_Private"})," implementation, it reads ADC values from a specific channel or multiple channels and displays the results in both raw and millivolt (mV) formats."]}),"\n",(0,s.jsx)(n.h4,{id:"usage-example",children:"Usage Example"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Syntax"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"AdcTest [ADC Channel]\n"})}),"\n",(0,s.jsx)(n.p,{children:"ADC Channel (optional): The specific ADC channel to read. If omitted, the command reads multiple channels."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Example"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Read ADC value from channel 1:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"D-Robotics:/$ Adc_Test 1\n[052.860562 0]--------------Adc_PrivateApiTest start-----------!\n[052.876472 0]AdcCurrentValue [1]: 2404 -> 1056 mv\n[052.869226 0]--------------Adc_PrivateApiTest end!-----------\n"})}),"\n",(0,s.jsx)(n.p,{children:"Read ADC values from all channels:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"D-Robotics:/$ Adc_Test\n[038.836359 0]--------------Adc_PrivateApiTest start-----------!\n[038.852268 0]AdcCurrentValue [0]: 1117 -> 490 mv\n[038.852648 0]BoradIdMsb code: 6!\n[038.853028 0]\n[038.853212 0]AdcCurrentValue [1]: 2393 -> 1051 mv\n[038.854451 0]BoradIdLsb code: 10!\n[038.854842 0]\n[038.855026 0]AdcCurrentValue [2]: 1754 -> 770 mv\n[038.856320 0]DDR TYPE code: 8!\n[038.856634 0]\n[038.856819 0]AdcCurrentValue [3]: 1725 -> 758 mv\n[038.858210 0]\n[038.858306 0]AdcCurrentValue [4]: 630 -> 276 mv\n[038.858760 0]\n[038.858945 0]AdcCurrentValue [5]: 2515 -> 1105 mv\n[038.860273 0]\n[038.860391 0]AdcCurrentValue [6]: 2492 -> 1095 mv\n[038.860925 0]\n[038.861109 0]AdcCurrentValue [7]: 2156 -> 947 mv\n[038.862341 0]\n[038.862525 0]AdcCurrentValue [8]: 2163 -> 950 mv\n[038.863067 0]\n[038.863252 0]AdcCurrentValue [9]: 2161 -> 949 mv\n[038.864483 0]\n[038.864667 0]AdcCurrentValue [10]: 2169 -> 953 mv\n[038.865220 0]\n[038.866262 0]AdcCurrentValue [11]: 2223 -> 977 mv\n[038.866665 0]\n[038.866850 0]AdcCurrentValue [12]: 1837 -> 807 mv\n[038.868234 0]\n[038.868331 0]AdcCurrentValue [13]: 2101 -> 923 mv\n[038.868825 0]\n[038.868999 0]PASS.\n[038.869226 0]--------------Adc_PrivateApiTest end!-----------\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"adc-software-triggered-continuous-conversion-application",children:"ADC Software-Triggered Continuous Conversion Application"}),"\n",(0,s.jsx)(n.p,{children:"The ADC software-triggered continuous sampling application is implemented based on the standard ADC driver. It features automatic repeated conversions\u2014immediately starting the next conversion upon completion of the current one without requiring additional triggers. This is suitable for scenarios requiring continuous signal monitoring, though it incurs relatively higher power consumption due to continuous operation."}),"\n",(0,s.jsx)(n.h4,{id:"key-configuration",children:"Key Configuration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"// McalCdd/gen_s100_sip_B_mcu1/Adc/src/Adc_PBcfg.c\nstatic const Adc_GroupCfg Adc_GroupsCfg[] =\n{\n    /**< @brief Group0 -- Logical Unit Id 0 -- Hardware Unit ADC0 */\n    {\n        /**< @brief Index of group */\n        0U, /* GroupId */\n        /**< @brief ADC Logical Unit Id that the group belongs to */\n        (uint8)0, /* UnitId */\n        /**< @brief Access mode */\n        ADC_ACCESS_MODE_SINGLE, /* AccessMode */\n        /**< @brief Conversion mode */\n        ADC_CONV_MODE_CONTINUOUS, /* Mode */  // Use continuous conversion mode\n        /**< @brief Conversion type */\n        ADC_NORMAL_CONV, /* Type */ // Can select normal or injected conversion\n#if (ADC_PRIORITY_IMPLEMENTATION != ADC_PRIORITY_NONE)\n        /**< @brief Priority configured */\n        (Adc_GroupPriorityType)ADC_GROUP_PRIORITY(0), /* Priority */\n#endif /* ADC_PRIORITY_IMPLEMENTATION != ADC_PRIORITY_NONE */\n        /**< @brief Trigger source configured */\n        ADC_TRIGG_SRC_SW, /* TriggerSource */  // Software trigger\n#if (STD_ON == ADC_HW_TRIGGER_API)\n        /**< @brief Hardware trigger source for the group */\n        0U, /* HwTriggerSource */\n#endif /* (STD_ON == ADC_HW_TRIGGER_API) */\n#if (STD_ON == ADC_GRP_NOTIF_CAPABILITY)\n        /**< @brief Notification function */\n        Adc_TestNormal_Notification_0, /* Notification */ // Notification function to inform upper layer that conversion is complete\n#endif /* (STD_ON == ADC_GRP_NOTIF_CAPABILITY) */\n    ............\n        /**< @brief Enables or Disables the ADC and DMA interrupts */\n        (uint8)(STD_ON), /* AdcWithoutInterrupt */  // STD_ON: non-interrupt mode; STD_OFF: interrupt mode; S100 uses non-interrupt mode by default\n#if (ADC_ENABLE_LIMIT_CHECK == STD_ON)\n        /**< @brief Enables or disables the usage of limit checking for an ADC group. */\n        (boolean)FALSE, /* AdcGroupLimitcheck */\n#endif /* (STD_ON == ADC_ENABLE_LIMIT_CHECK) */\n        { { 0x3FFFU } }, /* AssignedChannelMask */\n#if (ADC_SET_ADC_CONV_TIME_ONCE == STD_OFF)\n        &AdcLldGroupConfig_0 /* AdcLldGroupConfigPtr */\n#endif /* (ADC_SET_ADC_CONV_TIME_ONCE == STD_OFF) */\n    }\n};\n"})}),"\n",(0,s.jsx)(n.h4,{id:"usage-example-1",children:"Usage Example"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Syntax"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Adc_TestNormal [Action]\n"})}),"\n",(0,s.jsx)(n.h5,{id:"non-interrupt-mode",children:"Non-interrupt Mode"}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["Note: Set the ",(0,s.jsx)(n.code,{children:"AdcWithoutInterrupt"})," field in ",(0,s.jsx)(n.code,{children:"Adc_GroupsCfg"})," to ",(0,s.jsx)(n.code,{children:"STD_ON"}),"."]})}),"\n",(0,s.jsx)(n.p,{children:"Step 1: Start continuous ADC sampling"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"D-Robotics:/$ Adc_TestNormal start\n[0129.823385 0]Adc test running...\n"})}),"\n",(0,s.jsx)(n.p,{children:"Step 2: Read sampling results"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"D-Robotics:/$ Adc_TestNormal read noirq\n[0112.002331 0]not use irq\n[0112.002480 0]##############################\n[0112.002970 0] ResultBuffer0[0]: 1103 : 484 mv\n[0112.003502 0] ResultBuffer0[1]: 2346 : 1031 mv\n[0112.004044 0] ResultBuffer0[2]: 1728 : 759 mv\n[0112.004576 0] ResultBuffer0[3]: 1704 : 749 mv\n[0112.005108 0] ResultBuffer0[4]: 828 : 363 mv\n[0112.005629 0] ResultBuffer0[5]: 3411 : 1499 mv\n[0112.006171 0] ResultBuffer0[6]: 3180 : 1397 mv\n[0112.006713 0] ResultBuffer0[7]: 3051 : 1341 mv\n[0112.007256 0] ResultBuffer0[8]: 2935 : 1290 mv\n[0112.007798 0] ResultBuffer0[9]: 2820 : 1239 mv\n[0112.008341 0] ResultBuffer0[10]: 2731 : 1200 mv\n[0112.008894 0] ResultBuffer0[11]: 2645 : 1162 mv\n[0112.009448 0] ResultBuffer0[12]: 1854 : 814 mv\n[0112.009990 0] ResultBuffer0[13]: 1798 : 790 mv\n[0112.010533 0]==============================\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"Step 3: Stop continuous ADC sampling"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"D-Robotics:/$ Adc_TestNormal stop\n[0268.403214 0]Adc test exit.\n"})}),"\n",(0,s.jsx)(n.h5,{id:"interrupt-mode",children:"Interrupt Mode"}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["Note: Set the ",(0,s.jsx)(n.code,{children:"AdcWithoutInterrupt"})," field in ",(0,s.jsx)(n.code,{children:"Adc_GroupsCfg"})," to ",(0,s.jsx)(n.code,{children:"STD_OFF"}),"."]})}),"\n",(0,s.jsx)(n.p,{children:"Step 1: Start continuous ADC sampling"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"D-Robotics:/$ Adc_TestNormal start\n[0129.823385 0]Adc test running...\n"})}),"\n",(0,s.jsx)(n.p,{children:"Step 2: Read sampling results"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"D-Robotics:/$ Adc_TestNormal read irq\n[0195.226347 0]##############################\n[0195.228233 0] ResultBuffer0[0]: 1103 : 484 mv\n[0195.230181 0] ResultBuffer0[1]: 2346 : 1031 mv\n[0195.232191 0] ResultBuffer0[2]: 1727 : 759 mv\n[0195.234261 0] ResultBuffer0[3]: 1705 : 749 mv\n[0195.236271 0] ResultBuffer0[4]: 827 : 363 mv\n[0195.238261 0] ResultBuffer0[5]: 3396 : 1492 mv\n[0195.240231 0] ResultBuffer0[6]: 3229 : 1419 mv\n[0195.242241 0] ResultBuffer0[7]: 3076 : 1352 mv\n[0195.244292 0] ResultBuffer0[8]: 2953 : 1298 mv\n[0195.246263 0] ResultBuffer0[9]: 2841 : 1248 mv\n[0195.248331 0] ResultBuffer0[10]: 2735 : 1202 mv\n[0195.250341 0] ResultBuffer0[11]: 2657 : 1167 mv\n[0195.252392 0] ResultBuffer0[12]: 1856 : 815 mv\n[0195.254442 0] ResultBuffer0[13]: 1799 : 790 mv\n[0195.256431 0]==============================\n"})}),"\n",(0,s.jsx)(n.p,{children:"Step 3: Stop continuous ADC sampling"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"D-Robotics:/$ Adc_TestNormal stop\n[0268.403214 0]Adc test exit.\n"})}),"\n",(0,s.jsx)(n.h3,{id:"application-programming-interface",children:"Application Programming Interface"}),"\n",(0,s.jsx)(n.h4,{id:"void-adc_initconst-adc_configtype-configptr",children:"void Adc_Init(const Adc_ConfigType* ConfigPtr)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: Initializes the ADC hardware units and driver.\n\nSync/Async: Synchronous\nParameters(in)\n    None\nParameters(inout)\n    None\nParameters(out)\n    None\nReturn value: None\n"})}),"\n",(0,s.jsx)(n.h4,{id:"std_returntype-adc_setupresultbufferadc_grouptype-group-const-adc_valuegrouptype-databufferptr",children:"Std_ReturnType Adc_SetupResultBuffer(Adc_GroupType Group, const Adc_ValueGroupType* DataBufferPtr)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: Initializes the group-specific ADC result buffer pointer as configured\n             to point to the address provided by the pDataBufferPtr parameter.\n\nSync/Async: Synchronous\nParameters(in)\n    Group: Numeric ID of the requested ADC channel group.\n    DataBufferPtr: Pointer to the result data buffer.\nParameters(inout)\n    None\nParameters(out)\n    None\nReturn value: Std_ReturnType\n    E_OK: Result buffer pointer initialized correctly\n    E_NOT_OK: Operation failed or a development error occurred\n"})}),"\n",(0,s.jsx)(n.h4,{id:"void-adc_deinitvoid",children:"void Adc_DeInit(void)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: Returns all ADC hardware units to a state equivalent to their power-on reset state.\n\nSync/Async: Synchronous\nParameters(in)\n    ConfigPtr: Pointer to the configuration set in Variant PB\nParameters(inout)\n    None\nParameters(out)\n    None\nReturn value: None\n"})}),"\n",(0,s.jsx)(n.h4,{id:"void-adc_startgroupconversionadc_grouptype-group",children:"void Adc_StartGroupConversion(Adc_GroupType Group)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: Starts the conversion of all channels in the requested ADC channel group.\n\nSync/Async: Synchronous\nParameters(in)\n    Group: Numeric ID of the requested ADC channel group.\nParameters(inout)\n    None\nParameters(out)\n    None\nReturn value: None\n"})}),"\n",(0,s.jsx)(n.h4,{id:"std_returntype-adc_readgroupadc_grouptype-group-adc_valuegrouptype-databufferptr",children:"Std_ReturnType Adc_ReadGroup(Adc_GroupType Group, Adc_ValueGroupType* DataBufferPtr)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: Reads the group conversion results from the last completed conversion round of the requested group\n             and stores the channel values starting at the address pointed to by DataBufferPtr.\n             The group channel values are stored in ascending channel number order\n             (in contrast to the storage layout of the result buffer if streaming access is configured).\n\nSync/Async: Synchronous\nParameters(in)\n    Group: Numeric ID of the requested ADC channel group.\nParameters(inout)\n    None\nParameters(out)\n    DataBufferPtr: ADC results of all channels in the selected group are stored in the data buffer\n                   addressed by this pointer.\nReturn value: Std_ReturnType\n    E_OK: Results are available and written to the data buffer\n    E_NOT_OK: No results are available or a development error occurred\n"})}),"\n",(0,s.jsx)(n.h4,{id:"void-adc_enablehardwaretriggeradc_grouptype-group",children:"void Adc_EnableHardwareTrigger(Adc_GroupType Group)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: Enables the hardware trigger for the requested ADC channel group.\n\nSync/Async: Asynchronous\nParameters(in)\n    Group: Numeric ID of the requested ADC channel group.\nParameters(inout)\n    None\n    Parameters(out)  \n    DataBufferPtr: ADC results of all channels of the selected group are stored  \n                   in the data buffer addressed with the pointer.  \nReturn value: None  \n"})}),"\n",(0,s.jsx)(n.h4,{id:"void-adc_disablehardwaretriggeradc_grouptype-group",children:"void Adc_DisableHardwareTrigger(Adc_GroupType Group)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: Disables the hardware trigger for the requested ADC Channel group.  \n\nSync/Async: Asynchronous  \nParameters(in)  \n    Group: Numeric ID of requested ADC Channel group.  \nParameters(inout)  \n    None  \nParameters(out)  \n    None  \nReturn value: None  \n"})}),"\n",(0,s.jsx)(n.h4,{id:"void-adc_enablegroupnotificationadc_grouptype-group",children:"void Adc_EnableGroupNotification(Adc_GroupType Group)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: Enables the notification mechanism for the requested ADC Channel group.  \n\nSync/Async: Asynchronous  \nParameters(in)  \n    Group: Numeric ID of requested ADC Channel group.  \nParameters(inout)  \n    None  \nParameters(out)  \n    None  \nReturn value: None  \n"})}),"\n",(0,s.jsx)(n.h4,{id:"void-adc_disablegroupnotificationadc_grouptype-group",children:"void Adc_DisableGroupNotification(Adc_GroupType Group)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: Disables the notification mechanism for the requested ADC Channel group.  \n\nSync/Async: Asynchronous  \nParameters(in)  \n    Group: Numeric ID of requested ADC Channel group.  \nParameters(inout)  \n    None  \nParameters(out)  \n    None  \nReturn value: None  \n"})}),"\n",(0,s.jsx)(n.h4,{id:"adc_statustype-adc_getgroupstatusadc_grouptype-group",children:"Adc_StatusType Adc_GetGroupStatus(Adc_GroupType Group)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: Returns the conversion status of the requested ADC Channel group.  \n\nSync/Async: Asynchronous  \nParameters(in)  \n    Group: Numeric ID of requested ADC Channel group.  \nParameters(inout)  \n    None  \nParameters(out)  \n    None  \nReturn value: Adc_StatusType  \n\tConversion status for the requested group.  \n"})}),"\n",(0,s.jsx)(n.h4,{id:"adc_streamnumsampletype-adc_getstreamlastpointeradc_grouptype-group-adc_valuegrouptype-ptrtosampleptr",children:"Adc_StreamNumSampleType Adc_GetStreamLastPointer(Adc_GroupType Group, Adc_ValueGroupType** PtrToSamplePtr)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: Returns the number of valid samples per channel, stored in the result buffer.  \n             Reads a pointer, pointing to a position in the group result buffer.  \n             With the pointer position, the results of all group channels of the last  \n             completed conversion round can be accessed.  \n             With the pointer and the return value, all valid group conversion results can  \n             be accessed.  \n\nSync/Async: Synchronous  \nParameters(in)  \n    Group: Numeric ID of requested ADC Channel group.  \nParameters(inout)  \n    None  \nParameters(out)  \n    PtrToSamplePtr: Pointer to result buffer pointer.  \nReturn value: Adc_StreamNumSampleType  \n\tNumber of valid samples per channel.  \n"})}),"\n",(0,s.jsx)(n.h4,{id:"void-adc_getversioninfostd_versioninfotype-versioninfo",children:"void Adc_GetVersionInfo(Std_VersionInfoType* versioninfo)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: Returns the version information of this module.  \n\nSync/Async: Synchronous  \nParameters(in)  \n    None  \nParameters(inout)  \n    None  \nParameters(out)  \n    versioninfo: Pointer to where to store the version information of this module.  \nReturn value: None  \n\n"})}),"\n",(0,s.jsx)(n.h4,{id:"std_returntype-adc_setpowerstateadc_powerstaterequestresulttype-result",children:"Std_ReturnType Adc_SetPowerState(Adc_PowerStateRequestResultType* Result)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: This API configures the Adc module so that it enters the already prepared  \n             power state, chosen between a predefined set of configured ones.  \n\nSync/Async: Synchronous  \nParameters(in)  \n    None  \nParameters(inout)  \n    None  \nParameters(out)  \n    Result: If the API returns E_OK:  \n        ADC_SERVICE_ACCEPTED: Power state change executed.  \n    If the API returns E_NOT_OK:  \n        ADC_NOT_INIT: ADC Module not initialized.  \n        ADC_SEQUENCE_ERROR: wrong API call sequence.  \n        ADC_HW_FAILURE: the HW module has a failure which prevents it to enter the required power state.  \nReturn value: Std_ReturnType  \n    E_OK: Power Mode changed  \n    E_NOT_OK: request rejected  \n"})}),"\n",(0,s.jsx)(n.h4,{id:"std_returntype-adc_getcurrentpowerstateadc_powerstatetype-currentpowerstate-adc_powerstaterequestresulttype-result",children:"Std_ReturnType Adc_GetCurrentPowerState(Adc_PowerStateType* CurrentPowerState, Adc_PowerStateRequestResultType* Result)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: This API returns the current power state of the ADC HW unit.  \n\nSync/Async: Synchronous  \nParameters(in)  \n    None  \nParameters(inout)  \n    None  \nParameters(out)  \n    CurrentPowerState: The current power mode of the ADC HW Unit is returned in this parameter  \n    Result: If the API returns E_OK: ADC_SERVICE_ACCEPTED: Current power mode was returned  \n            If the API returns E_NOT_OK: ADC_NOT_INIT: ADC Module not initialized.  \nReturn value: Std_ReturnType  \n    E_OK: Mode could be read  \n    E_NOT_OK: request rejected  \n"})}),"\n",(0,s.jsx)(n.h4,{id:"std_returntype-adc_gettargetpowerstateadc_powerstatetype-targetpowerstate-adc_powerstaterequestresulttype-result",children:"Std_ReturnType Adc_GetTargetPowerState(Adc_PowerStateType* TargetPowerState, Adc_PowerStateRequestResultType* Result)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: This API returns the Target power state of the ADC HW unit.  \n\nSync/Async: Synchronous  \nParameters(in)  \n    None  \nParameters(inout)  \n    None  \nParameters(out)  \n    TargetPowerState: The target power mode of the ADC HW Unit is returned in this parameter  \n    Result: If the API returns E_OK: ADC_SERVICE_ACCEPTED: Target power mode was returned  \n            If the API returns E_NOT_OK: ADC_NOT_INIT: ADC Module not initialized.  \nReturn value: Std_ReturnType  \n    E_OK: Mode could be read  \n    E_NOT_OK: request rejected  \n"})}),"\n",(0,s.jsx)(n.h4,{id:"std_returntype-adc_preparepowerstateadc_powerstatetype-powerstate-adc_powerstaterequestresulttype-result",children:"Std_ReturnType Adc_PreparePowerState(Adc_PowerStateType PowerState, Adc_PowerStateRequestResultType* Result)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: This API starts the needed process to allow the ADC HW module to  \n             enter the requested power state.  \n\nSync/Async: Synchronous  \nParameters(in)  \n    PowerState: The target power state intended to be attained  \nParameters(inout)  \n    None  \nParameters(out)  \n    Result:  \n    If the API returns E_OK:  \n        ADC_SERVICE_ACCEPTED: ADC Module power state preparation was started.  \n    If the API returns E_NOT_OK:  \n        ADC_NOT_INIT: ADC Module not initialized.  \n        ADC_SEQUENCE_ERROR: wrong API call sequence (Current Power State = Target Power State).  \n        ADC_POWER_STATE_NOT_SUPP: ADC Module does not support the requested power state.  \n        ADC_TRANS_NOT_POSSIBLE: ADC Module cannot transition directly from the current power  \n                                state to the requested power state or the HW peripheral is still busy.  \nReturn value: Std_ReturnType  \n    E_OK: Preparation initiated successfully  \n    E_NOT_OK: request rejected  \n"})}),"\n",(0,s.jsx)(n.h4,{id:"std_returntype-adc_preparepowerstateadc_powerstatetype-powerstate-adc_powerstaterequestresulttype-result-1",children:"Std_ReturnType Adc_PreparePowerState(Adc_PowerStateType PowerState, Adc_PowerStateRequestResultType* Result)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: This API starts the needed process to allow the ADC HW module to  \n             enter the requested power state.  \n\nSync/Async: Synchronous  \nParameters(in)PowerState: The target power state intended to be attained\nParameters(inout)\n    None\nParameters(out)\n    Result:\n    If the API returns E_OK:\n        ADC_SERVICE_ACCEPTED: ADC Module power state preparation was started.\n    If the API returns E_NOT_OK:\n        ADC_NOT_INIT: ADC Module not initialized.\n        ADC_SEQUENCE_ERROR: wrong API call sequence (Current Power State = Target Power State).\n        ADC_POWER_STATE_NOT_SUPP: ADC Module does not support the requested power state.\n        ADC_TRANS_NOT_POSSIBLE: ADC Module cannot transition directly from the current power\n                                state to the requested power state or the HW peripheral is still busy.\nReturn value: Std_ReturnType\n    E_OK: Mode could be read\n    E_NOT_OK: request rejected\n"})}),"\n",(0,s.jsx)(n.h4,{id:"void-adc_enablewdgnotificationadc_channeltype-channelid",children:"void Adc_EnableWdgNotification(Adc_ChannelType ChannelId)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: Enable notification of a channel that has watchdog functionality\n             configured at initialization\n\nParameters(in)\n    Adc_ChannelType: Symbolic name of channel\nParameters(inout)\n    None\nParameters(out)\n    None\nReturn value: None\n"})}),"\n",(0,s.jsx)(n.h4,{id:"void-adc_disablewdgnotificationadc_channeltype-channelid",children:"void Adc_DisableWdgNotification(Adc_ChannelType ChannelId)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: Disable notification of a channel that has watchdog functionality\n             configured at initialization\n\nParameters(in)\n    Adc_ChannelType: Symbolic name of channel\nParameters(inout)\n    None\nParameters(out)\n    None\nReturn value: None\n"})})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);