"use strict";(self.webpackChunkrdk_doc=self.webpackChunkrdk_doc||[]).push([[6367],{28453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>d});var r=i(96540);const c={},t=r.createContext(c);function s(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:s(e.components),r.createElement(t.Provider,{value:n},e.children)}},86021:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>p,contentTitle:()=>d,default:()=>a,frontMatter:()=>s,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"Advanced_development/linux_development/driver_development_s100/driver_pcie/s100x_pcie_libhbpciehal","title":"PCIe User-space High Level API Introduction","description":"Introduction","source":"@site/i18n/en/docusaurus-plugin-content-docs-docs_s/current/07_Advanced_development/02_linux_development/04_driver_development_s100/13_driver_pcie/04_s100x_pcie_libhbpciehal.md","sourceDirName":"07_Advanced_development/02_linux_development/04_driver_development_s100/13_driver_pcie","slug":"/Advanced_development/linux_development/driver_development_s100/driver_pcie/s100x_pcie_libhbpciehal","permalink":"/rdk_doc/en/rdk_s/Advanced_development/linux_development/driver_development_s100/driver_pcie/s100x_pcie_libhbpciehal","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1769237656000,"sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Configuration of S100X PCIe Module Functionality under the Kernel","permalink":"/rdk_doc/en/rdk_s/Advanced_development/linux_development/driver_development_s100/driver_pcie/s100x_pcie_sw_setup"},"next":{"title":"WiFi Driver Debugging Guide","permalink":"/rdk_doc/en/rdk_s/Advanced_development/linux_development/driver_development_s100/driver_wifi"}}');var c=i(74848),t=i(28453);const s={sidebar_position:4},d="PCIe User-space High Level API Introduction",p={},l=[{value:"Introduction",id:"introduction",level:2},{value:"API List",id:"api-list",level:2},{value:"Usage Workflow",id:"usage-workflow",level:2},{value:"Publisher (chip#0)",id:"publisher-chip0",level:3},{value:"Subscriber (chip#1)",id:"subscriber-chip1",level:3}];function o(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(n.header,{children:(0,c.jsx)(n.h1,{id:"pcie-user-space-high-level-api-introduction",children:"PCIe User-space High Level API Introduction"})}),"\n",(0,c.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,c.jsxs)(n.p,{children:["The High Level API (",(0,c.jsx)(n.code,{children:"libhbpciehl.so"}),") is built upon the Low Level API (",(0,c.jsx)(n.code,{children:"libhbpcie.so"}),"), abstracting generic topic/subscribe/publish concepts and hiding hardware differences across various D-Robotics chip series. This enables users to utilize PCIe for data communication more conveniently."]}),"\n",(0,c.jsx)(n.p,{children:"Key supported features include:"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"Data transmission (publish)"}),"\n",(0,c.jsx)(n.li,{children:"Data reception (subscribe)"}),"\n",(0,c.jsxs)(n.li,{children:["Management of send/receive buffers","\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"Using built-in buffers"}),"\n",(0,c.jsx)(n.li,{children:"Using user-allocated buffers (requiring physically contiguous memory)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.h2,{id:"api-list",children:"API List"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-c",children:"pcieErrCode pcieInit(pcieHandler *ph, uint8_t chipID, uint8_t topicID);\npcieErrCode pcieDeInit(pcieHandler ph);\npcieErrCode pcieGetMaxTopicSize(pcieHandler ph, uint8_t *topicSize);\npcieErrCode pciePublish(pcieHandler ph, uint8_t weight);\npcieErrCode pcieSubscribe(pcieHandler ph);\npcieErrCode pcieGetMaxInnerBufSize(pcieHandler ph, uint32_t *size);\npcieErrCode pcieAllocInnerBuf(pcieHandler ph, uint32_t size, void **virtualAddr, uint64_t *physAddr);\npcieErrCode pcieRegisterUserBuf(pcieHandler ph, uint64_t physAddr, uint32_t size);\npcieErrCode pcieStartRecv(pcieHandler ph, recvDataCallBack fun, void *funData);\npcieErrCode pcieSendData(pcieHandler ph, uint32_t size);\n"})}),"\n",(0,c.jsx)(n.h2,{id:"usage-workflow",children:"Usage Workflow"}),"\n",(0,c.jsx)(n.p,{children:"The workflows for sender and receiver are illustrated below:"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/02_linux_development/driver_development_s100/pcie/hl_process.png",alt:"Image Description"})}),"\n",(0,c.jsx)(n.h3,{id:"publisher-chip0",children:"Publisher (chip#0)"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-c",children:"void main()\n{\n    uint32_t size;\n    void *addr;\n    uint64_t phys;\n    pcieHandler ph;\n    void *UserBuffer;\n    uint64_t UserBufferPhys;\n\n    /* connect chip1 topic0 */\n    pcieInit(&ph, 1, 0);\n\n    pciePublish(ph);\n\n    if (useInnerBuffer) {\n        pcieGetMaxInnerBufSize(ph, &size);\n        pcieAllocInnerBuf(ph, &addr, &phys, size);\n        /* fill user data to inner buffer */\n        ...\n\n    } else {\n        /* prepare the User data */\n        ...\n        /* use data in user buffer */\n        pcieRegisterUserBuf(ph, UserBufferPhys, size);\n    }\n\n    pcieSendData(ph, size);\n\n    pcieDeInit(ph);\n\n    return;\n}\n"})}),"\n",(0,c.jsx)(n.h3,{id:"subscriber-chip1",children:"Subscriber (chip#1)"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-c",children:"void recvDataHandler(pcieHandler ph, uint32_t RecvSize, void *pData)\n{\n    /* deal with the received data */\n    ...\n}\n\nvoid main()\n{\n    void *pData;\n    pcieHandler ph;\n    uint32_t size;\n    void *addr;\n    uint64_t phys;\n\n    /* connect chip0 topic0 */\n    pcieInit(&ph, 0, 0);\n\n    pcieSubscribe(ph);\n\n    if (useInnerBuffer) {\n        pcieGetMaxInnerBufSize(ph, &size);\n        pcieAllocInnerBuf(ph, &addr, &phys, size);\n    } else {\n        /* alloc user buff */\n        ...\n        pcieRegisterUserBuf(ph, UserBufferPhys, size);\n    }\n\n    pcieStartRecv(ph, recvDataHandler, pData);\n\n    /* wait for receiving data */\n    while (1) {\n        sleep(1);\n    }\n\n    pcieDeInit(ph);\n\n    return;\n}\n"})})]})}function a(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(o,{...e})}):o(e)}}}]);