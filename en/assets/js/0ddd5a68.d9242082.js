"use strict";(self.webpackChunkrdk_doc=self.webpackChunkrdk_doc||[]).push([[31859],{28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>c});var r=i(96540);const s={},d=r.createContext(s);function o(e){const n=r.useContext(d);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(d.Provider,{value:n},e.children)}},74299:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>t,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"Advanced_development/linux_development/driver_development_s100/driver_audio","title":"Audio Debugging Guide","description":"This chapter mainly covers the basic features of S100 I2S, fundamental voice/audio knowledge, and instructions for adding a codec and debugging sound cards.","source":"@site/i18n/en/docusaurus-plugin-content-docs-docs_s/current/07_Advanced_development/02_linux_development/04_driver_development_s100/11_driver_audio.md","sourceDirName":"07_Advanced_development/02_linux_development/04_driver_development_s100","slug":"/Advanced_development/linux_development/driver_development_s100/driver_audio","permalink":"/rdk_doc/en/rdk_s/Advanced_development/linux_development/driver_development_s100/driver_audio","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1770955066000,"sidebarPosition":11,"frontMatter":{"sidebar_position":11},"sidebar":"tutorialSidebar","previous":{"title":"Low Power Mode Debugging Guide","permalink":"/rdk_doc/en/rdk_s/Advanced_development/linux_development/driver_development_s100/driver_lowpower"},"next":{"title":"Time Synchronization Solutions","permalink":"/rdk_doc/en/rdk_s/Advanced_development/linux_development/driver_development_s100/driver_timesync"}}');var s=i(74848),d=i(28453);const o={sidebar_position:11},c="Audio Debugging Guide",t={},a=[{value:"Overview",id:"overview",level:2},{value:"Audio Development Instructions",id:"audio-development-instructions",level:2},{value:"I2S Parameter Specifications",id:"i2s-parameter-specifications",level:3},{value:"Adding a New Codec",id:"adding-a-new-codec",level:3},{value:"Add Codec Driver",id:"add-codec-driver",level:4},{value:"Add Build Configuration",id:"add-build-configuration",level:4},{value:"Modify Device Tree Source (DTS)",id:"modify-device-tree-source-dts",level:4},{value:"Debugging Instructions",id:"debugging-instructions",level:2},{value:"Sound Card Debugging",id:"sound-card-debugging",level:3},{value:"Common Debugging Techniques",id:"common-debugging-techniques",level:3},{value:"Adjust Debug Log Level",id:"adjust-debug-log-level",level:4},{value:"ALSA procfs Node Description",id:"alsa-procfs-node-description",level:4},{value:"/proc/asound/cards",id:"procasoundcards",level:5},{value:"/proc/asound/pcm",id:"procasoundpcm",level:5},{value:"/proc/asound/cardX/pcmY[c,p]/*",id:"procasoundcardxpcmycp",level:5},{value:"info",id:"info",level:6},{value:"hw_params",id:"hw_params",level:6},{value:"sw_params",id:"sw_params",level:6},{value:"status",id:"status",level:6},{value:"xrun",id:"xrun",level:4},{value:"Scenarios Where xrun May Occur",id:"scenarios-where-xrun-may-occur",level:5},{value:"Diagnosing xrun",id:"diagnosing-xrun",level:5},{value:"Fixing xrun",id:"fixing-xrun",level:5},{value:"Common Issues",id:"common-issues",level:3},{value:"Device Node Opening Errors",id:"device-node-opening-errors",level:4},{value:"Recording/Playback Issues",id:"recordingplayback-issues",level:5},{value:"Audio Daughterboard Usage Guide",id:"audio-daughterboard-usage-guide",level:2},{value:"Audio Daughterboard Overview",id:"audio-daughterboard-overview",level:3},{value:"Connecting the Audio Daughterboard to the Development Board",id:"connecting-the-audio-daughterboard-to-the-development-board",level:3}];function l(e){const n={admonition:"admonition",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",h6:"h6",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,d.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"audio-debugging-guide",children:"Audio Debugging Guide"})}),"\n",(0,s.jsx)(n.p,{children:"This chapter mainly covers the basic features of S100 I2S, fundamental voice/audio knowledge, and instructions for adding a codec and debugging sound cards."}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"CPU DAI"}),": Digital Audio Interface on the CPU side, typically an I2S interface, controlling bus transmission."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"CODEC DAI"}),": Refers to the codec itself. It manages the codec workflow and provides interfaces to the core layer."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"DAI LINK"}),": Binds CPU DAI and CODEC DAI, representing the hardware controller driver."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"PLATFORM"}),": Specifies the platform driver on the CPU side, usually a DMA driver used for data transmission."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"DAPM"}),": Dynamic Audio Power Management."]}),"\n",(0,s.jsx)(n.h2,{id:"audio-development-instructions",children:"Audio Development Instructions"}),"\n",(0,s.jsx)(n.p,{children:"A complete sound card consists of CPU DAI, CODEC DAI, PLATFORM, and SOUND CARD."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"CPU DAI driver"}),": Typically an I2S interface driver."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"CODEC DAI driver"}),": Refers to the external codec driver."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"PLATFORM driver"}),": Usually a DMA driver responsible for managing audio data."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"SOUND CARD driver"}),": Responsible for connecting CPU DAI and CODEC DAI, e.g., ",(0,s.jsx)(n.code,{children:"sound/soc/hobot/hobot-snd-s100-ac-fdx-host.c"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"i2s-parameter-specifications",children:"I2S Parameter Specifications"}),"\n",(0,s.jsx)(n.p,{children:"Capabilities supported by the S100 I2S module:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Channel support"}),": 1/2/4/8/16 channels."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Sample rate support"}),": 8k/16k/32k/48k/44.1k/96k/192k."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Sample precision support"}),": 8bit/16bit/24bit/32bit."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Transmission protocol support"}),": I2S/DSP (TDM)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"I2S mode"}),": Supports configuration as either master or slave mode."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"SYSCLK requirement"}),": The I2S module\u2019s SYSCLK must be at least 6 times the BCLK frequency."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Full-duplex support"}),": In full-duplex mode, SDIO0 is input and SDIO1 is output; this cannot be changed."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"BCLK limit"}),": BCLK output must not exceed 25 MHz."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"adding-a-new-codec",children:"Adding a New Codec"}),"\n",(0,s.jsx)(n.h4,{id:"add-codec-driver",children:"Add Codec Driver"}),"\n",(0,s.jsxs)(n.p,{children:["Place the newly added codec driver file under the ",(0,s.jsx)(n.code,{children:"sound/soc/codecs/"})," directory."]}),"\n",(0,s.jsx)(n.h4,{id:"add-build-configuration",children:"Add Build Configuration"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Modify ",(0,s.jsx)(n.code,{children:"sound/soc/codecs/Kconfig"})," and ",(0,s.jsx)(n.code,{children:"Makefile"})," to include the codec driver in the build configuration."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Example addition to ",(0,s.jsx)(n.code,{children:"Kconfig"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'config SND_SOC_ES7210\n        tristate "ES7210 Audio Codec"\n        depends on I2C\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Example addition to ",(0,s.jsx)(n.code,{children:"Makefile"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"obj-$(CONFIG_SND_SOC_ES7210)   += snd-soc-es7210.o\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Enable the codec driver via ",(0,s.jsx)(n.code,{children:"menuconfig"}),":"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"sudo ./mk_kernel.sh menuconfig\n"})}),"\n",(0,s.jsxs)(n.p,{children:["After running the above command, open the Kernel Configuration interface, search for ",(0,s.jsx)(n.code,{children:"CONFIG_SND_SOC_ES7210"}),", and enable it."]}),"\n",(0,s.jsx)(n.h4,{id:"modify-device-tree-source-dts",children:"Modify Device Tree Source (DTS)"}),"\n",(0,s.jsx)(n.p,{children:"DTS modifications typically involve the following:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Add a codec driver node"}),". Since codecs are usually controlled via I2C, add codec information under the corresponding I2C node. Example:"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'i2c5: i2c@39470000 {\n    es7210_0: es7210_0@40 {\n            compatible = "MicArray_0";\n            reg = <0x40>;\n            #sound-dai-cells = <1>;\n            channels = <8>;\n            adc_dev_num = <2>;\n            status = "okay";\n    };\n};\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Add a sound card node"})," to establish the DAI link binding between the codec and I2S. Example:"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'snd2: snd2 {\n        status = "okay";\n        model = "s100snd2";\n        compatible = "hobot, s100-snd-ac-fdx-master";\n        i2s_mode = <1>;/*1:i2s mode; 7:dsp_a mode*/\n        work_mode = <1>;/*0:half-duplex; 1:full-duplex*/\n        channel_max = <2>;\n        mclk_set = <24576000>;\n        dai-link@0 {\n                dai-format = "dsp_a"; //"i2s"/"dsp_a" // corresponds to SND_SOC_DAIFMT_DSP_A\n                // bitclock-master; // Configuring *-master corresponds to dai_fmt equivalent to SND_SOC_DAIFMT_CBM_CFM, indicating the codec provides the clock source\n                // frame-master;\n                // frame-inversion; // Corresponds to SND_SOC_DAIFMT_NB_IF, inverting frame sync signal polarity. Normally, left channel = low level, right channel = high level. Polarity reverses when frame-inversion is enabled.\n                link-name = "s100dailink0";\n                cpu {\n                        sound-dai = <&i2s0 0>; // Digital audio interface, controls bus transmission\n                };\n                codec {\n                        sound-dai = <&es7210_0 0>; // Codec chip interface\n                };\n        };\n\n        dai-link@1 {\n                dai-format = "dsp_a";\n                link-name = "s100dailink1";\n                cpu {\n                        sound-dai = <&i2s0 1>;\n                };\n                codec {\n                        sound-dai = <&es8156>;\n                };\n        };\n};\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Additionally, a ",(0,s.jsx)(n.code,{children:"dummy_codec"})," node is added in the DTS. When no external codec is present or the codec requires standalone configuration independent of the ALSA framework, a virtual codec-bound sound card device is registered to allow user-space creation of device nodes for controlling I2S/DMA."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"debugging-instructions",children:"Debugging Instructions"}),"\n",(0,s.jsx)(n.h3,{id:"sound-card-debugging",children:"Sound Card Debugging"}),"\n",(0,s.jsx)(n.admonition,{title:"Note",type:"info",children:(0,s.jsx)(n.p,{children:"This section describes sound card debugging based on the S100 with Waveshare audio daughterboard."})}),"\n",(0,s.jsxs)(n.p,{children:["On S100, the sound card modules are provided as loadable kernel modules (",(0,s.jsx)(n.code,{children:".ko"}),") and mounted dynamically. Use the following commands to load them:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"modprobe hobot_cpudai_super\nmodprobe snd-soc-es8156\nmodprobe snd-soc-es7210\nmodprobe hobot_snd_s100_ac_fdx_host\n"})}),"\n",(0,s.jsx)(n.p,{children:"After loading the drivers, verify successful sound card registration using:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Check ",(0,s.jsx)(n.code,{children:"/proc/asound/cards"}),":"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"root@ubuntu:/# cat /proc/asound/cards\n 0 [s100snd2       ]: s100snd2 - s100snd2\n                      s100snd2\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Check ",(0,s.jsx)(n.code,{children:"/dev/snd/"}),":"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"root@ubuntu:/# ls -l /dev/snd\ntotal 0\ncrw-rw-r--+ 1 root misc 116,  4 Apr 29 19:09 controlC0\ncrw-rw-r--+ 1 root misc 116,  2 Apr 29 19:09 pcmC0D0c\ncrw-rw-r--+ 1 root misc 116,  3 Apr 29 19:09 pcmC0D1p\n"})}),"\n",(0,s.jsx)(n.p,{children:"After successful sound card loading, test functionality with the following commands:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"arecord -Dhw:0,0 -c 2 -r 16000 -f S16_LE -t wav -d 5 test.wav\naplay -Dhw:0,1 test.wav\n"})}),"\n",(0,s.jsxs)(n.admonition,{title:"Note",type:"info",children:[(0,s.jsx)(n.p,{children:"The PDMA driver requires data size to be aligned to 64-byte boundaries."}),(0,s.jsxs)(n.p,{children:["When configuring the ",(0,s.jsx)(n.code,{children:"period-size"})," value, ensure it satisfies this alignment requirement."]}),(0,s.jsxs)(n.p,{children:["For ",(0,s.jsx)(n.code,{children:"arecord"}),"/",(0,s.jsx)(n.code,{children:"aplay"}),", use the parameter: ",(0,s.jsx)(n.code,{children:"--period-size=X"})]})]}),"\n",(0,s.jsx)(n.h3,{id:"common-debugging-techniques",children:"Common Debugging Techniques"}),"\n",(0,s.jsx)(n.h4,{id:"adjust-debug-log-level",children:"Adjust Debug Log Level"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'echo "8 4 1 7" > /proc/sys/kernel/printk\necho -n "file hobot-cpudai-super.c +p" > /sys/kernel/debug/dynamic_debug/control\necho -n "file hobot-i2s-super.c +p" > /sys/kernel/debug/dynamic_debug/control\necho -n "file hobot-platform-super.c +p" > /sys/kernel/debug/dynamic_debug/control\n'})}),"\n",(0,s.jsx)(n.h4,{id:"alsa-procfs-node-description",children:"ALSA procfs Node Description"}),"\n",(0,s.jsx)(n.p,{children:"procfs is a Linux filesystem that provides interfaces to kernel data structures. It is mounted at /proc."}),"\n",(0,s.jsx)(n.p,{children:"The ALSA procfs mount point is: /proc/asound. ALSA uses files under /proc/asound to store device information and for control purposes. Through these proc nodes, we can quickly inspect certain information to help diagnose and debug issues."}),"\n",(0,s.jsx)(n.h5,{id:"procasoundcards",children:"/proc/asound/cards"}),"\n",(0,s.jsx)(n.p,{children:"Lists all registered sound cards. By checking this node, you can verify the list of sound cards currently registered in the system or confirm whether a sound card has been successfully registered."}),"\n",(0,s.jsx)(n.h5,{id:"procasoundpcm",children:"/proc/asound/pcm"}),"\n",(0,s.jsx)(n.p,{children:"Displays information about allocated PCM stream devices. By examining this node, you can identify the list of devices supported by the current sound card. This helps determine appropriate card/device values when configuring device nodes during testing."}),"\n",(0,s.jsx)(n.h5,{id:"procasoundcardxpcmycp",children:"/proc/asound/cardX/pcmY[c,p]/*"}),"\n",(0,s.jsx)(n.p,{children:"Each PCM stream device associated with a sound card in the system has a corresponding procfs directory structured as shown above. Here:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"X represents the sound card number, which can be confirmed via /proc/asound/cards or device nodes under /dev/snd."}),"\n",(0,s.jsx)(n.li,{children:"Y represents the device number, which can be confirmed via /proc/asound/pcm or device nodes under /dev/snd."}),"\n",(0,s.jsx)(n.li,{children:"c/p stands for capture/playback respectively."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This directory allows viewing PCM device information and status."}),"\n",(0,s.jsx)(n.h6,{id:"info",children:"info"}),"\n",(0,s.jsx)(n.p,{children:"General information about the PCM stream, such as sound card number, device number, stream type, bound codec type, etc."}),"\n",(0,s.jsx)(n.h6,{id:"hw_params",children:"hw_params"}),"\n",(0,s.jsx)(n.p,{children:"When the PCM stream is open, you can view basic hardware parameter configurations here, such as sample rate, bit width, number of channels, period_size, buffer_size, etc. Note that the configured period_size and buffer_size might differ from the values displayed here; the actual hardware parameters shown here should be considered authoritative."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"root@ubuntu:/proc/asound/card0/pcm0c/sub0# cat hw_params\naccess: RW_INTERLEAVED\nformat: S16_LE\nsubformat: STD\nchannels: 2\nrate: 48000 (48000/1)\nperiod_size: 1024\nbuffer_size: 4096\n"})}),"\n",(0,s.jsx)(n.h6,{id:"sw_params",children:"sw_params"}),"\n",(0,s.jsx)(n.p,{children:"When the PCM stream is open, you can view software parameters such as start_threshold, stop_threshold, and silence_threshold. Pay special attention to start_threshold and stop_threshold."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"start_threshold"}),": If set too high, there will be a long delay between playback start and audible output, potentially causing very short audio clips to be missed entirely."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"stop_threshold"}),": Determines the condition for triggering an xrun. An xrun occurs when available buffer space exceeds this threshold."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"root@ubuntu:/proc/asound/card0/pcm0c/sub0# cat sw_params\ntstamp_mode: ENABLE\nperiod_step: 1\navail_min: 1\nstart_threshold: 1\nstop_threshold: 40960\nsilence_threshold: 0\nsilence_size: 0\nboundary: 4611686018427387904\n"})}),"\n",(0,s.jsx)(n.h6,{id:"status",children:"status"}),"\n",(0,s.jsxs)(n.p,{children:["Shows the current substream status (e.g., running, xrun) and values of appl_ptr/hw_ptr pointers. The hw_ptr and appl_ptr can help identify situations where the underlying hardware fails to transmit or receive any data.",(0,s.jsx)(n.br,{}),"\n","For example, if a test starts but interrupts are not triggered properly, data transfer will stall, and hw_ptr/appl_ptr will cease updating."]}),"\n",(0,s.jsx)(n.h4,{id:"xrun",children:"xrun"}),"\n",(0,s.jsx)(n.p,{children:"During audio playback, intermittent or continuous crackling, popping, or stuttering noises typically indicate an xrun. Xruns (frame drops) are unavoidable under system performance constraints. A certain frame drop rate may be acceptable depending on the use case, and optimization techniques can help minimize occurrences. However, if xruns happen frequently and cannot recover, code implementation flaws must be investigated."}),"\n",(0,s.jsx)(n.h5,{id:"scenarios-where-xrun-may-occur",children:"Scenarios Where xrun May Occur"}),"\n",(0,s.jsx)(n.p,{children:"During playback, the application continuously writes audio data into the driver buffer, which is then sent via I2S FIFO to the codec for playback. If the application writes too slowly, causing the driver buffer to become empty, an underrun occurs, leading to frame drops and potential audio anomalies."}),"\n",(0,s.jsx)(n.p,{children:"During recording, digital signals converted by the codec are written via I2S FIFO into the driver buffer, and the application reads audio data from this buffer. If the application reads slower than data is written, exceeding the stop_threshold triggers an overrun."}),"\n",(0,s.jsx)(n.h5,{id:"diagnosing-xrun",children:"Diagnosing xrun"}),"\n",(0,s.jsx)(n.p,{children:"Check if xrun is caused by time-consuming I/O operations:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Write audio files to a RAM disk or specific device file, using commands like:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Write to RAM disk:\nmkdir /data/audio_test\ntinycap /data/audio_test/test.wav\n\nSpecific device file:\ntinycap /dev/null\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": The above methods only help determine if I/O latency causes xrun; they are not solutions to fix xrun."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Optimize application testing:"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Use a dedicated thread for media storage access and PCM device I/O.",(0,s.jsx)(n.br,{}),"\n","For recording, create a separate thread for file writing along with a ring buffer (adjustable size). Data from pcm_read is written into the ring buffer, and fwrite reads from it. As long as fwrite\u2019s blocking time stays within the ring buffer\u2019s capacity, xrun-induced data loss can be avoided."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use /proc configuration features to inspect information:"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Enable the xrun_debug config options during kernel compilation and reflash the image. (If xrun_debug already exists, the feature is enabled\u2014no need to recompile.)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"CONFIG_SND_PCM_XRUN_DEBUG=y\nCONFIG_SND_VERBOSE_PROCFS=y\nCONFIG_SND_DEBUG=y\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The corresponding proc node is located at: ",(0,s.jsx)(n.code,{children:"/proc/asound/cardX/pcmY[c,p]/xrun_debug"})]}),"\n",(0,s.jsx)(n.p,{children:'For example, writing "3" to xrun_debug enables basic debugging and stack dumping, helping identify if the PCM stream stopped due to specific reasons:'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"# Enable basic debugging and dump stack\n# Useful to check if PCM stream stops (often due to incorrect audio process timing from scheduler)\necho 3 > /proc/asound/card0/pcm0p/xrun_debug\n"})}),"\n",(0,s.jsx)(n.h5,{id:"fixing-xrun",children:"Fixing xrun"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Increase thread priority (use real-time threads with higher priority values)."}),"\n",(0,s.jsx)(n.li,{children:"Increase period_size to adjust DMA transfer volume."}),"\n",(0,s.jsx)(n.li,{children:"Implement asynchronous I/O and ALSA device read/write operations."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-issues",children:"Common Issues"}),"\n",(0,s.jsx)(n.h4,{id:"device-node-opening-errors",children:"Device Node Opening Errors"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Unable to open PCM device (cannot open device '/dev/snd/pcmC0D3c': No such file or directory)"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Driver failed to load, so no device node was created under /dev/snd."}),"\n",(0,s.jsx)(n.li,{children:"Incorrect card/device values specified, leading to failure in locating the corresponding device node."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Possible reasons for missing device nodes under /dev/snd:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"I2S/codec driver failed to load. Check dmesg for messages like:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"soc:sndcard@0: BUG: Can't get codec\nsoc:sndcard@0: BUG: Can't get cpu\nprobe of soc:sndcard@0 failed with error -22\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["In the device tree source (DTS), the ",(0,s.jsx)(n.code,{children:"status"}),' property of relevant driver nodes isn\u2019t set to "okay", preventing driver initialization. After driver loading, check dmesg for success messages like "successfully registered cpu dai0 driver".']}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Unable to open PCM device (cannot set hw params: Unknown error -22)"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The parameters set during testing exceed the intersection of supported ranges (rate, format, channels) defined in snd_soc_dai_driver for both I2S and codec drivers."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Application hangs when opening device node with no log output"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"ALSA framework allows only one open instance per device at a time. Check if the application was previously launched and hasn\u2019t exited before starting again."}),"\n",(0,s.jsx)(n.h5,{id:"recordingplayback-issues",children:"Recording/Playback Issues"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"pcm_read/pcm_write returns error code -5"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Increase ALSA framework log level to check if missing interrupts or hardware link issues prevent interrupt generation:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'echo "8 4 1 7" > /proc/sys/kernel/printk\necho -n "file pcm_lib.c +p" > /sys/kernel/debug/dynamic_debug/control\n'})}),"\n",(0,s.jsxs)(n.p,{children:["If the message ",(0,s.jsx)(n.code,{children:"write error (DMA or IRQ trouble?)"})," appears, it indicates missing interrupts. Inspect register configurations and hardware connections."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"pcm_read/pcm_write returns error code -32"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Usually indicates an xrun."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"pcm_read returns error code -16"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"During normal recording (with S100 as slave), this error occurs if the clock signal suddenly disappears or the hardware connection is interrupted."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Recorded data is all zeros or no sound during playback"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use an oscilloscope to verify I2S clock line frequency and check if data lines carry valid signals."}),"\n",(0,s.jsx)(n.li,{children:"If clock frequency is unexpected or a clock signal remains constantly low, verify I2S register configurations (e.g., master/slave mode, clock ratios)."}),"\n",(0,s.jsx)(n.li,{children:"If the above checks pass, verify if the codec chip functions correctly. Play a sine wave and measure analog output from the codec. If no output is detected, confirm codec clock ratio settings match J5 pin requirements and that S100\u2019s current clock ratio falls within the codec\u2019s supported range."}),"\n",(0,s.jsx)(n.li,{children:"If the codec outputs a clean signal, check if the amplifier chip works properly by verifying voltage levels on its pins."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Recording/Playback noise"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Some codec designs require the codec\u2019s master clock (MCLK) to be synchronous with BCLK/LRCLK when operating in slave mode. Otherwise, data glitches or repetitions during recording may cause noise."}),"\n",(0,s.jsx)(n.h2,{id:"audio-daughterboard-usage-guide",children:"Audio Daughterboard Usage Guide"}),"\n",(0,s.jsx)(n.h3,{id:"audio-daughterboard-overview",children:"Audio Daughterboard Overview"}),"\n",(0,s.jsx)(n.p,{children:"The audio daughterboard connects to the S100 development board and receives a single full-duplex I2S signal."}),"\n",(0,s.jsx)(n.p,{children:"It includes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Two ES7210 chips (I2C addresses 0x40 and 0x42), supporting 8-channel recording: 4 channels for analog microphones and 2 channels for AEC loopback from speakers."}),"\n",(0,s.jsx)(n.li,{children:"One ES8156 chip (I2C address 0x08), supporting 2-channel playback to headphones or speakers."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Physical layout (see image below): red circles mark ES7210 chips, yellow circle marks ES8156, and green circle marks the 4-mic array."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/02_linux_development/driver_development_s100/audio1.png",alt:""})}),"\n",(0,s.jsx)(n.h3,{id:"connecting-the-audio-daughterboard-to-the-development-board",children:"Connecting the Audio Daughterboard to the Development Board"}),"\n",(0,s.jsx)(n.p,{children:"Connection method shown below:"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/02_linux_development/driver_development_s100/audio2.png",alt:""}),(0,s.jsx)(n.strong,{children:"Note"}),": The PCM pins on the 40-pin header are shared with the PCIe Wi-Fi module. A DIP switch is provided on the hardware to toggle the pin functionality."]}),"\n",(0,s.jsx)(n.p,{children:"The DIP switch configuration for pin function selection is illustrated in the following figure:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/02_linux_development/driver_development_s100/audio3.png",alt:""})})]})}function h(e={}){const{wrapper:n}={...(0,d.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);