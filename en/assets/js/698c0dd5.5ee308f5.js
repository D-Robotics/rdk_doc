"use strict";(self.webpackChunkrdk_doc=self.webpackChunkrdk_doc||[]).push([[52998],{28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var o=t(96540);const r={},i=o.createContext(r);function s(e){const n=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),o.createElement(i.Provider,{value:n},e.children)}},46384:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"Advanced_development/mcu_development/S100/mcu_ramdump","title":"MCU Ramdump Feature","description":"Currently, crash information for MCU0 and MCU1 shares the same memory region. If MCU0 and MCU1 crash simultaneously, the information saved by the MCU ramdump feature becomes unreliable.","source":"@site/i18n/en/docusaurus-plugin-content-docs-docs_s/current/07_Advanced_development/05_mcu_development/01_S100/13_mcu_ramdump.md","sourceDirName":"07_Advanced_development/05_mcu_development/01_S100","slug":"/Advanced_development/mcu_development/S100/mcu_ramdump","permalink":"/rdk_doc/en/rdk_s/Advanced_development/mcu_development/S100/mcu_ramdump","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1770709590000,"sidebarPosition":13,"frontMatter":{"sidebar_position":13},"sidebar":"tutorialSidebar","previous":{"title":"Port Development Guide","permalink":"/rdk_doc/en/rdk_s/Advanced_development/mcu_development/S100/mcu_port/development_manual"},"next":{"title":"7.6 RDK S100 Build System Development Guide","permalink":"/rdk_doc/en/rdk_s/Advanced_development/rdk_gen"}}');var r=t(74848),i=t(28453);const s={sidebar_position:13},a="MCU Ramdump Feature",c={},d=[{value:"Overview",id:"overview",level:2},{value:"Exception Handling Flow",id:"exception-handling-flow",level:2},{value:"Rebooting MCU1 After an Exception",id:"rebooting-mcu1-after-an-exception",level:2},{value:"Retrieving MCU Exception Information",id:"retrieving-mcu-exception-information",level:2},{value:"Analyzing Exception Logs",id:"analyzing-exception-logs",level:2}];function l(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"mcu-ramdump-feature",children:"MCU Ramdump Feature"})}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsxs)(n.p,{children:["Currently, crash information for MCU0 and MCU1 shares the same memory region. If MCU0 and MCU1 crash ",(0,r.jsx)(n.strong,{children:"simultaneously"}),", the information saved by the MCU ramdump feature becomes unreliable."]})}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"The MCU ramdump feature was developed primarily to print and preserve exception information when the MCU crashes or enters an abnormal state, facilitating analysis and localization of the root cause."}),"\n",(0,r.jsx)(n.h2,{id:"exception-handling-flow",children:"Exception Handling Flow"}),"\n",(0,r.jsx)(n.p,{children:"When the MCU enters an exception, it saves the context information into a global variable. This global variable can be read either by the A-core or via the MCU shell."}),"\n",(0,r.jsxs)(n.p,{children:["If MCU0 encounters an exception, the system will reboot. During the reboot process, the system checks the reboot reason. If the reboot reason is identified as ",(0,r.jsx)(n.code,{children:"mpainc"}),", the system ensures that the memory region corresponding to the global variable storing the MCU exception context is ",(0,r.jsx)(n.strong,{children:"not cleared to zero"}),". Consequently, after system reboot, we can retrieve the ramdump data and analyze the cause of the exception."]}),"\n",(0,r.jsx)(n.p,{children:"The exception handling flow is illustrated below:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"http://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/05_mcu_development/01_S100/mcu_ramdump_flowchart-en.jpg",alt:""})}),"\n",(0,r.jsx)(n.p,{children:"The exception handling flows for MCU0 and MCU1 are largely similar, with the only difference being that MCU0 triggers a system reboot after handling the exception."}),"\n",(0,r.jsx)(n.h2,{id:"rebooting-mcu1-after-an-exception",children:"Rebooting MCU1 After an Exception"}),"\n",(0,r.jsx)(n.p,{children:"When MCU1 encounters an exception, it drops into the shell. At this point, you can stop and restart MCU1 using the A-core remoteproc control mechanism. Example commands are as follows:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"  # Stop execution\n  echo stop > /sys/class/remoteproc/remoteproc_MCU0/state\n  # Start execution\n  echo start > /sys/class/remoteproc/remoteproc_MCU0/state\n"})}),"\n",(0,r.jsx)(n.h2,{id:"retrieving-mcu-exception-information",children:"Retrieving MCU Exception Information"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"You can read the context information recorded during an MCU1 exception via a sysfs node on the A-core. The corresponding sysfs path is:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"  cat /sys/devices/platform/soc/soc:mcu_crash/crash\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["When MCU0 crashes and the system reboots, if the reboot reason is determined to be ",(0,r.jsx)(n.code,{children:"mpainc"}),", the context information is dumped to the ",(0,r.jsx)(n.code,{children:"/log"})," partition for historical log analysis. The dumped log directory follows the naming format: ",(0,r.jsx)(n.code,{children:"SuperSoC_Mdump-<count>-<time>"}),".",(0,r.jsx)(n.br,{}),"\n","Here, ",(0,r.jsx)(n.code,{children:"<count>"})," indicates the number of system reboots, and ",(0,r.jsx)(n.code,{children:"<time>"})," represents the timestamp in the format: ",(0,r.jsx)(n.code,{children:"Year_Month_Day_Hour_Minute_Second"}),", for example: ",(0,r.jsx)(n.code,{children:"SuperSoC_Mdump-0010-2025_08_13_20_25_11"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"When the MCU encounters data abort, undefined instruction, or prefetch abort exceptions, it can dump the context information to aid in debugging."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"analyzing-exception-logs",children:"Analyzing Exception Logs"}),"\n",(0,r.jsx)(n.p,{children:"Taking a data abort exception as an example, the recorded exception information is explained below:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/05_mcu_development/01_S100/mcu_ramdump_exception.png",alt:""})}),"\n",(0,r.jsx)(n.p,{children:"The meaning of each data field is as follows:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Arrow 1"})," indicates the memory address being accessed when the data abort occurred. As shown in the figure, the exception happened while attempting to access address ",(0,r.jsx)(n.code,{children:"0x1"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Arrow 2"})," shows the exception status data, which is generally not critical for analysis."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Arrow 3"})," indicates the type of exception that occurred."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Arrow 4"})," shows the address of the instruction that triggered the exception. By combining this address with ELF symbol information, we can pinpoint the exact source code location where the exception occurred. Example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"  addr2line -e S100_MCU_DEBUG.elf 0xcab3fa1\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.code,{children:"addr2line"})," is not installed on your system, you can install it using the following commands:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"  sudo apt update\n  sudo apt install binutils -y\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Arrow 5"})," shows the value of the CPU's CPSR (Current Program Status Register) at the time of the exception."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Arrow 6"})," indicates the memory address where the crash dump was saved. You can read the saved register and stack context either by entering ",(0,r.jsx)(n.code,{children:"dumpmem [addr] 4 64"})," in the MCU shell, or by accessing the crash context via ",(0,r.jsx)(n.a,{href:"#retrieving-mcu-exception-information",children:"sysfs on the A-core"}),"."]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}}}]);