"use strict";(self.webpackChunkrdk_doc=self.webpackChunkrdk_doc||[]).push([[92090],{28453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>c});var i=s(96540);const a={},r=i.createContext(a);function t(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),i.createElement(r.Provider,{value:n},e.children)}},97736:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"Advanced_development/hardware_development/rdk_x5/can","title":"CAN Usage","description":"Protocol Overview","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/07_Advanced_development/01_hardware_development/rdk_x5/can.md","sourceDirName":"07_Advanced_development/01_hardware_development/rdk_x5","slug":"/Advanced_development/hardware_development/rdk_x5/can","permalink":"/rdk_doc/en/Advanced_development/hardware_development/rdk_x5/can","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1765534493000,"sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Accessories List","permalink":"/rdk_doc/en/Advanced_development/hardware_development/rdk_x5/accessory"},"next":{"title":"Display Usage","permalink":"/rdk_doc/en/Advanced_development/hardware_development/rdk_x5/display"}}');var a=s(74848),r=s(28453);const t={sidebar_position:3},c="CAN Usage",d={},l=[{value:"Protocol Overview",id:"protocol-overview",level:2},{value:"Interface Description",id:"interface-description",level:2},{value:"Module Overview",id:"module-overview",level:2},{value:"Driver Guide",id:"driver-guide",level:2},{value:"Driver Code",id:"driver-code",level:2},{value:"can-utils Introduction",id:"can-utils-introduction",level:2},{value:"Basic Usage",id:"basic-usage",level:3},{value:"Test Guide",id:"test-guide",level:2},{value:"Loopback Test",id:"loopback-test",level:3},{value:"CANFD Loopback Test",id:"canfd-loopback-test",level:3},{value:"Dual Device Communication Test",id:"dual-device-communication-test",level:3},{value:"Application Guide",id:"application-guide",level:2}];function o(e){const n={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"can-usage",children:"CAN Usage"})}),"\n",(0,a.jsx)(n.h2,{id:"protocol-overview",children:"Protocol Overview"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"CAN"}),"\nCAN stands for Controller Area Network, which is a serial communication protocol standardized by ISO. It is widely used in real-time applications, utilizing twisted pair cables for signal transmission. It is one of the most widely used fieldbus technologies worldwide."]}),"\n",(0,a.jsx)(n.p,{children:"Advantages of CAN bus:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"High reliability and strong anti-interference capabilities"}),(0,a.jsx)(n.br,{}),"\n","The physical layer chip uses differential signals and twisted pair wiring for transmission, effectively mitigating electromagnetic interference. The hardware-based data link layer automatically resolves synchronization issues between multiple nodes."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Strong error detection capabilities"}),(0,a.jsx)(n.br,{}),"\n","The hardware-based data link layer includes features like CRC and bit detection, ensuring near 100% detection of communication anomalies."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Comprehensive error management"}),(0,a.jsx)(n.br,{}),"\n","If a message arbitration fails or is corrupted during transmission, it will be automatically retransmitted. Nodes with severe errors will automatically disconnect from the bus, without affecting normal operation of the network."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Real-time performance"}),(0,a.jsx)(n.br,{}),"\n","CAN bus supports high data transmission speeds and can handle large amounts of data in real time, meeting the needs of automotive electronic control systems."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Low cost"}),(0,a.jsx)(n.br,{}),"\n","The hardware cost for CAN bus systems is relatively low, reducing the overall cost of automotive electronic control systems."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Long communication distance and high message transmission speed"}),(0,a.jsx)(n.br,{}),"\n","Direct communication can cover up to 10 km (at rates below 4 kbps); the transmission speed can reach up to 1 Mbps, with a maximum distance of 40 meters at this speed."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Multi-master communication support, lossless arbitration"}),(0,a.jsx)(n.br,{}),"\n","In the event that two nodes send messages simultaneously, the higher priority message will be transmitted without interference."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:'Eliminates the concept of "address"'}),(0,a.jsx)(n.br,{}),"\n","A key feature of CAN is the elimination of traditional address encoding, replaced by message-based communication."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"High flexibility and ease of network expansion"}),(0,a.jsx)(n.br,{}),"\n","The number of nodes on a CAN network is not limited. Adding new nodes does not affect the existing hardware and software of the network."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"CAN FD"}),"\nThe need for higher performance in CAN networks led to the development of CAN FD (Flexible Data-rate). CAN FD maintains the advantages of standard CAN but addresses its shortcomings with the following features:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Extended data field"}),(0,a.jsx)(n.br,{}),"\n","CAN FD supports a data field of up to 64 bytes per frame, compared to the 8 bytes in standard CAN. This greatly increases data transfer capacity."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Dual bit-rate mode"}),(0,a.jsx)(n.br,{}),"\n","CAN FD supports dual bit-rate operation, using a nominal bit-rate (up to 1 Mbps) for the arbitration phase and a higher bit-rate (up to 5 Mbps) for the data phase, enhancing data transmission speed while maintaining compatibility."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Improved CRC and padding bit counter"}),(0,a.jsx)(n.br,{}),"\n","CAN FD introduces improvements in CRC and padding bit counters to enhance error detection and data integrity."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Remote frame support removed"}),(0,a.jsx)(n.br,{}),"\n","CAN FD simplifies the frame structure by removing support for remote frames, making communication fully data-frame based."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"interface-description",children:"Interface Description"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/01_hardware_development/rdk_x5/img-20241009-1.png",alt:"img-20241009-1"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"The RDK X5 provides a CAN communication interface, equipped with a 120-ohm terminal resistor switch. To enable the terminal resistor, simply close the switch."}),"\n",(0,a.jsx)(n.li,{children:"The terminal interface is of type SH1.0 1X3P."}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"module-overview",children:"Module Overview"}),"\n",(0,a.jsxs)(n.p,{children:["The RDK X5 integrates the ",(0,a.jsx)(n.strong,{children:"TCAN4550"})," chip.",(0,a.jsx)(n.br,{}),"\n","The ",(0,a.jsx)(n.strong,{children:"TCAN4550"})," is a CAN FD controller with an integrated transceiver supporting data rates of up to 8 Mbps. It complies with the ISO11898-1:2015 high-speed CAN data link layer specification and the ISO11898\u20132:2016 high-speed CAN physical layer requirements. The TCAN4550 interfaces between the CAN bus and the system processor via the Serial Peripheral Interface (SPI), supporting both classic CAN and CAN FD, and provides port expansion or CAN support for processors that do not support CAN FD. The TCAN4550 features differential transmission and reception capabilities for CAN FD transceivers."]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Supports CAN at 1 Mbps and CAN FD at 2 Mbps."}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"driver-guide",children:"Driver Guide"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"dts"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:'&spi5 {\n  status = "okay";\n  pinctrl-names = "default";\n  pinctrl-0 = <&pinctrl_spi5 &lsio_gpio0_7 &lsio_gpio0_12>;\n\n  tcan4x5x: tcan4x5x@0 {\n    compatible = "ti,tcan4x5x";\n    reg = <0>;\n    #address-cells = <1>;\n    #size-cells = <1>;\n    spi-max-frequency = <10000000>;\n    bosch,mram-cfg = <0x0 0 0 16 0 0 1 1>;\n    interrupt-parent = <&ls_gpio0_porta>;\n    interrupts = <12 IRQ_TYPE_EDGE_FALLING>;\n    reset-gpios = <&ls_gpio0_porta 7 GPIO_ACTIVE_HIGH>;\n  };\n};\n'})}),"\n",(0,a.jsx)(n.h2,{id:"driver-code",children:"Driver Code"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"kernel\\drivers\\net\\can\\m_can\\tcan4x5x-core.c\n"})}),"\n",(0,a.jsx)(n.h2,{id:"can-utils-introduction",children:"can-utils Introduction"}),"\n",(0,a.jsx)(n.p,{children:"can-utils is an open-source toolset for the Linux operating system, specifically designed for tasks related to the CAN (Controller Area Network) bus. CAN bus is widely used in automotive and industrial automation for communication between devices."}),"\n",(0,a.jsx)(n.p,{children:"This toolset provides various command-line utilities for sending, receiving, and processing data on the CAN network. Some common tools include:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"cansend"}),": Sends a single CAN frame."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"candump"}),": Captures and displays data passing through the CAN interface."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"canplayer"}),": Replays data recorded by ",(0,a.jsx)(n.code,{children:"candump"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"cansniffer"}),": Displays changes in CAN data."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"can-utils also includes advanced tools for tasks like configuring CAN hardware filters or debugging CAN devices and networks. These tools are accessible via the command line and can be easily integrated into scripts and automation systems."}),"\n",(0,a.jsx)(n.h3,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"1. candump"}),"\nDisplays, filters, and records CAN data"]}),"\n",(0,a.jsx)(n.p,{children:"Basic usage:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"candump can0\n"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Display all CAN data through the can0 interface."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Filter by specific ID:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"candump can0,123:7FF\n"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Display CAN frames with ID 123."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Record data to a file:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"candump -l can0\n"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["This will record data passing through can0 to a file, with the default filename format as ",(0,a.jsx)(n.code,{children:"candump-YYYY-MM-DD.log"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"2. canplayer"}),"\n",(0,a.jsx)(n.strong,{children:"canplayer"})," is used to replay CAN data logs recorded by ",(0,a.jsx)(n.code,{children:"candump"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Basic usage:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"canplayer -I candump.log\n"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Replay CAN data from the file ",(0,a.jsx)(n.code,{children:"candump.log"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"3. cansend"}),"\nused to send a specified CAN frame."]}),"\n",(0,a.jsx)(n.p,{children:"Basic usage:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"cansend can0 123#1122334455667788\n"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Send a CAN frame with ID 123 and data ",(0,a.jsx)(n.code,{children:"1122334455667788"})," to the can0 interface."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"4. cangen"}),"\nGenerate random or specific-patterned CAN traffic for testing or simulation purposes."]}),"\n",(0,a.jsx)(n.p,{children:"Basic usage:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"cangen can0 -I 1A -L 8 -D i -g 10 -n 100\n"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Generate 100 CAN frames with ID 1A, 8-byte length, and incrementing payloads on ",(0,a.jsx)(n.code,{children:"can0"}),", with a 10ms interval between each frame."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"5. cansequence"}),(0,a.jsx)(n.br,{}),"\n","Send a sequence of CAN frames with incrementing payloads and check for any frame loss."]}),"\n",(0,a.jsx)(n.p,{children:"Basic usage:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"cansequence can0\n"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Send and monitor a sequence of CAN frames with incrementing payloads on ",(0,a.jsx)(n.code,{children:"can0"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"6. cansniffer"}),(0,a.jsx)(n.br,{}),"\n","Used to display changes in CAN data, which is very useful for debugging and understanding the data flow."]}),"\n",(0,a.jsx)(n.p,{children:"Basic usage:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"cansniffer can0\n"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Monitor and display any changes in CAN data on the ",(0,a.jsx)(n.code,{children:"can0"})," interface."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"test-guide",children:"Test Guide"}),"\n",(0,a.jsx)(n.h3,{id:"loopback-test",children:"Loopback Test"}),"\n",(0,a.jsx)(n.p,{children:"Configure the CAN bus bitrate and enable loopback mode."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"ip link set down can0\nip link set can0 type can bitrate 125000\nip link set can0 type can loopback on\nip link set up can0\n"})}),"\n",(0,a.jsx)(n.p,{children:"View CAN0 Configuration Information"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"ip -details link show can0\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/01_hardware_development/rdk_x5/img-20241009-2.png",alt:"img-20241009-2"})}),"\n",(0,a.jsxs)(n.p,{children:["To check the configuration details of the ",(0,a.jsx)(n.code,{children:"can0"})," interface, you can use the following command:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"candump can0 -L &\n"})}),"\n",(0,a.jsx)(n.p,{children:"To send a test message and verify that data is immediately received, use the following command:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"cansend can0 123#1122334455667788\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Test Results\n",(0,a.jsx)(n.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/01_hardware_development/rdk_x5/img-20241009-3.png",alt:"img-20241009-3"})]}),"\n",(0,a.jsx)(n.h3,{id:"canfd-loopback-test",children:"CANFD Loopback Test"}),"\n",(0,a.jsx)(n.p,{children:"The arbitration segment bitrate is set to 500K, and the data segment bitrate is set to 2M."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"ip link set can0 down\nip link set can0 type can bitrate 500000 dbitrate 2000000  fd on\nip link set can0 type can loopback on\nip link set can0 up\n"})}),"\n",(0,a.jsx)(n.p,{children:"Sending and Receiving CAN FD Data"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"candump can0 -L &\ncansend can0 123##300112233445566778899aabbccddeeff\n"})}),"\n",(0,a.jsx)(n.h3,{id:"dual-device-communication-test",children:"Dual Device Communication Test"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Hardware Connection"}),(0,a.jsx)(n.br,{}),"\n",(0,a.jsx)(n.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/01_hardware_development/rdk_x5/img-20241009-4.png",alt:"img-20241009-4"})]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"GND to GND, L to L, H to H."}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Test Instructions"}),(0,a.jsx)(n.br,{}),"\n","Configure both devices with the same CAN bus bit rate."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"ip link set down can0\nip link set can0 type can bitrate 125000\nip link set up can0\n"})}),"\n",(0,a.jsxs)(n.p,{children:["One device should be configured to ",(0,a.jsx)(n.strong,{children:"receive"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"candump can0 -L\n"})}),"\n",(0,a.jsxs)(n.p,{children:["One device should be configured to ",(0,a.jsx)(n.strong,{children:"send"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"cansend can0 123#1122334455667788\n"})}),"\n",(0,a.jsx)(n.h2,{id:"application-guide",children:"Application Guide"}),"\n",(0,a.jsx)(n.p,{children:"Linux provides a SocketCAN interface, which makes CAN bus communication similar to Ethernet communication. The application programming interface is more universal and flexible. Using SocketCAN is like using TCP/IP."}),"\n",(0,a.jsx)(n.p,{children:"Here is a simple example of sending and receiving CAN data:"}),"\n",(0,a.jsx)(n.p,{children:"Configure CAN Bus Bitrate and Loopback Mode"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"ip link set down can0\nip link set can0 type can bitrate 125000\nip link set can0 type can loopback on\nip link set up can0\n"})}),"\n",(0,a.jsx)(n.p,{children:"write code"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <linux/can.h>\n#include <linux/can/raw.h>\n#include <sys/socket.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n\nint main() {\n  int sock;\n  struct sockaddr_can addr;\n  struct can_frame frame;\n\n  // \u521b\u5efa Socket\n  sock = socket(PF_CAN, SOCK_RAW, CAN_RAW);\n  if (sock < 0) {\n      perror("Socket");\n      return 1;\n  }\n\n  // \u83b7\u53d6 can0 \u63a5\u53e3\n  struct ifreq ifr;\n  strcpy(ifr.ifr_name, "can0");\n  ioctl(sock, SIOCGIFINDEX, &ifr);\n\n  // \u7ed1\u5b9a Socket\n  addr.can_family = PF_CAN;\n  addr.can_ifindex = ifr.ifr_ifindex;\n  bind(sock, (struct sockaddr *)&addr, sizeof(addr));\n\n  // \u53d1\u9001\u6d88\u606f\n  frame.can_id = 0x123;\n  frame.can_dlc = 4;\n  memcpy(frame.data, "\\xde\\xad\\xbe\\xef", 4);\n  write(sock, &frame, sizeof(struct can_frame));\n\n  // \u63a5\u6536\u6d88\u606f\n  while (1) {\n      int nbytes = read(sock, &frame, sizeof(struct can_frame));\n      if (nbytes > 0) {\n          printf("Received: ID: 0x%X Data: ", frame.can_id);\n          for (int i = 0; i < frame.can_dlc; i++) {\n              printf("%02X ", frame.data[i]);\n          }\n          printf("\\n");\n      }\n  }\n\n  close(sock);\n  return 0;\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"Compile and Run"}),"\n",(0,a.jsxs)(n.p,{children:["Save the code to a file named ",(0,a.jsx)(n.code,{children:"can_loopback.c"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"compile the program:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"gcc -o can_loopback can_loopback.c\n"})}),"\n",(0,a.jsx)(n.p,{children:"Run the Program"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"sudo ./can_loopback\n"})}),"\n",(0,a.jsx)(n.p,{children:"The code will send a CAN message and continuously receive and print the messages it receives."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(o,{...e})}):o(e)}}}]);