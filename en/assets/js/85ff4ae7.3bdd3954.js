"use strict";(self.webpackChunkrdk_doc=self.webpackChunkrdk_doc||[]).push([[84491],{28453:(e,n,d)=>{d.d(n,{R:()=>t,x:()=>c});var i=d(96540);const s={},r=i.createContext(s);function t(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),i.createElement(r.Provider,{value:n},e.children)}},95627:(e,n,d)=>{d.r(n),d.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"Basic_Application/multi_media/multi_media_api/cdev/decoder_api","title":"DECODER API","description":"The DECODER API provides the following interfaces:","source":"@site/i18n/en/docusaurus-plugin-content-docs-docs_s/current/03_Basic_Application/04_multi_media/multi_media_api/cdev/decoder_api.md","sourceDirName":"03_Basic_Application/04_multi_media/multi_media_api/cdev","slug":"/Basic_Application/multi_media/multi_media_api/cdev/decoder_api","permalink":"/rdk_doc/en/rdk_s/Basic_Application/multi_media/multi_media_api/cdev/decoder_api","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1765989934000,"sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"ENCODER API","permalink":"/rdk_doc/en/rdk_s/Basic_Application/multi_media/multi_media_api/cdev/encoder_api"},"next":{"title":"DISPLAY API","permalink":"/rdk_doc/en/rdk_s/Basic_Application/multi_media/multi_media_api/cdev/display_api"}}');var s=d(74848),r=d(28453);const t={sidebar_position:3},c="DECODER API",o={},l=[{value:"sp_init_decoder_module",id:"sp_init_decoder_module",level:2},{value:"sp_release_decoder_module",id:"sp_release_decoder_module",level:2},{value:"sp_start_decode",id:"sp_start_decode",level:2},{value:"sp_stop_decode",id:"sp_stop_decode",level:2},{value:"sp_decoder_get_image",id:"sp_decoder_get_image",level:2},{value:"sp_decoder_set_image",id:"sp_decoder_set_image",level:2}];function a(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"decoder-api",children:"DECODER API"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"DECODER"})," API provides the following interfaces:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Function"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"sp_init_decoder_module"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Initialize decoder module object"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"sp_release_decoder_module"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Destroy decoder module object"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"sp_start_decode"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Create an image decoding channel"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"sp_stop_decode"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Close an image decoding channel"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"sp_decoder_get_image"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Retrieve a decoded image frame from the decoding channel"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"sp_decoder_set_image"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Feed encoded stream data into the decoding channel"})})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"sp_init_decoder_module",children:"sp_init_decoder_module"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"[Function Prototype]"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"void *sp_init_decoder_module()"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"[Description]"})}),"\n",(0,s.jsx)(n.p,{children:"Initializes a decoder module object. This function must be called to obtain a handle before using the decoder module. It supports video streams in H264, H265, and Mjpeg formats."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"[Parameters]"})}),"\n",(0,s.jsx)(n.p,{children:"None."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"[Return Type]"})}),"\n",(0,s.jsxs)(n.p,{children:["Returns a ",(0,s.jsx)(n.code,{children:"DECODER"})," object on success; returns NULL on failure."]}),"\n",(0,s.jsx)(n.h2,{id:"sp_release_decoder_module",children:"sp_release_decoder_module"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"[Function Prototype]"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"void sp_release_decoder_module(void *obj)"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"[Description]"})}),"\n",(0,s.jsx)(n.p,{children:"Destroys the decoder module object."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"[Parameters]"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"obj"}),": Pointer to the object obtained from the initialization function."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"[Return Type]"})}),"\n",(0,s.jsx)(n.p,{children:"None."}),"\n",(0,s.jsx)(n.h2,{id:"sp_start_decode",children:"sp_start_decode"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"[Function Prototype]"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"int32_t sp_start_decode(void *obj, const char *stream_file, int32_t video_chn, int32_t type, int32_t width, int32_t height)"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"[Description]"})}),"\n",(0,s.jsx)(n.p,{children:"Creates a decoding channel and configures its channel ID, stream type to decode, and output image resolution."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"[Parameters]"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"obj"}),": Pointer to an initialized ",(0,s.jsx)(n.code,{children:"DECODER"})," object."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"stream_file"}),': When set to a valid stream filename (e.g., "stream.h264" for an H264 stream), the decoder will decode this file. If an empty string is passed, the stream data must be provided later via ',(0,s.jsx)(n.code,{children:"sp_decoder_set_image"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"video_chn"}),": Decoding channel number, supporting values from 0 to 31."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"type"}),": Stream type to decode. Supported values: ",(0,s.jsx)(n.code,{children:"SP_ENCODER_H264"}),", ",(0,s.jsx)(n.code,{children:"SP_ENCODER_H265"}),", and ",(0,s.jsx)(n.code,{children:"SP_ENCODER_MJPEG"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"width"}),": Width of the decoded image frame."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"height"}),": Height of the decoded image frame."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"[Return Type]"})}),"\n",(0,s.jsx)(n.p,{children:"Returns 0 on success; returns -1 on failure."}),"\n",(0,s.jsx)(n.h2,{id:"sp_stop_decode",children:"sp_stop_decode"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"[Function Prototype]"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"int32_t sp_stop_decode(void *obj)"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"[Description]"})}),"\n",(0,s.jsx)(n.p,{children:"Closes the decoding channel."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"[Parameters]"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"obj"}),": Pointer to an initialized ",(0,s.jsx)(n.code,{children:"DECODER"})," object."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"[Return Type]"})}),"\n",(0,s.jsx)(n.p,{children:"Returns 0 on success; returns -1 on failure."}),"\n",(0,s.jsx)(n.h2,{id:"sp_decoder_get_image",children:"sp_decoder_get_image"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"[Function Prototype]"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"int32_t sp_decoder_get_image(void *obj, char *image_buffer)"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"[Description]"})}),"\n",(0,s.jsxs)(n.p,{children:["Retrieves decoded image frame data from the decoding channel. The returned image data is in ",(0,s.jsx)(n.code,{children:"NV12"})," format (",(0,s.jsx)(n.code,{children:"YUV"}),")."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"[Parameters]"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"obj"}),": Pointer to an initialized ",(0,s.jsx)(n.code,{children:"DECODER"})," object."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"image_buffer"}),": Buffer to store the returned image frame data. The required buffer size is ",(0,s.jsx)(n.code,{children:"(width * height * 3) / 2"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"[Return Type]"})}),"\n",(0,s.jsx)(n.p,{children:"Returns 0 on success; returns -1 on failure."}),"\n",(0,s.jsx)(n.h2,{id:"sp_decoder_set_image",children:"sp_decoder_set_image"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"[Function Prototype]"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"int32_t sp_decoder_set_image(void *obj, char *image_buffer, int32_t chn, int32_t size, int32_t eos)"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"[Description]"})}),"\n",(0,s.jsx)(n.p,{children:"Feeds encoded stream data into an opened decoding channel.For H264 or H265 streams, you must first send 3\u20135 frames to allow the decoder to fill its internal frame buffers before retrieving decoded frames.For H264 streams, the first frame sent must contain SPS and PPS header information; otherwise, the decoder will report an error and exit."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"[Parameters]"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"obj"}),": Pointer to an initialized ",(0,s.jsx)(n.code,{children:"DECODER"})," object."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"image_buffer"}),": Pointer to the encoded stream data."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"chn"}),": Decoder channel number, which must correspond to a channel previously opened via ",(0,s.jsx)(n.code,{children:"sp_start_decode"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"size"}),": Size of the stream data."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"eos"}),": Indicates whether this is the last frame of data."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"[Return Type]"})}),"\n",(0,s.jsx)(n.p,{children:"Returns 0 on success; returns -1 on failure."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}}}]);