"use strict";(self.webpackChunkrdk_doc=self.webpackChunkrdk_doc||[]).push([[89791],{28453:(n,e,i)=>{i.d(e,{R:()=>l,x:()=>a});var t=i(96540);const s={},o=t.createContext(s);function l(n){const e=t.useContext(o);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:l(n.components),t.createElement(o.Provider,{value:e},n.children)}},64848:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>r,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"Basic_Application/03_40pin_user_guide/gpio","title":"3.3.2 Using GPIO","description":"The development board is equipped with the GPIO Python library Hobot.GPIO. Users can import the GPIO library with the following command.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/03_Basic_Application/03_40pin_user_guide/gpio.md","sourceDirName":"03_Basic_Application/03_40pin_user_guide","slug":"/Basic_Application/03_40pin_user_guide/gpio","permalink":"/rdk_doc/en/Basic_Application/03_40pin_user_guide/gpio","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1754898418000,"sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"3.3.1 Pin Configuration and Definition","permalink":"/rdk_doc/en/Basic_Application/03_40pin_user_guide/40pin_define"},"next":{"title":"3.3.3 Use PWM","permalink":"/rdk_doc/en/Basic_Application/03_40pin_user_guide/pwm"}}');var s=i(74848),o=i(28453);const l={sidebar_position:2},a="3.3.2 Using GPIO",r={},d=[{value:"Setting Pin Numbering Mode",id:"setting-pin-numbering-mode",level:2},{value:"Warning Messages",id:"warning-messages",level:2},{value:"Pin Configuration",id:"pin-configuration",level:2},{value:"Input Operation",id:"input-operation",level:2},{value:"Output Operation",id:"output-operation",level:2},{value:"Clearing Pin Usage",id:"clearing-pin-usage",level:2},{value:"Checking Pin State",id:"checking-pin-state",level:2},{value:"Edge Detection and Interrupts",id:"edge-detection-and-interrupts",level:2},{value:"wait_for_edge() function",id:"wait_for_edge-function",level:3},{value:"event_detected() function",id:"event_detected-function",level:3},{value:"Running a callback function when an edge event is detected",id:"running-a-callback-function-when-an-edge-event-is-detected",level:3},{value:"Disable Interrupts",id:"disable-interrupts",level:3},{value:"Test Cases",id:"test-cases",level:2},{value:"Introduction to <code>hb_gpioinfo</code> Tool",id:"introduction-to-hb_gpioinfo-tool",level:2},{value:"Components of <code>hb_gpioinfo</code>",id:"components-of-hb_gpioinfo",level:3},{value:"Example Usage of <code>hb_gpioinfo</code>",id:"example-usage-of-hb_gpioinfo",level:3}];function c(n){const e={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"332-using-gpio",children:"3.3.2 Using GPIO"})}),"\n",(0,s.jsxs)(e.p,{children:["The development board is equipped with the GPIO Python library ",(0,s.jsx)(e.code,{children:"Hobot.GPIO"}),". Users can import the GPIO library with the following command."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-shell",children:'sunrise@ubuntu:~$ sudo python3\nPython 3.8.10 (default, Mar 15 2022, 12:22:08) \nType "help", "copyright", "credits" or "license" for more information.\n>>> import Hobot.GPIO as GPIO\nGet board ID: 0x504\n>>> GPIO.VERSION\n\'0.0.2\'\n>>> GPIO.model\n\'X3PI\'\n'})}),"\n",(0,s.jsx)(e.h2,{id:"setting-pin-numbering-mode",children:"Setting Pin Numbering Mode"}),"\n",(0,s.jsx)(e.p,{children:"The development board has 4 pin numbering modes:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"BOARD: Physical pin numbering, corresponding to the silk screen numbering on the development board."}),"\n",(0,s.jsx)(e.li,{children:"BCM: GPIO naming based on the Broadcom SoC."}),"\n",(0,s.jsx)(e.li,{children:"CVM: Use strings instead of numbers, corresponding to the signal names of the CVM/CVB connectors."}),"\n",(0,s.jsx)(e.li,{children:"SOC: GPIO pin numbering corresponding to the X3M chip, matching the chip's datasheet."}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["This article recommends using the ",(0,s.jsx)(e.code,{children:"BOARD"})," pin numbering mode. The pin numbering can be set as follows:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"GPIO.setmode(GPIO.BOARD)\n# or\nGPIO.setmode(GPIO.BCM)\n# or\nGPIO.setmode(GPIO.CVM)\n# or \nGPIO.setmode(GPIO.SOC)\n"})}),"\n",(0,s.jsx)(e.p,{children:"To check the current pin numbering mode:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"mode = GPIO.getmode()\n"})}),"\n",(0,s.jsxs)(e.p,{children:["The program will output one of the results ",(0,s.jsx)(e.code,{children:"BOARD, BCM, CVM, SOC, or None"}),"."]}),"\n",(0,s.jsx)(e.h2,{id:"warning-messages",children:"Warning Messages"}),"\n",(0,s.jsx)(e.p,{children:"The code will produce warning log outputs, but will not affect normal functionality in the following cases:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"The GPIO being attempted to use by the user is already being used by another application."}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"GPIO.cleanup"})," is called to clean up the pins before setting the mode and channels."]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"To suppress the warning messages, you can use the following command:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"GPIO.setwarnings(False)\n"})}),"\n",(0,s.jsx)(e.h2,{id:"pin-configuration",children:"Pin Configuration"}),"\n",(0,s.jsx)(e.p,{children:"Before using GPIO pins, they need to be configured accordingly. Below are the specific configurations:"}),"\n",(0,s.jsx)(e.p,{children:"To set as input:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"GPIO.setup(channel, GPIO.IN)\n"})}),"\n",(0,s.jsx)(e.p,{children:"To set as output:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"GPIO.setup(channel, GPIO.OUT)\n"})}),"\n",(0,s.jsx)(e.p,{children:"You can also specify an initial value for the output channel. For example:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"GPIO.setup(channel, GPIO.OUT, initial=GPIO.HIGH)\n"})}),"\n",(0,s.jsx)(e.p,{children:"In addition, the tool supports setting multiple output channels at the same time. For example:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# set gpio(18,12,13) to output\nchannels = [18, 12, 13]\nGPIO.setup(channels, GPIO.OUT)\n"})}),"\n",(0,s.jsx)(e.h2,{id:"input-operation",children:"Input Operation"}),"\n",(0,s.jsx)(e.p,{children:"To read the value of a channel, use:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"GPIO.input(channel)\n"})}),"\n",(0,s.jsx)(e.p,{children:"The command returns either 0 or 1. 0 represents GPIO.LOW, and 1 represents GPIO.HIGH."}),"\n",(0,s.jsx)(e.h2,{id:"output-operation",children:"Output Operation"}),"\n",(0,s.jsx)(e.p,{children:"To set the output value of a channel, use:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"GPIO.output(channel, state)\n"})}),"\n",(0,s.jsx)(e.p,{children:"Where state can be GPIO.LOW or GPIO.HIGH."}),"\n",(0,s.jsx)(e.h2,{id:"clearing-pin-usage",children:"Clearing Pin Usage"}),"\n",(0,s.jsx)(e.p,{children:"Before exiting the program, it is recommended to perform a channel cleanup operation, use:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"GPIO.cleanup()\n"})}),"\n",(0,s.jsx)(e.p,{children:"If you only want to clean up specific channels, use:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# Clean up a single channel\nGPIO.cleanup(channel)\n# Clean up a group of channels\nGPIO.cleanup( (channel1, channel2) )\nGPIO.cleanup( [channel1, channel2] )\n"})}),"\n",(0,s.jsx)(e.h2,{id:"checking-pin-state",children:"Checking Pin State"}),"\n",(0,s.jsx)(e.p,{children:"This function allows you to check the function of the corresponding GPIO channel:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"GPIO.gpio_function(channel)\n"})}),"\n",(0,s.jsx)(e.p,{children:"This function returns IN or OUT."}),"\n",(0,s.jsx)(e.h2,{id:"edge-detection-and-interrupts",children:"Edge Detection and Interrupts"}),"\n",(0,s.jsx)(e.p,{children:"Edge refers to the change in the electrical signal from low to high (rising edge) or high to low (falling edge), which can be considered as the occurrence of an event. This event can be used to trigger a CPU interrupt signal."}),"\n",(0,s.jsxs)(e.admonition,{type:"info",children:[(0,s.jsxs)(e.p,{children:["On the ",(0,s.jsx)(e.code,{children:"RDK Ultra"})," platform, only a specific few pins on the ",(0,s.jsx)(e.code,{children:"40 pin"})," header can be used as interrupt pins. They are numbered as ",(0,s.jsx)(e.strong,{children:"13"}),", ",(0,s.jsx)(e.strong,{children:"16"}),", ",(0,s.jsx)(e.strong,{children:"18"}),", ",(0,s.jsx)(e.strong,{children:"22"}),", ",(0,s.jsx)(e.strong,{children:"27"}),", ",(0,s.jsx)(e.strong,{children:"28"}),", ",(0,s.jsx)(e.strong,{children:"32"}),", ",(0,s.jsx)(e.strong,{children:"33"}),", ",(0,s.jsx)(e.strong,{children:"37"})," in ",(0,s.jsx)(e.code,{children:"BOARD"})," mode."]}),(0,s.jsxs)(e.p,{children:["Please refer to ",(0,s.jsx)(e.a,{href:"./40pin_define#40pin_define",children:"Pin Configuration and Definitions"})," for pin definitions."]}),(0,s.jsx)(e.p,{children:":::The GPIO library provides three methods to detect input events:"}),(0,s.jsx)(e.h3,{id:"wait_for_edge-function",children:"wait_for_edge() function"}),(0,s.jsx)(e.p,{children:"This function blocks the calling thread until the corresponding edge change is detected. The function call is as follows:"}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"GPIO.wait_for_edge(channel, GPIO.RISING)\n"})}),(0,s.jsxs)(e.p,{children:["The second parameter specifies the edge to detect, which can be ",(0,s.jsx)(e.code,{children:"GPIO.RISING"}),", ",(0,s.jsx)(e.code,{children:"GPIO.FALLING"}),", or ",(0,s.jsx)(e.code,{children:"GPIO.BOTH"}),". If you want to specify a timeout, you can set the timeout parameter:"]}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# timeout specified in milliseconds\nGPIO.wait_for_edge(channel, GPIO.RISING, timeout=500)\n"})}),(0,s.jsx)(e.p,{children:"If the external signal changes within the timeout period, the function returns the detected channel number; if a timeout occurs, the function returns None."}),(0,s.jsx)(e.h3,{id:"event_detected-function",children:"event_detected() function"}),(0,s.jsx)(e.p,{children:"This function can be used to periodically check if an event has occurred since the last call. The function can be set and called as follows:"}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'# set rising edge detection on channel GPIO\nGPIO.add_event_detect(channel, GPIO.RISING)\nif GPIO.event_detected(channel):\n    print("Rising edge event detected")\n'})}),(0,s.jsxs)(e.p,{children:["You can detect events of ",(0,s.jsx)(e.code,{children:"GPIO.RISING"}),", ",(0,s.jsx)(e.code,{children:"GPIO.FALLING"}),", or ",(0,s.jsx)(e.code,{children:"GPIO.BOTH"}),"."]}),(0,s.jsx)(e.h3,{id:"running-a-callback-function-when-an-edge-event-is-detected",children:"Running a callback function when an edge event is detected"}),(0,s.jsx)(e.p,{children:"This feature can be used to register a callback function, which runs in a separate processing thread. Here is how to use it:"}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'# define callback function\ndef callback_fn(channel):\n    print("Callback called from channel %s" % channel)\n\n# enable rising detection\nGPIO.add_event_detect(channel, GPIO.RISING, callback=callback_fn)\n'})}),(0,s.jsx)(e.p,{children:"If needed, you can also add multiple callbacks by following the same method:"}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'def callback_one(channel):\n    print("First Callback")\n\ndef callback_two(channel):\n    print("Second Callback")\n\nGPIO.add_event_detect(channel, GPIO.RISING)\nGPIO.add_event_callback(channel, callback_one)\nGPIO.add_event_callback(channel, callback_two)\n'})}),(0,s.jsx)(e.p,{children:"Since all callback functions run on the same thread, different callbacks are executed in order, not simultaneously."}),(0,s.jsx)(e.p,{children:"To prevent multiple invocations of the callback function by merging multiple events into one event, you can choose to set debounce time:"}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# bouncetime unit is ms\nGPIO.add_event_detect(channel, GPIO.RISING, callback=callback_fn, bouncetime=200)\n"})}),(0,s.jsx)(e.h3,{id:"disable-interrupts",children:"Disable Interrupts"}),(0,s.jsx)(e.p,{children:"If edge detection is no longer needed, you can remove it as follows:"}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"GPIO.remove_event_detect(channel)\n"})}),(0,s.jsx)(e.h2,{id:"test-cases",children:"Test Cases"}),(0,s.jsxs)(e.p,{children:["The main test cases are provided in the ",(0,s.jsx)(e.code,{children:"/app/40pin_samples/"})," directory:"]}),(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Test Case"}),(0,s.jsx)(e.th,{children:"Description"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"simple_out.py"}),(0,s.jsxs)(e.td,{children:["Testing a single pin ",(0,s.jsx)(e.code,{children:"output"})]})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"simple_input.py"}),(0,s.jsxs)(e.td,{children:["Testing a single pin ",(0,s.jsx)(e.code,{children:"input"})]})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"button_led.py"}),(0,s.jsx)(e.td,{children:"Using one pin as a button input and another as an LED output"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"test_all_pins_input.py"}),(0,s.jsxs)(e.td,{children:["Code for ",(0,s.jsx)(e.code,{children:"input testing"})," for all pins"]})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"test_all_pins.py"}),(0,s.jsxs)(e.td,{children:["Code for ",(0,s.jsx)(e.code,{children:"output testing"})," for all pins"]})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"button_event.py"}),(0,s.jsx)(e.td,{children:"Capturing rising and falling edge events on a pin"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"button_interrupt.py"}),(0,s.jsx)(e.td,{children:"Handling rising and falling edge events on a pin using interrupts"})]})]})]}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["Set GPIO to ",(0,s.jsx)(e.code,{children:"output mode"}),", toggle the output level every 1 second, which can be used to control the LED cycle on and off. Test code ",(0,s.jsx)(e.code,{children:"simple_out.py"}),":"]}),"\n"]}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\n\nimport Hobot.GPIO as GPIO\nimport time\n\n# Define the GPIO channel used as 38output_pin = 38 # BOARD code 38\n\ndef main():\n    # Set the pin numbering mode to BOARD\n    GPIO.setmode(GPIO.BOARD)\n    # Set the pin as output and initialize it to high level\n    GPIO.setup(output_pin, GPIO.OUT, initial=GPIO.HIGH)\n    # Record the current pin state\n    curr_value = GPIO.HIGH\n    print(\"Starting demo now! Press CTRL+C to exit\")\n    try:\n        # Loop to control the LED light on and off every 1 second\n        while True:\n            time.sleep(1)\n            GPIO.output(output_pin, curr_value)\n            curr_value ^= GPIO.HIGH\n    finally:\n        GPIO.cleanup()\n\nif __name__=='__main__':\n    main()\n"})}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["GPIO is set to ",(0,s.jsx)(e.code,{children:"input mode"}),", and the pin level is read through busy polling, using the test code ",(0,s.jsx)(e.code,{children:"simple_input.py"}),":"]}),"\n"]}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n\nimport Hobot.GPIO as GPIO\nimport time\n\n# Define the GPIO channel as 38\ninput_pin = 38 # BOARD code 38\n\ndef main():\n    prev_value = None\n\n    # Set the pin numbering mode to BOARD\n    GPIO.setmode(GPIO.BOARD)\n    # Set the pin as input\n    GPIO.setup(input_pin, GPIO.IN)\n\n    print("Starting demo now! Press CTRL+C to exit")\n    try:\n        while True:\n            # Read the pin level\n            value = GPIO.input(input_pin)\n            if value != prev_value:\n                if value == GPIO.HIGH:\n                    value_str = "HIGH"else:\n                value_str = "LOW"\n            print("Value read from pin {} : {}".format(input_pin, value_str))\n            prev_value = value\n        time.sleep(1)\nfinally:\n    GPIO.cleanup()\n\nif __name__==\'__main__\':\n    main()\n\n'})}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["Set GPIO to input mode, capture rising and falling edge events on the pin, test code ",(0,s.jsx)(e.code,{children:"button_event.py"}),", detect falling edge of pin 38, and control the output of pin 31:"]}),"\n"]}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n\nimport RPi.GPIO as GPIO\nimport time\n\n# Define the GPIO channels:\n# Pin 31 as output to light up an LED\n# Pin 38 as input for a button\nled_pin = 31  # BOARD coding 31\nbut_pin = 38  # BOARD coding 38\n\n# Disable warning messages\nGPIO.setwarnings(False)\n\ndef main():\n    # Set the pin coding mode to BOARD\n    GPIO.setmode(GPIO.BOARD)\n    GPIO.setup(led_pin, GPIO.OUT)  # LED pin set as output\n    GPIO.setup(but_pin, GPIO.IN)  # button pin set as input\n\n    # Initial state for LEDs:\n    GPIO.output(led_pin, GPIO.LOW)\n\n    print("Starting demo now! Press CTRL+C to exit")\n    try:\n        while True:\n            print("Waiting for button event")\n            GPIO.wait_for_edge(but_pin, GPIO.FALLING)\n\n            # event received when button pressed\n            print("Button Pressed!")\n            GPIO.output(led_pin, GPIO.HIGH)\n            time.sleep(1)\n            GPIO.output(led_pin, GPIO.LOW)finally:\n    GPIO.cleanup()  # cleanup all GPIOs\n\nif __name__ == \'__main__\':\n    main()\n'})}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["Set GPIO pins to input mode, enable GPIO interrupt function, respond to rising and falling edge events on the pins, test code ",(0,s.jsx)(e.code,{children:"button_interrupt.py"}),", detect falling edge on pin 38, and then control pin 36 to switch between high and low levels quickly for 5 seconds."]}),"\n"]}),(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\nimport sys\nimport signal\nimport Hobot.GPIO as GPIO\nimport time\n\ndef signal_handler(signal, frame):\n    sys.exit(0)\n\n# Define GPIO channels:\n# Pin 12 as output, can light up an LED\n# Pin 13 as output, can light up an LED\n# Pin 38 as input, can connect a button\nled_pin_1 = 12 # BOARD code 12\nled_pin_2 = 13 # BOARD code 13\nbut_pin = 38   # BOARD code 38\n\n# Disable warning messages\nGPIO.setwarnings(False)\n\n# Blink LED 2 fast for 5 times when the button is pressed\ndef blink(channel):\n    print("Blink LED 2")\n    for i in range(5):\n        GPIO.output(led_pin_2, GPIO.HIGH)\n        time.sleep(0.5)\n        GPIO.output(led_pin_2, GPIO.LOW)\n        time.sleep(0.5)\n\ndef main():\n    # Pin Setup:\n    GPIO.setmode(GPIO.BOARD)  # BOARD pin-numbering scheme\n    GPIO.setup([led_pin_1, led_pin_2], GPIO.OUT)  # LED pins set as output\n    GPIO.setup(but_pin, GPIO.IN)  # button pin set as input\n\n    # Initial state for LEDs:\n    GPIO.output(led_pin_1, GPIO.LOW)\n    GPIO.output(led_pin_2, GPIO.LOW)\n\n    # Register blink function as the interrupt handler for falling edge events on the button pin.GPIO.add_event_detect(but_pin, GPIO.FALLING, callback=blink, bouncetime=10)\n    # Start testing, Led1 slowly blink\n    print("Starting demo now! Press CTRL+C to exit")\n    try:\n        while True:\n            # blink LED 1 slowly\n            GPIO.output(led_pin_1, GPIO.HIGH)\n            time.sleep(2)\n            GPIO.output(led_pin_1, GPIO.LOW)\n            time.sleep(2)\n    finally:\n        GPIO.cleanup()  # cleanup all GPIOs\n\nif __name__ == \'__main__\':\n    signal.signal(signal.SIGINT, signal_handler)\n    main()\n'})})]}),"\n",(0,s.jsxs)(e.h2,{id:"introduction-to-hb_gpioinfo-tool",children:["Introduction to ",(0,s.jsx)(e.code,{children:"hb_gpioinfo"})," Tool"]}),"\n",(0,s.jsxs)(e.p,{children:["The ",(0,s.jsx)(e.code,{children:"hb_gpioinfo"})," tool is a GPIO helper tool adapted for the X5 platform. It is used to view the mapping relationship between ",(0,s.jsx)(e.code,{children:"PinName"})," and ",(0,s.jsx)(e.code,{children:"PinNum"})," on the current development board."]}),"\n",(0,s.jsxs)(e.h3,{id:"components-of-hb_gpioinfo",children:["Components of ",(0,s.jsx)(e.code,{children:"hb_gpioinfo"})]}),"\n",(0,s.jsxs)(e.p,{children:["The ",(0,s.jsx)(e.code,{children:"hb_gpioinfo"})," tool consists of two parts:"]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Driver"}),": Parses the ",(0,s.jsx)(e.code,{children:"pinmux-gpio.dtsi"})," file and exports ",(0,s.jsx)(e.code,{children:"PinNode"})," and ",(0,s.jsx)(e.code,{children:"PinName"})," information to the ",(0,s.jsx)(e.code,{children:"debugfs"})," system."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Application"}),": Parses and displays the information in the terminal."]}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Driver Code Path:"})," ",(0,s.jsx)(e.code,{children:"kernel/drivers/gpio/hobot_gpio_debug.c"})]}),"\n"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsxs)(e.h3,{id:"example-usage-of-hb_gpioinfo",children:["Example Usage of ",(0,s.jsx)(e.code,{children:"hb_gpioinfo"})]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"PinName:"})," Refers to the pin name on the SoC, consistent with the X5 SoC pin names in the schematic."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"PinNode:"})," Refers to the ",(0,s.jsx)(e.code,{children:"PinNode"})," information in the device tree."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"PinNum:"})," Refers to the actual GPIO number corresponding to the pin on the X5."]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"root@ubuntu:~# hb_gpioinfo\ngpiochip0 - 8 lines: @platform/31000000.gpio: @GPIOs 498-505\n        [Number]                [Mode]  [Status]  [GpioName]       [PinName]              [PinNode]           [PinNum]\n        line  0:        unnamed input                             AON_GPIO0_PIN0        aon_gpio_0              498\n        line  1:        unnamed input                             AON_GPIO0_PIN1        aon_gpio_1              499\n        line  2:        unnamed input  active-low  GPIO Key Power AON_GPIO0_PIN2        aon_gpio_2              500\n        line  3:        unnamed input              interrupt      AON_GPIO0_PIN3        aon_gpio_3              501\n        line  4:        unnamed input                             AON_GPIO0_PIN4        aon_gpio_4              502\n        line  5:        unnamed input              id             AON_ENV_VDD           aon_gpio_5              503\n        line  6:        unnamed input              id             AON_ENV_CNN0          aon_gpio_6              504\n        line  7:        unnamed input                             AON_ENV_CNN1          aon_gpio_7              505\ngpiochip1 - 31 lines: @platform/35060000.gpio: @GPIOs 466-496\n        [Number]                [Mode]  [Status]  [GpioName]       [PinName]              [PinNode]           [PinNum]\n        line  0:        unnamed input                             HSIO_ENET_MDC         hsio_gpio0_0            466\n        line  1:        unnamed input                             HSIO_ENET_MDIO        hsio_gpio0_1            467\n        line  2:        unnamed input                             HSIO_ENET_TXD_0       hsio_gpio0_2            468\n        line  3:        unnamed input                             HSIO_ENET_TXD_1       hsio_gpio0_3            469\n        line  4:        unnamed input                             HSIO_ENET_TXD_2       hsio_gpio0_4            470\n        line  5:        unnamed input                             HSIO_ENET_TXD_3       hsio_gpio0_5            471\n        line  6:        unnamed input                             HSIO_ENET_TXEN        hsio_gpio0_6            472\n        line  7:        unnamed input                             HSIO_ENET_TX_CLK      hsio_gpio0_7            473\n        line  8:        unnamed input                             HSIO_ENET_RX_CLK      hsio_gpio0_8            474\n        ....\n"})})]})}function p(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(c,{...n})}):c(n)}}}]);