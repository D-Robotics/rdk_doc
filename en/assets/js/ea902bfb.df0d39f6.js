"use strict";(self.webpackChunkrdk_doc=self.webpackChunkrdk_doc||[]).push([[87594],{17744:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"Advanced_development/linux_development/driver_development/driver_thermal_dev","title":"Thermal System","description":"Temperature Sensor","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/07_Advanced_development/02_linux_development/driver_development/driver_thermal_dev.md","sourceDirName":"07_Advanced_development/02_linux_development/driver_development","slug":"/Advanced_development/linux_development/driver_development/driver_thermal_dev","permalink":"/rdk_doc/en/Advanced_development/linux_development/driver_development/driver_thermal_dev","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1761726760000,"sidebarPosition":10,"frontMatter":{"sidebar_position":10},"sidebar":"tutorialSidebar","previous":{"title":"BPU Driver sysfs debugging interface","permalink":"/rdk_doc/en/Advanced_development/linux_development/driver_development/driver_bpu_sysfs_dev"},"next":{"title":"Modifying BPU Reserved Memory Size","permalink":"/rdk_doc/en/Advanced_development/linux_development/driver_development/driver_bpu_mem_dev"}}');var i=n(74848),s=n(28453);const o={sidebar_position:10},l="Thermal System",a={},d=[{value:"Temperature Sensor",id:"temperature-sensor",level:2},{value:"Thermal",id:"thermal",level:2},{value:"Thermal Reference Documentation",id:"thermal-reference-documentation",level:2}];function c(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"thermal-system",children:"Thermal System"})}),"\n",(0,i.jsx)(t.h2,{id:"temperature-sensor",children:"Temperature Sensor"}),"\n",(0,i.jsx)(t.p,{children:"There is a temperature sensor on the X3 chip, which directly reflects the temperature of the X3 chip DIE."}),"\n",(0,i.jsx)(t.p,{children:"Under /sys/class/hwmon/, there is a hwmon0 directory containing relevant parameters of the temperature sensor."}),"\n",(0,i.jsx)(t.p,{children:"Important files: name and temp1_input."}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"name refers to the name of the temperature sensor."}),"\n",(0,i.jsx)(t.li,{children:"temp1_input refers to the temperature value, with a default precision of 0.001 degrees Celsius."}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"# cat /sys/class/hwmon/hwmon0/name\npvt_ts\n# cat /sys/class/hwmon/hwmon0/temp1_input\n55892\n# 55892 represents 55.892 degrees Celsius\n"})}),"\n",(0,i.jsx)(t.p,{children:"The temperature of this hwmon0 device directly affects the device at cat /sys/class/thermal/thermal_zone0/temp, and the values of the two are identical."}),"\n",(0,i.jsx)(t.h2,{id:"thermal",children:"Thermal"}),"\n",(0,i.jsx)(t.p,{children:"Linux Thermal is a module related to temperature control in the Linux system. It is mainly used to control the heat generated by chips during system operation, ensuring that the chip temperature and device casing temperature are maintained within a safe and comfortable range."}),"\n",(0,i.jsx)(t.p,{children:"In order to achieve reasonable control of device temperature, we need to understand the following three modules:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Device for obtaining temperature: in the Thermal framework, it is abstracted as the Thermal Zone Device, which is the temperature sensor thermal_zone0."}),"\n",(0,i.jsx)(t.li,{children:"Device that needs cooling: in the Thermal framework, it is abstracted as the Thermal Cooling Device, including CPU and GPU."}),"\n",(0,i.jsx)(t.li,{children:"Temperature control strategy: in the Thermal framework, it is abstracted as the Thermal Governor."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Information and controls for the above modules can be obtained in the /sys/class/thermal directory."}),"\n",(0,i.jsx)(t.p,{children:"There are a total of three cooling devices in the x3:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"cooling_device0: cnn0"}),"\n",(0,i.jsx)(t.li,{children:"cooling_device1: cnn1"}),"\n",(0,i.jsx)(t.li,{children:"cooling_device2: cpu"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Currently, the default strategy can be determined by the following command, which uses step_wise."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"cat /sys/class/thermal/thermal_zone0/policy\n"})}),"\n",(0,i.jsx)(t.p,{children:"The supported policies can be viewed using the following command: user_space and step_wise, a total of two."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"cat /sys/class/thermal/thermal_zone0/available_policies\n"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"user_space is a strategy that reports the current temperature of the thermal zone, as well as temperature control triggering points and other information to user space through uevent. The temperature control strategy is determined by user space software."}),"\n",(0,i.jsx)(t.li,{children:"step_wise is a relatively mild temperature control strategy that gradually increases the cooling state in each polling cycle."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"The specific choice of strategy depends on the needs of the product. It can be specified during compilation or dynamically switched through sysfs."}),"\n",(0,i.jsx)(t.p,{children:"For example, to dynamically switch to the user_space mode:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"echo user_space > /sys/class/thermal/thermal_zone0/policy \n"})}),"\n",(0,i.jsx)(t.p,{children:"Executing the following command will show three trip points (trigger temperatures)."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"ls -l  /sys/devices/virtual/thermal/thermal_zone0\n"})}),"\n",(0,i.jsx)(t.p,{children:"Currently, the default trip point selected is trip_point_1_temp (temperature is 75 degrees)."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"trip_point_*_hyst (*:0 - 2) # hysteresis temperature\ntrip_point_*_temp (*: 0 - 2) # trigger temperature\ntrip_point_*_type (*: 0 - 2) # trigger point type\n"})}),"\n",(0,i.jsx)(t.p,{children:"If you want to delay frequency reduction until the temperature reaches 85 degrees Celsius:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"echo 85000 > /sys/devices/virtual/thermal/thermal_zone0/trip_point_1_temp\n"})}),"\n",(0,i.jsx)(t.p,{children:"If you want to adjust the shutdown temperature to 105 degrees Celsius:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"echo 105000 > /sys/devices/virtual/thermal/thermal_zone0/trip_point_2_temp\n"})}),"\n",(0,i.jsx)(t.p,{children:"Note: The above settings need to be set again after power-off and restart."}),"\n",(0,i.jsx)(t.h2,{id:"thermal-reference-documentation",children:"Thermal Reference Documentation"}),"\n",(0,i.jsx)(t.p,{children:"kernel/Documentation/thermal/"})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>l});var r=n(96540);const i={},s=r.createContext(i);function o(e){const t=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);