"use strict";(self.webpackChunkrdk_doc=self.webpackChunkrdk_doc||[]).push([[20674],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var i=t(96540);const s={},c=i.createContext(s);function r(e){const n=i.useContext(c);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(c.Provider,{value:n},e.children)}},65158:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"Advanced_development/mcu_development/S100/mcu_i2c","title":"I2C Usage Guide","description":"The S100 MCU chip provides a standard I2C bus. The I2C bus controller transfers information between devices connected to the bus via a Serial Data Line (SDA) and a Serial Clock Line (SCL). Each device has a unique address. The primary function of the I2C subsystem is to enable serial communication between the microcontroller and peripheral devices. It can drive MIPI daughter cards, PMIC chips, and other commonly used peripherals.","source":"@site/i18n/en/docusaurus-plugin-content-docs-docs_s/current/07_Advanced_development/05_mcu_development/01_S100/10_mcu_i2c.md","sourceDirName":"07_Advanced_development/05_mcu_development/01_S100","slug":"/Advanced_development/mcu_development/S100/mcu_i2c","permalink":"/rdk_doc/en/rdk_s/Advanced_development/mcu_development/S100/mcu_i2c","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1764645625000,"sidebarPosition":10,"frontMatter":{"sidebar_position":10},"sidebar":"tutorialSidebar","previous":{"title":"CAN Usage Guide","permalink":"/rdk_doc/en/rdk_s/Advanced_development/mcu_development/S100/mcu_can"},"next":{"title":"Eth Usage Guide","permalink":"/rdk_doc/en/rdk_s/Advanced_development/mcu_development/S100/mcu_eth"}}');var s=t(74848),c=t(28453);const r={sidebar_position:10},a="I2C Usage Guide",o={},d=[{value:"I2C Controller",id:"i2c-controller",level:2},{value:"Code Paths",id:"code-paths",level:2},{value:"Initialization and Scheduling",id:"initialization-and-scheduling",level:3},{value:"I2C Usage",id:"i2c-usage",level:2},{value:"Application Programming Interface (API)",id:"application-programming-interface-api",level:2},{value:"void I2c_Init ( const I2c_ConfigType * Config )",id:"void-i2c_init--const-i2c_configtype--config-",level:3},{value:"void I2c_DeInit ( void )",id:"void-i2c_deinit--void-",level:3},{value:"Std_ReturnType I2c_SyncDataTrans ( uint8 Channel, const I2c_RequestType* RequestPtr )",id:"std_returntype-i2c_syncdatatrans--uint8-channel-const-i2c_requesttype-requestptr-",level:3},{value:"Std_ReturnType I2c_SyncMultiDataTrans ( uint8 Channel, const I2c_RequestType* RequestPtr, uint8 I2cRequestCnt )",id:"std_returntype-i2c_syncmultidatatrans--uint8-channel-const-i2c_requesttype-requestptr-uint8-i2crequestcnt-",level:3},{value:"Std_ReturnType I2c_AsyncDataTrans ( uint8 Channel, const I2c_RequestType* RequestPtr )",id:"std_returntype-i2c_asyncdatatrans--uint8-channel-const-i2c_requesttype-requestptr-",level:3},{value:"I2c_StatusType I2c_StatusGet ( uint8 Channel )",id:"i2c_statustype-i2c_statusget--uint8-channel-",level:3},{value:"void I2c_GetVersionInfo ( Std_VersionInfoType* VersionInfo )",id:"void-i2c_getversioninfo--std_versioninfotype-versioninfo-",level:3}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,c.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"i2c-usage-guide",children:"I2C Usage Guide"})}),"\n",(0,s.jsx)(n.p,{children:"The S100 MCU chip provides a standard I2C bus. The I2C bus controller transfers information between devices connected to the bus via a Serial Data Line (SDA) and a Serial Clock Line (SCL). Each device has a unique address. The primary function of the I2C subsystem is to enable serial communication between the microcontroller and peripheral devices. It can drive MIPI daughter cards, PMIC chips, and other commonly used peripherals."}),"\n",(0,s.jsx)(n.h2,{id:"i2c-controller",children:"I2C Controller"}),"\n",(0,s.jsx)(n.p,{children:"The I2C controller supports the following features:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Three speed mode selections (currently, the driver does not support HIGH SPEED mode):","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Standard Mode"}),": 0\u2013100 Kb/s"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fast Mode & Fast Mode Plus"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Fast Mode: 0\u2013400 Kb/s"}),"\n",(0,s.jsx)(n.li,{children:"Fast Mode Plus: 0\u20131000 Kb/s"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"High-Speed Mode"}),": 0\u20133.4 Mb/s"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Supports master and slave mode configuration"}),"\n",(0,s.jsx)(n.li,{children:"Supports both 7-bit and 10-bit addressing modes"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The S100 MCU chip provides a total of four I2C controllers (I2C6\u2013I2C9), with a default speed setting of Fast Mode Plus."}),"\n",(0,s.jsx)(n.h2,{id:"code-paths",children:"Code Paths"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"McalCdd/Common/Register/inc/I2c_Register.h # Register-related content"}),"\n",(0,s.jsx)(n.li,{children:"McalCdd/I2c/src/I2c.c # Driver source code"}),"\n",(0,s.jsx)(n.li,{children:"McalCdd/I2c/src/I2c_Lld.c # Low-level driver source code"}),"\n",(0,s.jsx)(n.li,{children:"McalCdd/I2c/inc/I2c.h # Driver header file"}),"\n",(0,s.jsx)(n.li,{children:"McalCdd/I2c/inc/I2c_Lld.h # Low-level driver header file"}),"\n",(0,s.jsx)(n.li,{children:"Config/McalCdd/gen_s100_sip_B_mcu1/I2c/src/I2c_PBcfg.c # PB configuration file"}),"\n",(0,s.jsx)(n.li,{children:"Config/McalCdd/gen_s100_sip_B_mcu1/I2c/inc/I2c_PBcfg.h # PB configuration header file"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"initialization-and-scheduling",children:"Initialization and Scheduling"}),"\n",(0,s.jsxs)(n.p,{children:["Initialization of general-purpose I/O pins is outside the scope of the I2C driver and should be handled first by the PORT driver (via ",(0,s.jsx)(n.code,{children:"Port_Init(NULL);"}),") before using the I2C driver. The I2C driver initialization function is ",(0,s.jsx)(n.code,{children:"I2c_Init(NULL)"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"i2c-usage",children:"I2C Usage"}),"\n",(0,s.jsx)(n.p,{children:"S100 implements a set of commands on the MCU side similar to the open-source i2c-tools utilities to support user debugging."}),"\n",(0,s.jsx)(n.p,{children:"Code path:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"samples/I2c/src/I2c_Cmd.c\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Currently supported commands include ",(0,s.jsx)(n.code,{children:"i2cdetect"}),", ",(0,s.jsx)(n.code,{children:"i2cget"}),", and ",(0,s.jsx)(n.code,{children:"i2cset"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"i2cdetect"})," \u2014 Lists I2C buses and all devices present on a specific bus"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"i2cget"})," \u2014 Reads the value of a specific register from an I2C device"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"i2cset"})," \u2014 Writes a value to a specific register of an I2C device"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Test example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"D-Robotics:/$ i2cdetect 7\n     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f\n00:    -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n10: -- -- 12 -- -- -- -- -- -- -- -- -- -- -- -- --\n20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n70: -- -- -- -- -- -- -- --\n"})}),"\n",(0,s.jsx)(n.h2,{id:"application-programming-interface-api",children:"Application Programming Interface (API)"}),"\n",(0,s.jsx)(n.h3,{id:"void-i2c_init--const-i2c_configtype--config-",children:"void I2c_Init ( const I2c_ConfigType * Config )"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: Subsystem driver initialization function.\n\nSync/Async: Synchronous\nParameters (in):\n    Config: Pointer to configuration structure\nParameters (inout):\n    None\nParameters (out):\n    None\nReturn value: None\n"})}),"\n",(0,s.jsx)(n.h3,{id:"void-i2c_deinit--void-",children:"void I2c_DeInit ( void )"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: De-initializes the I2C system to reset values.\n\nSync/Async: Synchronous\nParameters (in):\n    None\nParameters (inout):\n    None\nParameters (out):\n    None\nReturn value: None\n"})}),"\n",(0,s.jsx)(n.h3,{id:"std_returntype-i2c_syncdatatrans--uint8-channel-const-i2c_requesttype-requestptr-",children:"Std_ReturnType I2c_SyncDataTrans ( uint8 Channel, const I2c_RequestType* RequestPtr )"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: Sends or receives an I2C message in blocking mode.\n\nSync/Async: Synchronous\nParameters (in):\n    Channel: I2C channel.\n    RequestPtr: I2C transmit request type\nParameters (inout):\n    None\nParameters (out):\n    None\nReturn value:\n    E_OK: Command has been accepted\n    E_NOT_OK: Command has not been accepted\n"})}),"\n",(0,s.jsx)(n.h3,{id:"std_returntype-i2c_syncmultidatatrans--uint8-channel-const-i2c_requesttype-requestptr-uint8-i2crequestcnt-",children:"Std_ReturnType I2c_SyncMultiDataTrans ( uint8 Channel, const I2c_RequestType* RequestPtr, uint8 I2cRequestCnt )"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: Sends or receives multiple I2C messages in blocking mode.\n\nSync/Async: Synchronous\nParameters (in):\n    Channel: I2C channel.\n    RequestPtr: I2C transmit request type\n    I2cRequestCnt: Number of I2C transmit requests\nParameters (inout):\n    None\nParameters (out):\n    None\nReturn value:\n    E_OK: Command has been accepted\n    E_NOT_OK: Command has not been accepted\n"})}),"\n",(0,s.jsx)(n.h3,{id:"std_returntype-i2c_asyncdatatrans--uint8-channel-const-i2c_requesttype-requestptr-",children:"Std_ReturnType I2c_AsyncDataTrans ( uint8 Channel, const I2c_RequestType* RequestPtr )"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: Sends or receives an I2C message in non-blocking mode.\n\nSync/Async: Asynchronous\nParameters (in):\n    Channel: I2C channel.\n    RequestPtr: I2C transmit request type\nParameters (inout):\n    None\nParameters (out):\n    None\nReturn value:\n    E_OK: Command has been accepted\n    E_NOT_OK: Command has not been accepted\n"})}),"\n",(0,s.jsx)(n.h3,{id:"i2c_statustype-i2c_statusget--uint8-channel-",children:"I2c_StatusType I2c_StatusGet ( uint8 Channel )"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: Gets the status of an I2C channel.\n\nSync/Async: Synchronous\nParameters (in):\n    Channel: I2C channel.\nParameters (inout):\n    None\nParameters (out):\n    None\nReturn value: Status of the I2C channel\n"})}),"\n",(0,s.jsx)(n.h3,{id:"void-i2c_getversioninfo--std_versioninfotype-versioninfo-",children:"void I2c_GetVersionInfo ( Std_VersionInfoType* VersionInfo )"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"Description: Retrieves the version information of this module.\n\nSync/Async: Synchronous\nParameters (in):\n    VersionInfo: Version information of this module\nParameters (inout):\n    None\nParameters (out):\n    None\nReturn value: None\n"})})]})}function u(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);