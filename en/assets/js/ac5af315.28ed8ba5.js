"use strict";(self.webpackChunkrdk_doc=self.webpackChunkrdk_doc||[]).push([[706],{28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>l});var d=i(96540);const t={},s=d.createContext(t);function r(e){const n=d.useContext(s);return d.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),d.createElement(s.Provider,{value:n},e.children)}},78177:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>d,toc:()=>c});const d=JSON.parse('{"id":"Basic_Application/multi_media/multi_media_api/cdev_multimedia_api_ultra/sys_api","title":"SYS (Module Binding) API","description":"The SYS API provides interfaces for binding and unbinding different modules such as VIO, ENCODER, DECODER, and DISPLAY. This allows seamless data transfer between the modules without requiring manual data fetching and setting.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/03_Basic_Application/04_multi_media/multi_media_api/cdev_multimedia_api_ultra/sys_api.md","sourceDirName":"03_Basic_Application/04_multi_media/multi_media_api/cdev_multimedia_api_ultra","slug":"/Basic_Application/multi_media/multi_media_api/cdev_multimedia_api_ultra/sys_api","permalink":"/rdk_doc/en/Basic_Application/multi_media/multi_media_api/cdev_multimedia_api_ultra/sys_api","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1757664965000,"sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"BPU (Algorithm Inference Module) API","permalink":"/rdk_doc/en/Basic_Application/multi_media/multi_media_api/cdev_multimedia_api_ultra/bpu_api"},"next":{"title":"4. \u7b97\u6cd5\u5e94\u7528\u5f00\u53d1","permalink":"/rdk_doc/en/Basic_Development"}}');var t=i(74848),s=i(28453);const r={sidebar_position:6},l="SYS (Module Binding) API",o={},c=[{value:"Functions",id:"functions",level:2},{value:"sp_module_bind",id:"sp_module_bind",level:2},{value:"sp_module_unbind",id:"sp_module_unbind",level:2}];function a(e){const n={br:"br",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"sys-module-binding-api",children:"SYS (Module Binding) API"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"SYS"})," API provides interfaces for binding and unbinding different modules such as ",(0,t.jsx)(n.code,{children:"VIO"}),", ",(0,t.jsx)(n.code,{children:"ENCODER"}),", ",(0,t.jsx)(n.code,{children:"DECODER"}),", and ",(0,t.jsx)(n.code,{children:"DISPLAY"}),". This allows seamless data transfer between the modules without requiring manual data fetching and setting."]}),"\n",(0,t.jsx)(n.h2,{id:"functions",children:"Functions"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Function"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"sp_module_bind"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Bind source and destination modules for automatic data flow"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"sp_module_unbind"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Unbind previously bound modules"})})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"sp_module_bind",children:"sp_module_bind"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Function Declaration"}),(0,t.jsx)(n.br,{}),"\n",(0,t.jsx)(n.code,{children:"int32_t sp_module_bind(void *src, int32_t src_type, void *dst, int32_t dst_type)"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description"}),(0,t.jsx)(n.br,{}),"\n","This function binds the output of one module to the input of another. Once bound, data flows automatically between the modules without user intervention. For example, if ",(0,t.jsx)(n.code,{children:"VIO"})," and ",(0,t.jsx)(n.code,{children:"DISPLAY"})," are bound, the data from a connected MIPI camera will be automatically displayed on the screen without needing to manually fetch frames from ",(0,t.jsx)(n.code,{children:"VIO"})," and pass them to ",(0,t.jsx)(n.code,{children:"DISPLAY"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"The following module bindings are supported:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Source Module"}),(0,t.jsx)(n.th,{children:"Destination Module"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"VIO"}),(0,t.jsx)(n.td,{children:"ENCODER"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"VIO"}),(0,t.jsx)(n.td,{children:"DISPLAY"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"DECODER"}),(0,t.jsx)(n.td,{children:"ENCODER"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"DECODER"}),(0,t.jsx)(n.td,{children:"DISPLAY"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"src"}),": The source module object pointer (obtained by calling the initialization interface for each module)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"src_type"}),": The type of the source module. Supported types are ",(0,t.jsx)(n.code,{children:"SP_MTYPE_VIO"})," and ",(0,t.jsx)(n.code,{children:"SP_MTYPE_DECODER"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"dst"}),": The destination module object pointer (obtained by calling the initialization interface for each module)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"dst_type"}),": The type of the destination module. Supported types are ",(0,t.jsx)(n.code,{children:"SP_MTYPE_ENCODER"})," and ",(0,t.jsx)(n.code,{children:"SP_MTYPE_DISPLAY"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Return Type"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Returns ",(0,t.jsx)(n.code,{children:"0"})," on success."]}),"\n",(0,t.jsx)(n.li,{children:"Returns a non-zero value on failure."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"sp_module_unbind",children:"sp_module_unbind"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Function Declaration"}),(0,t.jsx)(n.br,{}),"\n",(0,t.jsx)(n.code,{children:"int32_t sp_module_unbind(void *src, int32_t src_type, void *dst, int32_t dst_type)"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description"}),(0,t.jsx)(n.br,{}),"\n","This function unbinds previously bound modules, stopping the automatic data flow between them. It is necessary to unbind modules before exiting or shutting down the system."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"src"}),": The source module object pointer (obtained by calling the initialization interface for each module)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"src_type"}),": The type of the source module. Supported types are ",(0,t.jsx)(n.code,{children:"SP_MTYPE_VIO"})," and ",(0,t.jsx)(n.code,{children:"SP_MTYPE_DECODER"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"dst"}),": The destination module object pointer (obtained by calling the initialization interface for each module)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"dst_type"}),": The type of the destination module. Supported types are ",(0,t.jsx)(n.code,{children:"SP_MTYPE_ENCODER"})," and ",(0,t.jsx)(n.code,{children:"SP_MTYPE_DISPLAY"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Return Type"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Returns ",(0,t.jsx)(n.code,{children:"0"})," on success."]}),"\n",(0,t.jsx)(n.li,{children:"Returns a non-zero value on failure."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}}}]);