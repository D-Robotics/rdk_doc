"use strict";(self.webpackChunkrdk_doc=self.webpackChunkrdk_doc||[]).push([[99548],{28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>d});var i=t(96540);const a={},r=i.createContext(a);function s(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(r.Provider,{value:n},e.children)}},75406:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"Algorithm_Application/cdev_dnn_api/data_alignment","title":"4.2.8 Data Layout and Alignment Rules","description":"Data Layout","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/04_Algorithm_Application/02_cdev_dnn_api/data_alignment.md","sourceDirName":"04_Algorithm_Application/02_cdev_dnn_api","slug":"/Algorithm_Application/cdev_dnn_api/data_alignment","permalink":"/rdk_doc/en/Algorithm_Application/cdev_dnn_api/data_alignment","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1750509720000,"sidebarPosition":8,"frontMatter":{"sidebar_position":8},"sidebar":"tutorialSidebar","previous":{"title":"4.2.7 Data Types and Data Structures","permalink":"/rdk_doc/en/Algorithm_Application/cdev_dnn_api/data_struct"},"next":{"title":"4.2.9 Model Inference DEBUG Method","permalink":"/rdk_doc/en/Algorithm_Application/cdev_dnn_api/model_debug"}}');var a=t(74848),r=t(28453);const s={sidebar_position:8},d="4.2.8 Data Layout and Alignment Rules",o={},l=[{value:"Data Layout",id:"data-layout",level:2},{value:"BPU Alignment Restriction Rules",id:"bpu-alignment-restriction-rules",level:2},{value:"Model Input Requirements",id:"model-input-requirements",level:3},{value:"Alignment and Valid Data",id:"alignment-and-valid-data",level:3},{value:"Introduction to NV12",id:"introduction-to-nv12",level:2},{value:"YUV Format",id:"yuv-format",level:3},{value:"NV12 Layout",id:"nv12-layout",level:3}];function c(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"428-data-layout-and-alignment-rules",children:"4.2.8 Data Layout and Alignment Rules"})}),"\n",(0,a.jsx)(n.h2,{id:"data-layout",children:"Data Layout"}),"\n",(0,a.jsx)(n.p,{children:"To improve computational efficiency, hardware devices adopt special data layout to ensure that the feature maps and kernels used for convolution operations within the same batch are placed adjacent to each other in memory.\nBelow is a brief introduction to the concept of data layout in the D-Robotics Processor."}),"\n",(0,a.jsx)(n.p,{children:"Variables in a neural network model can be represented by a 4-dimensional tensor, where each number is an element of this tensor, and we call it the natural layout.\nBy arranging the elements of different dimensions closely together according to certain rules, we form independent small blocks, and then treat these small blocks as new elements to compose a new 4-dimensional tensor, which we call a tensor with data layout."}),"\n",(0,a.jsx)(n.p,{children:"Different layouts are used for input and output data, and users can obtain layout description information through APIs. Different layouts cannot be directly compared."}),"\n",(0,a.jsxs)(n.admonition,{title:"Note",type:"info",children:[(0,a.jsx)(n.p,{children:"Please note that when performing data layout transformation, if padding is required, it is recommended to set the padding value to zero."}),(0,a.jsx)(n.p,{children:'Here we introduce two types of data layout: "NHWC_NATIVE" and "NCHW_NATIVE". Taking "NHWC_NATIVE" as an example, the data layout is as follows:'})]}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{}),(0,a.jsx)(n.th,{}),(0,a.jsx)(n.th,{})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"N0H0W0C0"}),(0,a.jsx)(n.td,{children:"N0H0W0C1"}),(0,a.jsx)(n.td,{children:"\u2026\u2026"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"N0H0W1C0"}),(0,a.jsx)(n.td,{children:"N0H0W1C1"}),(0,a.jsx)(n.td,{children:"\u2026\u2026"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"\u2026\u2026"}),(0,a.jsx)(n.td,{children:"\u2026\u2026"}),(0,a.jsx)(n.td,{children:"\u2026\u2026"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"N0H1W0C0"}),(0,a.jsx)(n.td,{children:"N0H1W0C1"}),(0,a.jsx)(n.td,{children:"\u2026\u2026"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"\u2026\u2026"}),(0,a.jsx)(n.td,{children:"\u2026\u2026"}),(0,a.jsx)(n.td,{children:"\u2026\u2026"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"N1H0W0C0"}),(0,a.jsx)(n.td,{children:"N1H0W0C1"}),(0,a.jsx)(n.td,{children:"\u2026\u2026"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"\u2026\u2026"}),(0,a.jsx)(n.td,{children:"\u2026\u2026"}),(0,a.jsx)(n.td,{children:"\u2026\u2026"})]})]})]}),"\n",(0,a.jsx)(n.p,{children:"A tensor of size N * H * W * C can be represented by the following 4 nested loops:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-C",children:"    for (int32_t n = 0; n < N; n++) {\n        for (int32_t h = 0; h < H; h++) {\n            for (int32_t w = 0; w < W; w++) {\n                for (int32_t c = 0; c < C; c++) {\n                    int32_t native_offset = n*H*W*C + h*W*C + w*C + c;\n                }\n            }\n        }\n    }\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Compared to ",(0,a.jsx)(n.code,{children:"NCHW_NATIVE"}),", ",(0,a.jsx)(n.code,{children:"NHWC_NATIVE"})," has a different loop order, but it is not listed separately here."]}),"\n",(0,a.jsx)(n.admonition,{type:"caution",children:(0,a.jsx)(n.p,{children:"The term native mentioned in the following content specifically refers to this layout."})}),"\n",(0,a.jsx)(n.h2,{id:"bpu-alignment-restriction-rules",children:"BPU Alignment Restriction Rules"}),"\n",(0,a.jsx)(n.p,{children:"This section describes the alignment restriction rules when using BPU."}),"\n",(0,a.jsx)(n.h3,{id:"model-input-requirements",children:"Model Input Requirements"}),"\n",(0,a.jsx)(n.p,{children:"BPU does not impose any restrictions on the size or parity of the model inputs. It supports inputs of various sizes, such as 416x416 for models like YOLO, and 227x227 for models like SqueezeNet."}),"\n",(0,a.jsx)(n.p,{children:"For NV12 inputs, there is a special requirement that both the width (W) and height (H) must be even, in order to meet the requirement that the UV plane should be half the size of the Y plane."}),"\n",(0,a.jsx)(n.h3,{id:"alignment-and-valid-data",children:"Alignment and Valid Data"}),"\n",(0,a.jsxs)(n.p,{children:["BPU has alignment restrictions on data. The alignment requirements and the actual layout of the data are represented by ",(0,a.jsx)(n.code,{children:"validShape"}),", ",(0,a.jsx)(n.code,{children:"alignedShape"}),", and ",(0,a.jsx)(n.code,{children:"stride"})," in ",(0,a.jsx)(n.code,{children:"hbDNNTensorProperties"}),"."]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"validShape"})," represents the valid shape of the data."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"alignedShape"})," represents the shape that meets the alignment requirements. Due to hardware limitations, ",(0,a.jsx)(n.code,{children:"alignedShape"})," is always represented as four-dimensional data."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"stride"})," represents the strides of each dimension in ",(0,a.jsx)(n.code,{children:"validShape"}),". For models with NV12 inputs, the ",(0,a.jsx)(n.code,{children:"stride"})," value is always 0, because NV12 inputs only require alignment of W by 16."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Currently, the correct layout of four-dimensional model tensors can be obtained using ",(0,a.jsx)(n.code,{children:"validShape"})," and ",(0,a.jsx)(n.code,{children:"alignedShape"}),". If tensors with dimensions larger than four are used in RDK Ultra models, the correct layout can be obtained using ",(0,a.jsx)(n.code,{children:"validShape"})," and ",(0,a.jsx)(n.code,{children:"stride"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"introduction-to-nv12",children:"Introduction to NV12"}),"\n",(0,a.jsx)(n.h3,{id:"yuv-format",children:"YUV Format"}),"\n",(0,a.jsx)(n.p,{children:"YUV format is mainly used for optimizing the transmission of color video signals. YUV consists of three components: Y, which represents brightness or grayscale; U and V, which represent chrominance and are responsible for specifying the color of each pixel."}),"\n",(0,a.jsx)(n.h3,{id:"nv12-layout",children:"NV12 Layout"}),"\n",(0,a.jsx)(n.p,{children:"NV12 image format belongs to YUV color space, specifically YUV420SP format. Four Y components share one set of U and V components, with Y arranged continuously and U and V arranged alternately."}),"\n",(0,a.jsx)(n.p,{children:"The arrangement is as follows:"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/04_Algorithm_Application/02_cdev_dnn_api/image/cdev_dnn_api/nv12_layout.png",alt:"nv12_layout"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);