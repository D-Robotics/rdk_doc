"use strict";(self.webpackChunkrdk_doc=self.webpackChunkrdk_doc||[]).push([[89955],{4727:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>_,frontMatter:()=>r,metadata:()=>d,toc:()=>c});const d=JSON.parse('{"id":"Advanced_development/linux_development/driver_development/driver_watchdog_dev","title":"Watchdog Driver Debugging Guide","description":"Code Path","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/07_Advanced_development/02_linux_development/driver_development/driver_watchdog_dev.md","sourceDirName":"07_Advanced_development/02_linux_development/driver_development","slug":"/Advanced_development/linux_development/driver_development/driver_watchdog_dev","permalink":"/rdk_doc/en/Advanced_development/linux_development/driver_development/driver_watchdog_dev","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1753498781000,"sidebarPosition":14,"frontMatter":{"sidebar_position":14},"sidebar":"tutorialSidebar","previous":{"title":"RTC Debugging Guide","permalink":"/rdk_doc/en/Advanced_development/linux_development/driver_development/driver_rtc_dev"},"next":{"title":"Audio Codec Adaptation Guide","permalink":"/rdk_doc/en/Advanced_development/linux_development/driver_development/driver_codec_dev"}}');var o=t(74848),i=t(28453);const r={sidebar_position:14},s="Watchdog Driver Debugging Guide",a={},c=[{value:"Code Path",id:"code-path",level:2},{value:"DTS Configuration",id:"dts-configuration",level:2},{value:"Kernel Configuration",id:"kernel-configuration",level:2},{value:"Usage Example",id:"usage-example",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",pre:"pre",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"watchdog-driver-debugging-guide",children:"Watchdog Driver Debugging Guide"})}),"\n",(0,o.jsx)(n.h2,{id:"code-path",children:"Code Path"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"drivers/watchdog/hobot_wdt.c # watchdog driver source file\ninclude/linux/watchdog.h # watchdog driver header file\n"})}),"\n",(0,o.jsx)(n.h2,{id:"dts-configuration",children:"DTS Configuration"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'/* arch/arm64/boot/dts/hobot/hobot-xj3.dtsi */\nwatchdog: watchdog@0xA1002000 {\n    compatible = "hobot,hobot-wdt";\n    reg = <0 0xA1002000 0 0x1000>;\n    clocks = <&timer0_mclk>;\n    clock-names = "watchdog_mclk";\n    interrupt-parent = <&gic>;\n    interrupts = <0 15 4>;\n    pet-time = <6>;\n    bark-time = <11>;\n    bite-time = <15>;\n    status = "disabled";\n};\n\n/* arch/arm64/boot/dts/hobot/hobot-x3-sdb.dts */\n&watchdog {\n\tstatus = "okay";\n};\n\n/* arch/arm64/boot/dts/hobot/hobot-xj3-xvb.dtsi */\n&watchdog {\n\tstatus = "okay";\n};\n\n'})}),"\n",(0,o.jsx)(n.h2,{id:"kernel-configuration",children:"Kernel Configuration"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"/* arch/arm64/configs/xj3_debug_defconfig */\nCONFIG_WATCHDOG=y\nCONFIG_WATCHDOG_CORE=y\n# CONFIG_WATCHDOG_NOWAYOUT is not set\nCONFIG_WATCHDOG_HANDLE_BOOT_ENABLED=y\n# CONFIG_WATCHDOG_SYSFS is not set\n#\n# Watchdog Device Drivers\n#\n# CONFIG_SOFT_WATCHDOG is not set\n# CONFIG_GPIO_WATCHDOG is not set\n# CONFIG_XILINX_WATCHDOG is not set\n# CONFIG_ZIIRAVE_WATCHDOG is not set\n# CONFIG_ARM_SP805_WATCHDOG is not set\n# CONFIG_ARM_SBSA_WATCHDOG is not set\n# CONFIG_CADENCE_WATCHDOG is not set\n# CONFIG_DW_WATCHDOG is not set\n# CONFIG_MAX63XX_WATCHDOG is not set\nCONFIG_HOBOT_WATCHDOG=y\n# CONFIG_HOBOT_WATCHDOG_ENABLE is not set /*Enable this option for the system to automatically feed the dog*/\nCONFIG_HOBOT_WATCHDOG_TEST=y\n# CONFIG_MEN_A21_WDT is not set\n\n/* arch/arm64/configs/xj3_debug_defconfig */\nCONFIG_WATCHDOG=y\nCONFIG_WATCHDOG_CORE=y\n# CONFIG_WATCHDOG_NOWAYOUT is not set\nCONFIG_WATCHDOG_HANDLE_BOOT_ENABLED=y\n# CONFIG_WATCHDOG_SYSFS is not set\n\n#\n# Watchdog Device Drivers\n#\n# CONFIG_SOFT_WATCHDOG is not set\n# CONFIG_GPIO_WATCHDOG is not set\n# CONFIG_XILINX_WATCHDOG is not set\n# CONFIG_ZIIRAVE_WATCHDOG is not set\n# CONFIG_ARM_SP805_WATCHDOG is not set\n# CONFIG_ARM_SBSA_WATCHDOG is not set\n# CONFIG_CADENCE_WATCHDOG is not set\n# CONFIG_DW_WATCHDOG is not set\n# CONFIG_MAX63XX_WATCHDOG is not set\nCONFIG_HOBOT_WATCHDOG=y\nCONFIG_HOBOT_WATCHDOG_ENABLE=y/*Enable this option for the system to automatically feed the dog*/\n# CONFIG_HOBOT_WATCHDOG_TEST is not set\n# CONFIG_MEN_A21_WDT is not set\n"})}),"\n",(0,o.jsx)(n.h2,{id:"usage-example",children:"Usage Example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h> //UNIX standard function definitions\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h> // file control definition\n#include <termios.h> // PPSIX terminal control definition\n#include <errno.h> // error number definition\n#include <pthread.h>\n#include <linux/watchdog.h>\n#include <string.h>\n#include <sys/ioctl.h>\n\nint watchdogfd;\nint feeddog = 1;\n\nvoid *feeddogthread()\n{\n    int feeddogvalue;\n    int returnval;\n\n    feeddogvalue = 65535;\n\n    while (feeddog)\n    {\n        // reload the watchdog count register every 10 seconds\n        printf("feed dog\\n");\n        returnval = write(watchdogfd, &feeddogvalue, sizeof(int));\n        sleep(10);\n    }\n}\n\nint main()\n{\n    pthread_t watchdogThd;\n    // int watchdogfd;\n    int returnval;\n    char readline[32], *p;\n\n    // open the watchdog device\n    if ((watchdogfd = open("/dev/watchdog", O_RDWR | O_NONBLOCK)) < 0)\n    {\n        printf("cannot open the watchdog device\\n");\n        exit(0);\n    }\n\n    int timeout = 15;\n    int timeleft;\n    ioctl(watchdogfd, WDIOC_SETTIMEOUT, &timeout);\n    printf("The timeout was set to %d seconds\\n", timeout);\n\n    // create feeddog thread\n    returnval = pthread_create(&watchdogThd, NULL, feeddogthread, NULL);\n    if (returnval < 0)\n        printf("cannot create feeddog thread\\n");\n}while (1) {\n        printf("Command (e quit): ");\n        memset(readline, \'\\0\', sizeof(readline));\n        fgets(readline, sizeof(readline), stdin);\n\n        /* Remove leading spaces */\n        p = readline;\n        while (*p == \' \' || *p == \'\\t\')\n            p++;\n\n        switch (*p) {\n        case \'g\':\n            ioctl(watchdogfd, WDIOC_GETTIMEOUT, &timeout);\n            printf("The timeout was is %d seconds\\n", timeout);\n            break;\n        case \'e\':\n            printf("Close watchdog and exit safely!\\n");\n            int disable_dog = WDIOS_DISABLECARD;\n            ioctl(watchdogfd, WDIOC_SETOPTIONS, &disable_dog);\n            close(watchdogfd);\n            break;\n        case \'s\':\n            printf("stop feed dog\\n");\n            feeddog = 0;\n            break;\n        case \'t\':\n            ioctl(watchdogfd, WDIOC_GETTIMELEFT, &timeleft);\n            printf("The timeout was is %d seconds\\n", timeleft);\n            break;\n        case \'r\':\n            printf("we don\'t close watchdog. The machine will reboot in a few seconds!\\n");\n            printf("wait......\\n");\n            break;\n        default:\n            printf("get error char: %c\\n", *p);\n        }\n\n    }\n\n    return 0;\n}\n'})})]})}function _(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>s});var d=t(96540);const o={},i=d.createContext(o);function r(e){const n=d.useContext(i);return d.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),d.createElement(i.Provider,{value:n},e.children)}}}]);