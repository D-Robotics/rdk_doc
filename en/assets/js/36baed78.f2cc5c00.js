"use strict";(self.webpackChunkrdk_doc=self.webpackChunkrdk_doc||[]).push([[20189],{28453:(e,n,i)=>{i.d(n,{R:()=>d,x:()=>c});var s=i(96540);const t={},a=s.createContext(t);function d(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),s.createElement(a.Provider,{value:n},e.children)}},62165:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>c,default:()=>p,frontMatter:()=>d,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"Advanced_development/linux_development/driver_development_s100/driver_ipc","title":"Introduction to the IPC Module","description":"The IPC (Inter-Processor Communication) module enables communication between multiple cores, supporting both homogeneous and heterogeneous core communication. On the software side, it manages shared memory based on a buffer-ring mechanism; on the hardware side, it implements inter-core interrupts using MailBox. IPCF features multiple channels, supports large data transfers, and is adaptable across various platforms. RPMSG is built upon an open-source protocol framework and supports inter-core communication between Acore and VDSP.","source":"@site/i18n/en/docusaurus-plugin-content-docs-docs_s/current/07_Advanced_development/02_linux_development/04_driver_development_s100/06_driver_ipc.md","sourceDirName":"07_Advanced_development/02_linux_development/04_driver_development_s100","slug":"/Advanced_development/linux_development/driver_development_s100/driver_ipc","permalink":"/rdk_doc/en/rdk_s/Advanced_development/linux_development/driver_development_s100/driver_ipc","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1769771781000,"sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Pinctrl Debugging Guide","permalink":"/rdk_doc/en/rdk_s/Advanced_development/linux_development/driver_development_s100/driver_pinctrl_dev"},"next":{"title":"SPI Debugging Guide","permalink":"/rdk_doc/en/rdk_s/Advanced_development/linux_development/driver_development_s100/driver_spi_dev"}}');var t=i(74848),a=i(28453);const d={sidebar_position:6},c="Introduction to the IPC Module",r={},o=[{value:"IPCF Software-Hardware Component Block Diagram",id:"ipcf-software-hardware-component-block-diagram",level:2},{value:"Typical IPC Usage Scenarios",id:"typical-ipc-usage-scenarios",level:2},{value:"IPC Instance Allocation Scheme",id:"ipc-instance-allocation-scheme",level:2},{value:"Method for Configuring Instances on the Acore Side",id:"method-for-configuring-instances-on-the-acore-side",level:3},{value:"Device Tree Configuration Notes",id:"device-tree-configuration-notes",level:3},{value:"Usage of User-Space IPC Applications and Configuration Files",id:"usage-of-user-space-ipc-applications-and-configuration-files",level:2},{value:"Hardware Data Flow Description",id:"hardware-data-flow-description",level:3},{value:"Sample Code Location and Directory Structure on the Acore Side",id:"sample-code-location-and-directory-structure-on-the-acore-side",level:3},{value:"API Workflow Description",id:"api-workflow-description",level:3},{value:"Channel Configuration",id:"channel-configuration",level:3},{value:"Instance Description",id:"instance-description",level:3},{value:"Error Code Definitions",id:"error-code-definitions",level:3},{value:"C++ Application",id:"c-application",level:3},{value:"RunCmd Application",id:"runcmd-application",level:4},{value:"UART Passthrough",id:"uart-passthrough",level:4},{value:"Python Application",id:"python-application",level:3},{value:"Data Transfer Flow Between Acore and MCU",id:"data-transfer-flow-between-acore-and-mcu",level:2},{value:"MCU Sending Data to Acore",id:"mcu-sending-data-to-acore",level:3},{value:"Acore Sending Data to MCU",id:"acore-sending-data-to-mcu",level:3},{value:"IPCFHAL API Usage Sequence",id:"ipcfhal-api-usage-sequence",level:3},{value:"IPCFHAL Usage Notes",id:"ipcfhal-usage-notes",level:3},{value:"IPCFHAL Debugging Methods",id:"ipcfhal-debugging-methods",level:3},{value:"Debug Logs",id:"debug-logs",level:4},{value:"Error Codes (API Return Values)",id:"error-codes-api-return-values",level:4},{value:"sysfs Debug Nodes (Acore Side)",id:"sysfs-debug-nodes-acore-side",level:2},{value:"Statistic Debug Node",id:"statistic-debug-node",level:3},{value:"[Node Path]",id:"node-path",level:4},{value:"[Node Function]",id:"node-function",level:4},{value:"[Node Usage]",id:"node-usage",level:4},{value:"[Log Output]",id:"log-output",level:4},{value:"tsdump Debug Node",id:"tsdump-debug-node",level:3},{value:"[Node Path]",id:"node-path-1",level:4},{value:"[Node Function]",id:"node-function-1",level:4},{value:"[Node Usage]",id:"node-usage-1",level:4},{value:"[Log Output]",id:"log-output-1",level:4},{value:"wdump Debug Node",id:"wdump-debug-node",level:3},{value:"[Node Path]",id:"node-path-2",level:4},{value:"[Node Function]",id:"node-function-2",level:4},{value:"[Node Usage]",id:"node-usage-2",level:4},{value:"\u3010log\u3011",id:"log",level:4},{value:"rdump debug node",id:"rdump-debug-node",level:3},{value:"\u3010Node Path\u3011",id:"node-path-3",level:4},{value:"\u3010Node Function\u3011",id:"node-function-3",level:4},{value:"\u3010Node Usage\u3011",id:"node-usage-3",level:4},{value:"\u3010log\u3011",id:"log-1",level:4},{value:"dumplen debug node",id:"dumplen-debug-node",level:3},{value:"\u3010Node Function\u3011",id:"node-function-4",level:4},{value:"\u3010Node Usage\u3011",id:"node-usage-4",level:4},{value:"\u3010log\u3011",id:"log-2",level:4}];function l(e){const n={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"introduction-to-the-ipc-module",children:"Introduction to the IPC Module"})}),"\n",(0,t.jsx)(n.p,{children:"The IPC (Inter-Processor Communication) module enables communication between multiple cores, supporting both homogeneous and heterogeneous core communication. On the software side, it manages shared memory based on a buffer-ring mechanism; on the hardware side, it implements inter-core interrupts using MailBox. IPCF features multiple channels, supports large data transfers, and is adaptable across various platforms. RPMSG is built upon an open-source protocol framework and supports inter-core communication between Acore and VDSP."}),"\n",(0,t.jsx)(n.h2,{id:"ipcf-software-hardware-component-block-diagram",children:"IPCF Software-Hardware Component Block Diagram"}),"\n",(0,t.jsx)(n.p,{children:"Inter-core communication between Acore and MCU primarily uses IPCFHAL on the Acore side and IPCF on the MCU side. IPCFHAL is a wrapper layer based on IPCF, designed to facilitate data transfer between user space and kernel space."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/02_linux_development/driver_development_s100/linux-ipc.jpg",alt:"IPCF Software-Hardware Component Block Diagram"})}),"\n",(0,t.jsx)(n.h2,{id:"typical-ipc-usage-scenarios",children:"Typical IPC Usage Scenarios"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/02_linux_development/driver_development_s100/imageipcscen.png",alt:"Typical IPC Usage Scenario Diagram"})}),"\n",(0,t.jsx)(n.p,{children:"Typical IPC application scenarios include OTA modules, diagnostic modules, planning & control, CANHAL, etc."}),"\n",(0,t.jsx)(n.h2,{id:"ipc-instance-allocation-scheme",children:"IPC Instance Allocation Scheme"}),"\n",(0,t.jsx)(n.p,{children:"On the Acore side, IPC instance IDs range from [0\u201334], allocated as follows:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Instances [0\u201314] for Acore\u2013MCU communication,"}),"\n",(0,t.jsx)(n.li,{children:"Instances [22\u201324] for Acore\u2013VDSP communication,"}),"\n",(0,t.jsx)(n.li,{children:"Instances [32\u201334] for Acore\u2013BPU communication,"}),"\n",(0,t.jsx)(n.li,{children:"Remaining instances are reserved for other private purposes."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:['For Acore\u2013MCU communication, instances [0\u20138] can be used. By default, instances [4\u20136] are reserved for customers. If users do not require services like CANHAL or planning & control, they may modify the configuration files accordingly. For details on IPC communication between Acore and MCU in the S100 platform, refer to the "IPC Usage Overview" section in the ',(0,t.jsx)(n.a,{href:"/rdk_doc/en/rdk_s/Advanced_development/mcu_development/S100/mcu_ipc",children:"MCU IPC User Guide"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"method-for-configuring-instances-on-the-acore-side",children:"Method for Configuring Instances on the Acore Side"}),"\n",(0,t.jsx)(n.p,{children:"Instances on the Acore side can be configured via the device tree files, located at:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dts",children:"source/hobot-drivers/kernel-dts/drobot-s100-ipc.dtsi\nsource/hobot-drivers/kernel-dts/include/drobot_s100_ipc.h\n"})}),"\n",(0,t.jsx)(n.p,{children:"Example device tree configuration (for reference only):"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dts",children:'ipcfhal_cfg: ipcfhal_cfg {\n    status = "okay"; # Node status, no modification needed\n    compatible = "hobot,hobot-ipcfhal";  # Node compatibility property, must not be changed\n\n    /****************instance--num_chans--num_bufs--buf_size****************/\n    ipc-ins = <&ipc_instance0\t8\t8\t0x2000>, #(Acore&MCU) for CANHAL\n            <&ipc_instance1\t8\t8\t0x1000>, #(Acore&MCU) for planning & control\n            <&ipc_instance2\t2\t8\t0x800>, #(Acore&MCU) for planning & control\n            <&ipc_instance3\t8\t8\t0x1000>, #(Acore&MCU) for crypto\n            <&ipc_instance4\t8\t8\t0x1000>, #(Acore&MCU) free, configurable by user\n            <&ipc_instance5\t8\t8\t0x1000>, #(Acore&MCU) free, configurable by user\n            <&ipc_instance6\t8\t8\t0x1000>, #(Acore&MCU) free, configurable by user\n            <&ipc_instance7\t8\t8\t0x1000>, #(Acore&MCU) for transparent transmission of peripherals such as UART, SPI, I2C, and running MCU-side cmd applications\n            <&ipc_instance8\t8\t8\t0x1000>, #(Acore&MCU) partially free, configurable by user\n            <&ipc_instance9\t2\t5\t0x400>,  #(Acore&MCU) private instance, internally reserved\n            <&ipc_instance10\t1\t5\t0x200>, #(Acore&MCU) private instance, internally reserved\n            <&ipc_instance22\t8\t8\t0x1000>, #(Acore&VDSP) reserved for VDSP, not yet open to customers\n            <&ipc_instance23\t8\t8\t0x1000>, #(Acore&VDSP) reserved for VDSP, not yet open to customers\n            <&ipc_instance24\t8\t8\t0x1000>; #(Acore&VDSP) reserved for VDSP, not yet open to customers\n};\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"device-tree-configuration-notes",children:"Device Tree Configuration Notes"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"ipcfhal_cfg"})," node in the device tree includes default configurations for several instances:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The first column specifies the instance ID, which must be unique and within the valid range."}),"\n",(0,t.jsx)(n.li,{children:"The second column defines the number of channels allocated to the instance; users may configure this value, with a maximum of 32 channels."}),"\n",(0,t.jsx)(n.li,{children:"The third column indicates the number of buffer buffers per channel; users may configure this value, with a maximum of 1024 buffers, though limited by available control space."}),"\n",(0,t.jsx)(n.li,{children:"The fourth column specifies the buffer size in bytes; users may configure this value. The product of (number of channels \xd7 number of buffers per channel \xd7 buffer size) must be \u2264 0.5 MB (each instance currently pre-allocates 1 MB of data space, which is not expandable)."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"An example device tree node for a single instance is shown below:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dts",children:'#Not used, User can apply for it\nipc_instance3: ipc_instance3 {\n        status = "okay"; # Node status, no modification needed\n        compatible = "hobot,hobot-ipc"; # Node compatibility property, must not be changed\n        mbox-names = "mbox-chan"; # Mailbox name property, must not be changed\n        mboxes = <&mailbox0 3 19 3>; # Mailbox communication direction; only instances 5 and 6 need modification, others remain unchanged\n        instance = <3>; # Instance ID, no modification needed\n        data_local_addr = /bits/ 64 <IPC_INS3_DATA_LOCAL>; # Acore data segment; only instances 5 and 6 need modification\n        data_remote_addr = /bits/ 64 <IPC_INS3_DATA_REMOTE>; # MCU data segment; only instances 5 and 6 need modification\n        data_size = <IPC_SINGLE_DATA_SIZE>; # Data segment size, must not be changed (in bytes)\n        ctrl_local_addr = /bits/ 64 <IPC_INS3_CTRL_LOCAL>; # Acore control segment; only instances 5 and 6 need modification\n        ctrl_remote_addr = /bits/ 64 <IPC_INS3_CTRL_REMOTE>; # MCU control segment; only instances 5 and 6 need modification\n        ctrl_size = <IPC_SINGLE_CTRL_SIZE>; # Control segment size, must not be changed (in bytes)\n};\n\n'})}),"\n",(0,t.jsx)(n.p,{children:"Since instances 5 and 6 are internally used for testing, external customers who wish to use them must configure them manually as shown below (no further changes needed):"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dts",children:'ipc_instance5: ipc_instance5 {\n        status = "okay";\n        compatible = "hobot,hobot-ipc";\n        mbox-names = "mbox-chan";\n        mboxes = <&mailbox0 5 21 5>;\n        instance = <5>;\n        data_local_addr = /bits/ 64 <IPC_INS5_DATA_LOCAL>;\n        data_remote_addr = /bits/ 64 <IPC_INS5_DATA_REMOTE>;\n        data_size = <IPC_SINGLE_DATA_SIZE>;\n        ctrl_local_addr = /bits/ 64 <IPC_INS5_CTRL_LOCAL>;\n        ctrl_remote_addr = /bits/ 64 <IPC_INS5_CTRL_REMOTE>;\n        ctrl_size = <IPC_SINGLE_CTRL_SIZE>;\n};\n\nipc_instance6: ipc_instance6 {\n        status = "okay";\n        compatible = "hobot,hobot-ipc";\n        mbox-names = "mbox-chan";\n        mboxes = <&mailbox0 6 22 6>;\n        instance = <6>;\n        data_local_addr = /bits/ 64 <IPC_INS6_DATA_LOCAL>;\n        data_remote_addr = /bits/ 64 <IPC_INS6_DATA_REMOTE>;\n        data_size = <IPC_SINGLE_DATA_SIZE>;\n        ctrl_local_addr = /bits/ 64 <IPC_INS6_CTRL_LOCAL>;\n        ctrl_remote_addr = /bits/ 64 <IPC_INS6_CTRL_REMOTE>;\n        ctrl_size = <IPC_SINGLE_CTRL_SIZE>;\n};\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Important Notes for Device Tree Configuration:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Instances 3\u20138 have 1 MB of data space pre-allocated by default: 0.5 MB for Acore and 0.5 MB for MCU. Therefore, (number of channels \xd7 number of buffers per channel \xd7 buffer size) must be \u2264 0.5 MB."}),"\n",(0,t.jsx)(n.li,{children:"Instances 3\u20138 have 5 KB of control space pre-allocated: 2.5 KB for Acore and 2.5 KB for MCU, used to store ring buffer control and status information. Thus, ((number of buffers + 2) \xd7 16 \xd7 number of channels + 8) must be \u2264 2.5 KB."}),"\n",(0,t.jsx)(n.li,{children:"Instances 5\u20136 are used internally by D-Robotics for testing; users may adopt the above configuration and modify the device tree nodes accordingly. // TODO: Consider fully opening these to customers."}),"\n",(0,t.jsx)(n.li,{children:"The number of channels per instance must be \u2264 32, and the number of buffers per channel must be \u2264 1024, while also satisfying the two constraints above."}),"\n",(0,t.jsxs)(n.li,{children:["Using different channels within the same instance or using different instances has minimal impact on transmission performance. The main considerations are whether ",(0,t.jsx)(n.code,{children:"buf_size"}),"/",(0,t.jsx)(n.code,{children:"buf_num"})," are appropriate and whether the design facilitates development and maintenance."]}),"\n",(0,t.jsx)(n.li,{children:"Mailbox interrupt allocation at the hardware level is not configurable."}),"\n",(0,t.jsxs)(n.li,{children:["The number of channels, number of buffers, and buffer size must be identical on both Acore and MCU sides. Additionally, the ",(0,t.jsx)(n.code,{children:"local"})," and ",(0,t.jsx)(n.code,{children:"remote"})," addresses for data and control segments must be opposite between the two sides."]}),"\n",(0,t.jsx)(n.li,{children:"The first address of an instance\u2019s control segment stores the initialization status, which can be used to determine whether the instance has been initialized. By default, Acore completes initialization during kernel boot."}),"\n",(0,t.jsx)(n.li,{children:"If users need to allocate custom data and address segments, they must modify the Acore device tree file, Uboot device tree file, and MCU configuration file."}),"\n",(0,t.jsx)(n.li,{children:"Within the same channel, sending (push) and receiving (pop) operations use independent ring buffers and interrupt mechanisms, ensuring that transmit and receive operations are fully independent and do not interfere with each other."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"usage-of-user-space-ipc-applications-and-configuration-files",children:"Usage of User-Space IPC Applications and Configuration Files"}),"\n",(0,t.jsx)(n.p,{children:"The IPC Sample demonstrates bidirectional IPC communication between Acore and MCU, showcasing multi-instance, multi-channel, and multi-threaded usage of IPC."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/02_linux_development/driver_development_s100/sampleframeware.png",alt:"IPC Communication Between Acore and MCU"})}),"\n",(0,t.jsxs)(n.p,{children:["In the Sample software architecture diagram, Acore uses the ",(0,t.jsx)(n.code,{children:"libipcfhal"})," interface for data transmission and reception, with the underlying implementation based on the IPCF driver. MCU directly uses the IPCF interface for communication. Since Acore provides multiple IPC interfaces for clarity, they are referred to as IPCFHAL, RPMSG, and IPCF respectively. MCU, however, has only one IPC interface, so IPCF is uniformly referred to as IPC in MCU-side documentation."]}),"\n",(0,t.jsx)(n.h3,{id:"hardware-data-flow-description",children:"Hardware Data Flow Description"}),"\n",(0,t.jsx)(n.p,{children:"Shared memory data flow and interrupt signal flow in the Sample"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/02_linux_development/driver_development_s100/sampledataflow.png",alt:"Shared Memory Data Flow and Interrupt Signal Flow"})}),"\n",(0,t.jsx)(n.p,{children:"In the Sample, Acore and MCU exchange data via shared memory and notify each other through mailbox interrupts."}),"\n",(0,t.jsx)(n.h3,{id:"sample-code-location-and-directory-structure-on-the-acore-side",children:"Sample Code Location and Directory Structure on the Acore Side"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code Paths:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Sample source code paths\n${SDK}/source/hobot-io-samples/debian/app/ipcbox_sample  # IPC C++ Sample\n${SDK}/source/hobot-io-samples/debian/app/pyhbipchal_sample # IPC Python Sample\n${SDK}/source/hobot-io/debian/app/pyhbipchal # Source code for converting the IPC C++ library into a Python library\n\n\n# Source code is packaged with firmware and can be compiled directly on S100 at the following paths:\n${S100}/app/ipcbox_sample\n${S100}/app/pyhbipchal_sample\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Directory Structure:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"root@ubuntu:/app/ipcbox_sample# tree .\n.\n\u251c\u2500\u2500 ipcbox_runcmd # Sample for running MCU-side cmd commands\n\u2502\xa0\xa0 \u251c\u2500\u2500 Makefile # Sample build framework\n\u2502\xa0\xa0 \u251c\u2500\u2500 ipcbox_runcmd.cpp # Sample source code\n\u2502\xa0\xa0 \u2514\u2500\u2500 ipcfhal_sample_config.json # Sample configuration file\n\u2514\u2500\u2500 ipcbox_uart # IPC UART transparent transmission Sample\n    \u251c\u2500\u2500 Makefile # Sample build framework\n    \u251c\u2500\u2500 ipcbox_uart.cpp # Sample source code\n    \u2514\u2500\u2500 ipcfhal_sample_config.json # Sample configuration file\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"api-workflow-description",children:"API Workflow Description"}),"\n",(0,t.jsxs)(n.p,{children:["API Sample workflow diagram for Acore\u2013MCU communication (IRQ mode)\n",(0,t.jsx)(n.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/02_linux_development/driver_development_s100/sampleirqapi.png",alt:"API Sample Workflow Diagram for Acore\u2013MCU Communication (IRQ Mode)"})]}),"\n",(0,t.jsxs)(n.p,{children:["API Sample workflow diagram for Acore\u2013MCU communication (POLL mode)\n",(0,t.jsx)(n.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/02_linux_development/driver_development_s100/samplepollapi.png",alt:"API Sample Workflow Diagram for Acore\u2013MCU Communication (POLL Mode)"})]}),"\n",(0,t.jsx)(n.h3,{id:"channel-configuration",children:"Channel Configuration"}),"\n",(0,t.jsxs)(n.p,{children:["The number of channels (",(0,t.jsx)(n.code,{children:"config_num"}),") can be increased in the JSON file, along with corresponding channel information. This Sample does not support dynamic channel addition; to add channels, users must modify configuration files on both Acore and MCU sides."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n        "log_level": 0, # Log level (optional)\n        "config_num": 4, # Number of configured channels\n        "config_num_max":256, # Maximum number of configurable channels\n        "config_0": { # Configuration channel\n                "name": "cpu2mcu_ins7ch0", # Channel name\n                "instance": 7, # Instance ID\n                "channel": 0, # Channel ID\n                "pkg_size_max": 4096, # Maximum packet size in bytes; recommended to be \u2264 4096 bytes\n                "fifo_size": 64000, # FIFO buffer size, determined by the number of items to be buffered\n                "fifo_type": 0, # FIFO buffer type; only type 0 is supported\n                "ipcf_dev_path":"/dev/ipcdrv", # Character device driver; only "/dev/ipcdrv" is supported\n                "ipcf_dev_name":"ipcdrv" # Character device driver name; only "ipcdrv" is supported\n        },\n        "config_1": {\n                "name": "cpu2mcu_ins7ch1",\n                "instance": 7,\n                "channel": 1,\n                "pkg_size_max": 4096,\n                "fifo_size": 64000,\n                "fifo_type": 0,\n                "ipcf_dev_path":"/dev/ipcdrv",\n                "ipcf_dev_name":"ipcdrv"\n        },\n        "config_2": {\n                "name": "cpu2mcu_ins8ch0",\n                "instance": 8,\n                "channel": 0,\n                "pkg_size_max": 4096,\n                "fifo_size": 64000,\n                "fifo_type": 0,\n                "ipcf_dev_path":"/dev/ipcdrv",\n                "ipcf_dev_name":"ipcdrv"\n        },\n        "config_3": {\n                "name": "cpu2mcu_ins8ch1",\n                "instance": 8,\n                "channel": 1,\n                "pkg_size_max": 4096,\n                "fifo_size": 64000,\n                "fifo_type": 0,\n                "ipcf_dev_path":"/dev/ipcdrv",\n                "ipcf_dev_name":"ipcdrv"\n        }\n}\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"instance-description",children:"Instance Description"}),"\n",(0,t.jsx)(n.h3,{id:"error-code-definitions",children:"Error Code Definitions"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Error Code Macro"}),(0,t.jsx)(n.th,{children:"Error Code Value"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"IPCF_HAL_E_OK"})}),(0,t.jsx)(n.td,{children:"0"}),(0,t.jsx)(n.td,{children:"Operation succeeded"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"IPCF_HAL_E_NOK"})}),(0,t.jsx)(n.td,{children:"1"}),(0,t.jsx)(n.td,{children:"Operation failed"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"IPCF_HAL_E_CONFIG_FAIL"})}),(0,t.jsx)(n.td,{children:"2"}),(0,t.jsx)(n.td,{children:"Configuration failed"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"IPCF_HAL_E_WRONG_CONFIGURATION"})}),(0,t.jsx)(n.td,{children:"3"}),(0,t.jsx)(n.td,{children:"Invalid configuration"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"IPCF_HAL_E_NULL_POINTER"})}),(0,t.jsx)(n.td,{children:"4"}),(0,t.jsx)(n.td,{children:"Null pointer passed as argument"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"IPCF_HAL_E_PARAM_INVALID"})}),(0,t.jsx)(n.td,{children:"5"}),(0,t.jsx)(n.td,{children:"Invalid parameter"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"IPCF_HAL_E_LENGTH_TOO_SMALL"})}),(0,t.jsx)(n.td,{children:"6"}),(0,t.jsx)(n.td,{children:"Length too small"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"IPCF_HAL_E_INIT_FAILED"})}),(0,t.jsx)(n.td,{children:"7"}),(0,t.jsx)(n.td,{children:"Initialization failed"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"IPCF_HAL_E_UNINIT"})}),(0,t.jsx)(n.td,{children:"8"}),(0,t.jsx)(n.td,{children:"Called before initialization"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"IPCF_HAL_E_BUFFER_OVERFLOW"})}),(0,t.jsx)(n.td,{children:"9"}),(0,t.jsx)(n.td,{children:"Buffer overflow at source or destination address"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"IPCF_HAL_E_ALLOC_FAIL"})}),(0,t.jsx)(n.td,{children:"10"}),(0,t.jsx)(n.td,{children:"Resource allocation failed"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"IPCF_HAL_E_TIMEOUT"})}),(0,t.jsx)(n.td,{children:"11"}),(0,t.jsx)(n.td,{children:"Operation timed out"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"IPCF_HAL_E_REINIT"})}),(0,t.jsx)(n.td,{children:"12"}),(0,t.jsx)(n.td,{children:"Re-initialization attempted"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"IPCF_HAL_E_BUSY"})}),(0,t.jsx)(n.td,{children:"13"}),(0,t.jsx)(n.td,{children:"System busy"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"IPCF_HAL_E_CHANNEL_INVALID"})}),(0,t.jsx)(n.td,{children:"14"}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.strong,{children:"Data write channel status abnormal: kernel-space RingBuffer has reached its capacity limit, causing the write operation to fail. It is recommended to wait 1\u20132 ms and retry the operation."}),(0,t.jsx)("br",{}),(0,t.jsx)(n.strong,{children:"Data read channel status abnormal: kernel-space RingBuffer is empty, causing the read operation to fail. It is recommended to wait 1\u20132 ms and retry the operation."})]})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"c-application",children:"C++ Application"}),"\n",(0,t.jsx)(n.h4,{id:"runcmd-application",children:"RunCmd Application"}),"\n",(0,t.jsx)(n.p,{children:"This sample implements reading the voltage from an ADC channel."}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["After booting into S100, navigate to the application directory: ",(0,t.jsx)(n.code,{children:"/app/ipcbox_sample/ipcbox_runcmd"})]}),"\n",(0,t.jsxs)(n.li,{children:["Compile: ",(0,t.jsx)(n.code,{children:"make"})]}),"\n",(0,t.jsxs)(n.li,{children:["Run: ",(0,t.jsx)(n.code,{children:"./ipcbox_runcmd"})]}),"\n",(0,t.jsxs)(n.li,{children:["If the log message ",(0,t.jsx)(n.code,{children:'Extracted adc data:{"adc_ch":1,"adc_result":2411,"adc_mv":1059}'})," appears, the test passes."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Here, ",(0,t.jsx)(n.code,{children:"adc_ch"})," indicates the corresponding ADC pin, and ",(0,t.jsx)(n.code,{children:"adc_mv"})," represents the measured voltage value."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'root@ubuntu:/app/ipcbox_sample/ipcbox_runcmd# ./ipcbox_runcmd\n[INFO][hb_ipcf_hal.cpp:282] [channel] cpu2mcu_ins7ch0 [ins] 7 [id] 0 init success.\n[INFO][hb_ipcf_hal.cpp:333] [channel] cpu2mcu_ins7ch0 [ins] 7 [id] 0 config success.\n[INFO][hb_ipcf_hal.cpp:282] [channel] cpu2mcu_ins7ch1 [ins] 7 [id] 1 init success.\n[INFO][hb_ipcf_hal.cpp:333] [channel] cpu2mcu_ins7ch1 [ins] 7 [id] 1 config success.\nExtracted adc data:{"adc_ch":1,"adc_result":2411,"adc_mv":1059}\nTxCmdItem(96)\n44 2D 49 50 43 42 4F 58 01 00 00 00 55 07 00 00\n69 70 63 73 65 6E 64 5F 61 64 63 20 31 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n60 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n\nrx_packet(160):D-IPCBOX\n44 2D 49 50 43 42 4F 58 01 00 00 00 4B 10 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nA0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n7B 22 61 64 63 5F 63 68 22 3A 31 2C 22 61 64 63\n5F 72 65 73 75 6C 74 22 3A 32 34 31 31 2C 22 61\n64 63 5F 6D 76 22 3A 31 30 35 39 7D 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 C9 F5 5A 58 13 C3 E8 F0 1C E7 DE FF FF 00 00\nCC 74 22 8A FF FF 00 00 74 47 67 8A FF FF 00 00\nA4 0F 1F D4 AA AA 00 00 06 00 00 00 01 00 00 00\n58 1D E7 DE FF FF 00 00 58 1D E7 DE FF FF 00 00\n01 00 00 00 00 00 00 00 D8 1C 20 D4 AA AA 00 00\n40 C0 69 8A FF FF 00 00 A4 0F 1F D4 AA AA 00 00\n\n[INFO][hb_ipcf_hal.cpp:553] [channel] cpu2mcu_ins7ch0 [ins] 7 [id] 0 deinit success.\n[INFO][hb_ipcf_hal.cpp:553] [channel] cpu2mcu_ins7ch1 [ins] 7 [id] 1 deinit success.\n'})}),"\n",(0,t.jsx)(n.h4,{id:"uart-passthrough",children:"UART Passthrough"}),"\n",(0,t.jsx)(n.p,{children:"This sample implements UART5 passthrough. For testing, short the TX and RX pins of UART5."}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["After booting into S100, navigate to the application directory: ",(0,t.jsx)(n.code,{children:"cd /app/ipcbox_sample/ipcbox_uart"})]}),"\n",(0,t.jsxs)(n.li,{children:["Compile: ",(0,t.jsx)(n.code,{children:"make"})]}),"\n",(0,t.jsxs)(n.li,{children:["Run: ",(0,t.jsx)(n.code,{children:"./ipcbox_uart"})]}),"\n",(0,t.jsxs)(n.li,{children:["If the message ",(0,t.jsx)(n.code,{children:"tx_data and rx_data are identical."})," appears, the test passes. Sample log output is as follows:"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"# ./ipcbox_uart\n[INFO][hb_ipcf_hal.cpp:282] [channel] cpu2mcu_ins7ch4 [ins] 7 [id] 4 init success.\n[INFO][hb_ipcf_hal.cpp:333] [channel] cpu2mcu_ins7ch4 [ins] 7 [id] 4 config success.\ntx_data(64)\n69 70 63 5F 72 75 6E 63 6D 64 5F 73 65 6E 64 20\n37 20 30 20 31 32 33 34 35 36 37 38 39 20 31 30\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n\nrx_data(64)\n69 70 63 5F 72 75 6E 63 6D 64 5F 73 65 6E 64 20\n37 20 30 20 31 32 33 34 35 36 37 38 39 20 31 30\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n\ntx_data and rx_data are identical.\n[INFO][hb_ipcf_hal.cpp:553] [channel] cpu2mcu_ins7ch4 [ins] 7 [id] 4 deinit success.\n"})}),"\n",(0,t.jsx)(n.h3,{id:"python-application",children:"Python Application"}),"\n",(0,t.jsx)(n.p,{children:"S100 provides a Python library for IPC usage. Internally, it uses pybind11 to call C++ interfaces, ensuring consistent function names and macro definitions across both sides."}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Importing packages"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"import pyhbipchal as pyipc\nimport pyhbipchal_utils as ipc_utils\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsx)(n.li,{children:"Source code directory structure"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"root@ubuntu:/app/pyhbipchal_sample# tree\n.\n\u251c\u2500\u2500 ipcfhal_sample_config.json // Configuration file used for IPC initialization\n\u251c\u2500\u2500 pyhbipchal_test.py // Basic Python application test case using the pyhbipchal library\n\u251c\u2500\u2500 pyhbipchal_utils.py // Source code of pyhbipchal_utils, which provides a Pythonic wrapper over pyhbipchal\n\u2514\u2500\u2500 pyhbipchal_utils_test.py // Test cases for pyhbipchal_utils\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"3",children:["\n",(0,t.jsx)(n.li,{children:"Example"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Testing whether the Python library behaves consistently with the C++ interfaces:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"root@ubuntu:/app/pyhbipchal_sample# python pyhbipchal_test.py\nLibrary version: 1.0.0\n====================test error code==================\n\nIPCF_HAL_E_OK (0): General OK\n\nIPCF_HAL_E_NOK (-1): General Not OK\n\nIPCF_HAL_E_CONFIG_FAIL (-2): Config fail\n\nIPCF_HAL_E_WRONG_CONFIGURATION (-3): Wrong configuration\n\nIPCF_HAL_E_NULL_POINTER (-4): A null pointer was passed as an argument\n\nIPCF_HAL_E_PARAM_INVALID (-5): A parameter was invalid\n\nIPCF_HAL_E_LENGTH_TOO_SMALL (-6): Length too small\n\nIPCF_HAL_E_INIT_FAILED (-7): Initialization failed\n\nIPCF_HAL_E_UNINIT (-8): Called before initialization\n\nIPCF_HAL_E_BUFFER_OVERFLOW (-9): Source address or destination address Buffer overflow\n\nIPCF_HAL_E_ALLOC_FAIL (-10): Source alloc fail\n\nIPCF_HAL_E_TIMEOUT (-11): Expired the time out\n\nIPCF_HAL_E_REINIT (-12): Re initilize\n\nIPCF_HAL_E_BUSY (-13): Busy\nIPCF_HAL_E_CHANNEL_INVALID (-14): Channel is invalid\n\n=====================test OK=======================\n\n[INFO][hb_ipcf_hal.cpp:282] [channel] cpu2mcu_ins7ch4 [ins] 7 [id] 4 init success.\n[INFO][hb_ipcf_hal.cpp:333] [channel] cpu2mcu_ins7ch4 [ins] 7 [id] 4 config success.\ntx_data(64)\n69 70 63 5F 72 75 6E 63 6D 64 5F 73 65 6E 64 20\n37 20 30 20 31 32 33 34 35 36 37 38 39 20 31 30\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n\nrx_data(64)\n69 70 63 5F 72 75 6E 63 6D 64 5F 73 65 6E 64 20\n37 20 30 20 31 32 33 34 35 36 37 38 39 20 31 30\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n\ntx_data and rx_data are identical.\n[INFO][hb_ipcf_hal.cpp:553] [channel] cpu2mcu_ins7ch4 [ins] 7 [id] 4 deinit success.\nroot@ubuntu:/app/pyhbipchal_sample#\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"Test whether the IPC communication functionality of the pyhbipchal_utils package works properly."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"root@ubuntu:/app/pyhbipchal_sample# python pyhbipchal_utils_test.py\n[INFO][hb_ipcf_hal.cpp:282] [channel] cpu2mcu_ins7ch4 [ins] 7 [id] 4 init success.\n[INFO][hb_ipcf_hal.cpp:333] [channel] cpu2mcu_ins7ch4 [ins] 7 [id] 4 config success.\nTx: b'ipc_runcmd_send 7 0 123456789 10' | Rx: b'ipc_runcmd_send 7 0 123456789 10'\n[INFO][hb_ipcf_hal.cpp:553] [channel] cpu2mcu_ins7ch4 [ins] 7 [id] 4 deinit success.\n"})}),"\n",(0,t.jsx)(n.h2,{id:"data-transfer-flow-between-acore-and-mcu",children:"Data Transfer Flow Between Acore and MCU"}),"\n",(0,t.jsx)(n.p,{children:"Acore and MCU IPC communication uses MCU MDMA to transfer data between DDR and MCU SRAM. In the process where the MCU sends data to Acore, the MCU first uses MDMA to move data from SRAM to DDR, then sends an interrupt notification. In the process where Acore sends data to the MCU, upon receiving the interrupt notification, the MCU uses MDMA to move data from DDR to SRAM."}),"\n",(0,t.jsx)(n.h3,{id:"mcu-sending-data-to-acore",children:"MCU Sending Data to Acore"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"http://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/02_linux_development/driver_development_s100/imager52a78-en.jpg",alt:"MCU sending data to Acore"})}),"\n",(0,t.jsx)(n.h3,{id:"acore-sending-data-to-mcu",children:"Acore Sending Data to MCU"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"http://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/02_linux_development/driver_development_s100/imagea78r52-en.png",alt:"Acore sending data to MCU"})}),"\n",(0,t.jsx)(n.h3,{id:"ipcfhal-api-usage-sequence",children:"IPCFHAL API Usage Sequence"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/02_linux_development/driver_development_s100/imageipcfhalapi.png",alt:"Acore sending data to MCU"})}),"\n",(0,t.jsx)(n.p,{children:"During Acore\u2013MCU communication, IPCFHAL uses the IPCF interface on the MCU side."}),"\n",(0,t.jsx)(n.h3,{id:"ipcfhal-usage-notes",children:"IPCFHAL Usage Notes"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"IPCFHAL does not support multiple processes on the same channel; if multi-threaded transmission/reception is used, the user must ensure proper sequencing and logic."}),"\n",(0,t.jsx)(n.li,{children:"The MCU-side SRAM FIFO is too small and intended only for internal use. To conserve SRAM, customers may opt to use a DDR-based solution."}),"\n",(0,t.jsx)(n.li,{children:"Interrupt priorities for each instance on the Acore side are not configurable, whereas they are configurable on the MCU side."}),"\n",(0,t.jsx)(n.li,{children:"If the application is sensitive to fluctuations in system scheduling latency, the application\u2019s scheduling policy can be adjusted to SCHED_FIFO."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"ipcfhal-debugging-methods",children:"IPCFHAL Debugging Methods"}),"\n",(0,t.jsx)(n.h4,{id:"debug-logs",children:"Debug Logs"}),"\n",(0,t.jsx)(n.p,{children:"IPCFHAL, along with the underlying IPCF and Mailbox drivers, provides comprehensive log information. If debugging issues arise, check the log output to help identify problems."}),"\n",(0,t.jsx)(n.h4,{id:"error-codes-api-return-values",children:"Error Codes (API Return Values)"}),"\n",(0,t.jsxs)(n.p,{children:["IPCFHAL defines several error codes covering common error types. The function ",(0,t.jsx)(n.code,{children:"hb_ipcfhal_trans_err"})," can be used to convert an error code into a human-readable error description."]}),"\n",(0,t.jsx)(n.h2,{id:"sysfs-debug-nodes-acore-side",children:"sysfs Debug Nodes (Acore Side)"}),"\n",(0,t.jsx)(n.h3,{id:"statistic-debug-node",children:"Statistic Debug Node"}),"\n",(0,t.jsx)(n.p,{children:"Prints communication statistics, including pkg, pkg_len, err_acq, err_shm_tx, and err_cb."}),"\n",(0,t.jsx)(n.h4,{id:"node-path",children:"[Node Path]"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"// ins-X denotes the instance ID; e.g., if insid is 5, the path is ins-5\n/sys/kernel/debug/ipcdrv-ins-5/statistic\n"})}),"\n",(0,t.jsx)(n.h4,{id:"node-function",children:"[Node Function]"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"// Statistics per instance, counting all channels' TX/RX operations\nstruct ipc_statistic_t {\n        uint32_t acq_cnt;/**< tx: acquire buf count*/\n        uint32_t shm_tx_cnt;/**< tx: send count*/\n        uint32_t cb_cnt;/**< rx: callback count*/\n        uint32_t err_acq;/**< tx: error acquire buf count*/\n        uint32_t err_shm_tx;/**< tx: error send count*/\n        uint32_t err_cb;/**< rx: error callback count*/\n\n        uint32_t packages;/**< tx/rx: packages count*/\n        uint64_t datalen;/**< tx/rx: datalen*/\n};\n"})}),"\n",(0,t.jsx)(n.h4,{id:"node-usage",children:"[Node Usage]"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'// Method 1: Direct sysfs node operation\n// After channel initialization but before any TX/RX, enable statistics\necho 0 > /sys/kernel/debug/ipcdrv-ins-5/statistic\n// After completing TX/RX but before deinitialization, retrieve statistics\ncat /sys/kernel/debug/ipcdrv-ins-5/statistic\n\n\n// Method 2: Using open/write/read/close\nfd = open("/sys/kernel/debug/ipcdrv-ins-5/statistic", O_RDWR);\nwrite(fd, buf, 1024);\n// Perform TX/RX operations\nread(fd, buf, 1024);\nclose(fd);\n'})}),"\n",(0,t.jsx)(n.h4,{id:"log-output",children:"[Log Output]"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"DataLink:\n                                pkg              pkg_len    err_acq err_shm_tx     err_cb\n        INS5CH0 TX:              1                   32          0          0          0\n        INS5CH0 RX:              1                   32          0          0          0\n        INS5CH1 TX:              0                    0          0          0          0\n        INS5CH1 RX:              0                    0          0          0          0\n        INS5CH2 TX:              0                    0          0          0          0\n        INS5CH2 RX:              0                    0          0          0          0\n        INS5CH3 TX:              0                    0          0          0          0\n        INS5CH3 RX:              0                    0          0          0          0\n        INS5CH4 TX:              0                    0          0          0          0\n        INS5CH4 RX:              0                    0          0          0          0\n        INS5CH5 TX:              0                    0          0          0          0\n        INS5CH5 RX:              0                    0          0          0          0\n        INS5CH6 TX:              0                    0          0          0          0\n        INS5CH6 RX:              0                    0          0          0          0\n        INS5CH7 TX:              0                    0          0          0          0\n        INS5CH7 RX:              0                    0          0          0          0\n"})}),"\n",(0,t.jsx)(n.h3,{id:"tsdump-debug-node",children:"tsdump Debug Node"}),"\n",(0,t.jsx)(n.p,{children:"Prints timestamps per channel during data transmission and reception."}),"\n",(0,t.jsx)(n.h4,{id:"node-path-1",children:"[Node Path]"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"// ins-X denotes the instance ID; e.g., if insid is 5, the path is ins-5\n/sys/kernel/debug/ipcdrv-ins-5/tsdump\n"})}),"\n",(0,t.jsx)(n.h4,{id:"node-function-1",children:"[Node Function]"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"// Enables timestamp logging per channel during TX/RX\nint32_t tsdump;/**< >=0: enable timestamp logging for specified channel; <0: disable timestamp logging */\n"})}),"\n",(0,t.jsx)(n.h4,{id:"node-usage-1",children:"[Node Usage]"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'// Method 1: Direct sysfs node operation\n// After channel initialization but before TX/RX, enable timestamp logging\necho 0 > /sys/kernel/debug/ipcdrv-ins-5/tsdump\n// Timestamp logs will be printed during TX/RX\n// After TX/RX completes but before deinitialization, retrieve current setting\ncat /sys/kernel/debug/ipcdrv-ins-5/tsdump\n\n\n// Method 2: Using open/write/read/close\nfd = open("/sys/kernel/debug/ipcdrv-ins-5/tsdump", O_RDWR);\nwrite(fd, buf, 1024);\n// TX/RX operations will trigger timestamp logs\nread(fd, buf, 1024);\nclose(fd);\n'})}),"\n",(0,t.jsx)(n.h4,{id:"log-output-1",children:"[Log Output]"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"[ 1173.246630] ipc-shm-hal: dev_print_timestamp()[515]: [5][0] tx wt sta: 1717558158.887241446\n[ 1173.246642] ipc-shm-hal: dev_print_timestamp()[515]: [5][0] tx wt end: 1717558158.887253646\n[ 1173.246717] ipc-shm-hal: dev_print_timestamp()[515]: [5][0] rx cb sta: 1717558158.887327971\n[ 1173.246723] ipc-shm-hal: dev_print_timestamp()[515]: [5][0] rx cb end: 1717558158.887334796\n[ 1173.246725] ipc-shm-hal: dev_print_timestamp()[515]: [5][0] rx rd sta: 1717558158.887336446\n[ 1173.246727] ipc-shm-hal: dev_print_timestamp()[515]: [5][0] rx sm sta: 1717558158.887338496\n[ 1173.246729] ipc-shm-hal: dev_print_timestamp()[515]: [5][0] rx sm end: 1717558158.887340121\n[ 1173.246730] ipc-shm-hal: dev_print_timestamp()[515]: [5][0] rx rd end: 1717558158.887341646\nlibipcfhal-test: TestBody() [2328] info :\ntsdump: 0\n\nlibipcfhal-test: TestBody() [2329] info :\ntsdump: 0\n"})}),"\n",(0,t.jsx)(n.h3,{id:"wdump-debug-node",children:"wdump Debug Node"}),"\n",(0,t.jsx)(n.p,{children:"Prints transmitted data per channel."}),"\n",(0,t.jsx)(n.h4,{id:"node-path-2",children:"[Node Path]"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"// ins-X denotes the instance ID; e.g., if insid is 5, the path is ins-5\n/sys/kernel/debug/ipcdrv-ins-5/wdump\n"})}),"\n",(0,t.jsx)(n.h4,{id:"node-function-2",children:"[Node Function]"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"// Enables data dump for transmitted data per channel\n// Dump length depends on 'dumplen'; if 'dumplen' is not configured, all data is printed by default\nint32_t wdump;/**< =chan_id: enable TX dump for this channel; otherwise, disable TX dump */\n"})}),"\n",(0,t.jsx)(n.h4,{id:"node-usage-2",children:"[Node Usage]"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"// Method 1: Direct sysfs node operation\n// After channel initialization but before sending data, enable dump\necho 0 > /sys/kernel/debug/ipcdrv-ins-5/wdump\n// During data transmission, the transmitted data will be printed  \n// After data transmission/reception ends and the channel has not been de-initialized, get  \ncat /sys/kernel/debug/ipcdrv-ins-5/wdump\n\n\n// Method 2: Use open/write/read/close operations  \nfd = open(/sys/kernel/debug/ipcdrv-ins-5/wdump, O_RDWR);  \nwrite(fd, buf, 1024);  \n// tx/rx, print transmitted data  \nread(fd, buf, 1024);  \nclose(fd);  \n"})}),"\n",(0,t.jsx)(n.h4,{id:"log",children:"\u3010log\u3011"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"[ 1022.271650] ipc-shm-hal: hal_ipc_shm_write()[926]: [5][0] tx size 32  \n[ 1022.271666] ipc-shm-hal: ipcf_dump_data()[519]: dump info: tx data len[32] mul[1] remain[0]  \n[ 1022.271700] ipc-shm-hal: ipcf_dump_data()[522]: 0x0000: 00 01 02 03 04 05 06 07 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  \n[ 1022.273489] ipc-shm-hal: hal_ipc_shm_write()[926]: [6][0] tx size 32  \n[ 1022.273505] ipc-shm-hal: ipcf_dump_data()[519]: dump info: tx data len[32] mul[1] remain[0]  \n[ 1022.273733] ipc-shm-hal: ipcf_dump_data()[522]: 0x0000: 00 01 02 03 04 05 06 07 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  \nlibipcfhal-test: TestBody() [2403] info :  \nwdump: 0  \n\nlibipcfhal-test: TestBody() [2404] info :  \nwdump: 0  \n"})}),"\n",(0,t.jsx)(n.h3,{id:"rdump-debug-node",children:"rdump debug node"}),"\n",(0,t.jsx)(n.p,{children:"Prints received data per channel."}),"\n",(0,t.jsx)(n.h4,{id:"node-path-3",children:"\u3010Node Path\u3011"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"// ins-X represents insid; if insid is 5, it becomes ins-5  \n/sys/kernel/debug/ipcdrv-ins-5/rdump  \n"})}),"\n",(0,t.jsx)(n.h4,{id:"node-function-3",children:"\u3010Node Function\u3011"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"// Enable receive data dumping per channel, printing received data  \n// The printed length depends on dumplen; if dumplen is not configured, all data will be printed by default  \nuint32_t rdump; /**< =chan_id, enables receive dump; otherwise, disables receive dump */  \n"})}),"\n",(0,t.jsx)(n.h4,{id:"node-usage-3",children:"\u3010Node Usage\u3011"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"// Method 1: Directly operate sysfs node  \n// After channel initialization completes but before any data transmission/reception, enable  \necho 0 > /sys/kernel/debug/ipcdrv-ins-5/rdump  \n// During data transmission, received data will be printed  \n// After data transmission/reception ends and the channel has not been de-initialized, get  \ncat /sys/kernel/debug/ipcdrv-ins-5/rdump  \n\n\n// Method 2: Use open/write/read/close operations  \nfd = open(/sys/kernel/debug/ipcdrv-ins-5/rdump, O_RDWR);  \nwrite(fd, buf, DEV_README_BUFSIZE);  \n// tx/rx, print received data  \nread(fd, buf, DEV_README_BUFSIZE);  \nclose(fd);  \n"})}),"\n",(0,t.jsx)(n.h4,{id:"log-1",children:"\u3010log\u3011"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"[  983.730497] ipc-shm-hal: data_callback()[803]: [6][0] callback size 32  \n[  983.730524] ipc-shm-hal: ipcf_dump_data()[519]: dump info: callback rx len[32] mul[1] remain[0]  \n[  983.730540] ipc-shm-hal: ipcf_dump_data()[522]: 0x0000: 00 01 02 03 04 05 06 07 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  \n[  983.731415] ipc-shm-hal: data_callback()[803]: [5][0] callback size 32  \n[  983.731431] ipc-shm-hal: ipcf_dump_data()[519]: dump info: callback rx len[32] mul[1] remain[0]  \n[  983.731443] ipc-shm-hal: ipcf_dump_data()[522]: 0x0000: 00 01 02 03 04 05 06 07 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  \nlibipcfhal-test: TestBody() [2478] info :  \nrdump: 0  \n\nlibipcfhal-test: TestBody() [2479] info :  \nrdump: 0  \n"})}),"\n",(0,t.jsx)(n.h3,{id:"dumplen-debug-node",children:"dumplen debug node"}),"\n",(0,t.jsxs)(n.p,{children:["Configures dump data length per channel.",(0,t.jsx)(n.br,{}),"\n","\u3010Node Path\u3011"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"// ins-X represents insid; if insid is 5, it becomes ins-5  \n/sys/kernel/debug/ipcdrv-ins-5/dumplen  \n"})}),"\n",(0,t.jsx)(n.h4,{id:"node-function-4",children:"\u3010Node Function\u3011"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"// Configures dump data length per channel  \n// Effective only when dumplen > 0 and dumplen < data_len  \n// Prerequisite: wdump or rdump must be enabled  \nuint32_t dumplen; /**< Number of bytes to print when dumping data */  \n"})}),"\n",(0,t.jsx)(n.h4,{id:"node-usage-4",children:"\u3010Node Usage\u3011"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"// Method 1: Directly operate sysfs node  \n// After channel initialization completes but before sending data, enable  \necho 0 > /sys/kernel/debug/ipcdrv-ins-5/dumplen  \n// During data transmission, transmitted data will be printed  \n// After data transmission/reception ends and the channel has not been de-initialized, get  \ncat /sys/kernel/debug/ipcdrv-ins-5/dumplen  \n\n\n// Method 2: Use open/write/read/close operations  \nfd = open(/sys/kernel/debug/ipcdrv-ins-5/dumplen, O_RDWR);  \nwrite(fd, buf, DEV_README_BUFSIZE);  \n// tx/rx, print transmitted data  \nread(fd, buf, DEV_README_BUFSIZE);  \nclose(fd);  \n"})}),"\n",(0,t.jsx)(n.h4,{id:"log-2",children:"\u3010log\u3011"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"[  852.898250] ipc-shm-hal: hal_ipc_shm_write()[926]: [5][0] tx size 32  \n[  852.898283] ipc-shm-hal: ipcf_dump_data()[519]: dump info: tx data len[16] mul[0] remain[16]  \n[  852.898315] ipc-shm-hal: ipcf_dump_data()[539]: 0x0000: 00 01 02 03 04 05 06 07 00 00 00 00 00 00 00 00  \n[  852.898519] ipc-shm-hal: data_callback()[803]: [6][0] callback size 32  \n[  852.898542] ipc-shm-hal: ipcf_dump_data()[519]: dump info: callback rx len[16] mul[0] remain[16]  \n[  852.898571] ipc-shm-hal: ipcf_dump_data()[539]: 0x0000: 00 01 02 03 04 05 06 07 00 00 00 00 00 00 00 00  \n[  853.900076] ipc-shm-hal: hal_ipc_shm_write()[926]: [6][0] tx size 32  \n[  853.900112] ipc-shm-hal: ipcf_dump_data()[519]: dump info: tx data len[16] mul[0] remain[16]  \n[  853.900143] ipc-shm-hal: ipcf_dump_data()[539]: 0x0000: 00 01 02 03 04 05 06 07 00 00 00 00 00 00 00 00  \n[  853.900359] ipc-shm-hal: data_callback()[803]: [5][0] callback size 32  \n[  853.900373] ipc-shm-hal: ipcf_dump_data()[519]: dump info: callback rx len[16] mul[0] remain[16]  \n[  853.900401] ipc-shm-hal: ipcf_dump_data()[539]: 0x0000: 00 01 02 03 04 05 06 07 00 00 00 00 00 00 00 00  \nlibipcfhal-test: TestBody() [2576] info :  \ndumplen: 16  \n\nlibipcfhal-test: TestBody() [2577] info :  \ndumplen: 16  \n\nlibipcfhal-test: TestBody() [2584] info :  \nrdump: 0  \n\nlibipcfhal-test: TestBody() [2585] info :  \nrdump: 0  \n\nlibipcfhal-test: TestBody() [2592] info :  \nwdump: 0  \n\nlibipcfhal-test: TestBody() [2593] info :  \nwdump: 0  \n"})})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}}}]);