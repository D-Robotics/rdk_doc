"use strict";(self.webpackChunkrdk_doc=self.webpackChunkrdk_doc||[]).push([[29735],{15776:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>a,contentTitle:()=>d,default:()=>u,frontMatter:()=>c,metadata:()=>r,toc:()=>_});const r=JSON.parse('{"id":"Advanced_development/linux_development/driver_development/driver_uart_dev","title":"UART\u9a71\u52a8\u8c03\u8bd5\u6307\u5357","description":"X3 \u82af\u7247\u5171\u67094\u8def\u4e32\u53e3\uff1aUART0\u3001UART1\uff0cUART2\uff0cUART3","source":"@site/docs/07_Advanced_development/02_linux_development/driver_development/driver_uart_dev.md","sourceDirName":"07_Advanced_development/02_linux_development/driver_development","slug":"/Advanced_development/linux_development/driver_development/driver_uart_dev","permalink":"/rdk_doc/Advanced_development/linux_development/driver_development/driver_uart_dev","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1760623499000,"sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"\u914d\u7f6euboot\u548ckernel\u9009\u9879\u53c2\u6570","permalink":"/rdk_doc/Advanced_development/linux_development/driver_development/uboot_kernel_config"},"next":{"title":"I2C\u8c03\u8bd5\u6307\u5357","permalink":"/rdk_doc/Advanced_development/linux_development/driver_development/driver_i2c_dev"}}');var i=n(74848),s=n(28453);const c={sidebar_position:2},d="UART\u9a71\u52a8\u8c03\u8bd5\u6307\u5357",a={},_=[{value:"\u9a71\u52a8\u4ee3\u7801",id:"\u9a71\u52a8\u4ee3\u7801",level:2},{value:"\u4ee3\u7801\u8def\u5f84",id:"\u4ee3\u7801\u8def\u5f84",level:3},{value:"\u5185\u6838\u914d\u7f6e",id:"\u5185\u6838\u914d\u7f6e",level:3},{value:"DTS\u8bbe\u5907\u8282\u70b9\u914d\u7f6e",id:"dts\u8bbe\u5907\u8282\u70b9\u914d\u7f6e",level:3},{value:"UART\u6d4b\u8bd5",id:"uart_test",level:2},{value:"\u9644\u5f55\uff08\u6d4b\u8bd5\u4ee3\u7801\uff09",id:"\u9644\u5f55\u6d4b\u8bd5\u4ee3\u7801",level:2}];function o(t){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...t.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"uart\u9a71\u52a8\u8c03\u8bd5\u6307\u5357",children:"UART\u9a71\u52a8\u8c03\u8bd5\u6307\u5357"})}),"\n",(0,i.jsx)(e.p,{children:"X3 \u82af\u7247\u5171\u67094\u8def\u4e32\u53e3\uff1aUART0\u3001UART1\uff0cUART2\uff0cUART3"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"UART0 \u7528\u4f5c\u8c03\u8bd5\u4e32\u53e3\uff0c\u53ea\u6709 UART1 \u652f\u6301\u786c\u4ef6\u6d41\u63a7"}),"\n",(0,i.jsx)(e.li,{children:"\u652f\u6301\u6bd4\u7279\u7387 115.2Kbps\uff0c230.4Kbps\uff0c460.8Kbps\uff0c921.6Kbps\uff0c1.5Mbps\uff0c2Mbps\uff0c4Mbps\u30022M\u4ee5\u4e0a\u901f\u5f55\u9700\u8981\u4f7f\u80fdTOI"}),"\n",(0,i.jsx)(e.li,{children:"\u652f\u6301\u57fa\u4e8e\u4e2d\u65ad\u6216\u57fa\u4e8e DMA \u7684\u6a21\u5f0f"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"\u9a71\u52a8\u4ee3\u7801",children:"\u9a71\u52a8\u4ee3\u7801"}),"\n",(0,i.jsx)(e.h3,{id:"\u4ee3\u7801\u8def\u5f84",children:"\u4ee3\u7801\u8def\u5f84"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"drivers/tty/serial/hobot_serial.c\ndrivers/tty/serial/hobot_serial.h\n"})}),"\n",(0,i.jsx)(e.h3,{id:"\u5185\u6838\u914d\u7f6e",children:"\u5185\u6838\u914d\u7f6e"}),"\n",(0,i.jsx)(e.p,{children:"CONFIG_SERIAL_HOBOT_UART"}),"\n",(0,i.jsx)(e.p,{children:"SERIAL_HOBOT_UART_CONSOLE"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/02_linux_development/driver_development_x5/image-20220324112539182.png",alt:"image-20220324112539182"})}),"\n",(0,i.jsx)(e.h3,{id:"dts\u8bbe\u5907\u8282\u70b9\u914d\u7f6e",children:"DTS\u8bbe\u5907\u8282\u70b9\u914d\u7f6e"}),"\n",(0,i.jsx)(e.p,{children:"\u5728 hobot-xj3.dtsi \u6587\u4ef6\u4e2d\u6709uart0-3\u7684\u901a\u7528\u914d\u7f6e\uff0c\u6b64\u6587\u4ef6\u5185\u914d\u7f6e\u4e00\u822c\u4e0d\u505a\u4fee\u6539\uff0c\u5f53\u9700\u8981\u4f7f\u80fd\u5bf9\u5e94\u7684\u4e32\u53e3\u65f6\uff0c\u53ef\u4ee5\u5230\u5177\u4f53\u7684\u677f\u5b50\u914d\u7f6e\u8bbe\u5907\u6811\u4e2d\u4fee\u6539\u3001\u6dfb\u52a0\u81ea\u5b9a\u4e49\u914d\u7f6e\uff0c\u4f8b\u5982\u5728 hobot-x3-sdb.dts \u6587\u4ef6\u5185\u4f7f\u80fd uart0\u30011\u30013"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:'/* arch/arm64/boot/dts/hobot/hobot-xj3.dtsi */\nuart0: serial@0xA5000000 {\n    compatible = "hobot,hobot-uart";\n    reg = <0 0xA5000000 0 0x1000>;\n    interrupt-parent = <&gic>;\n    interrupts = <0 29 4>;\n    clocks = <&uart0_mclk>;\n    pinctrl-names = "default";\n    pinctrl-0 = <&uart0_func>;\n    status = "disabled";\n};\n'})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:'/* arch/arm64/boot/dts/hobot/hobot-x3-sdb.dts */\n&uart0 {\n\tstatus = "okay";\n};\n\n&uart1 {\n\tstatus = "okay"; /* 4 wire uart for bt */\n\tpinctrl-0 = <&uart1_func_rtscts>; /* <&uart1_func>;  uart 1 connect to bt with rtscts*/\n};\n\n&uart3 {\n\tstatus = "okay"; /* 4 wire uart for bt */\n};\n'})}),"\n",(0,i.jsx)(e.h2,{id:"uart_test",children:"UART\u6d4b\u8bd5"}),"\n",(0,i.jsx)(e.p,{children:"\u786c\u4ef6\u4e0a\u628auart3\u7684TX\u548cRX\u8fdb\u884c\u8fde\u63a5\u3002"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/02_linux_development/driver_development/image-20220324122032808.png",alt:"image-20220324122032808"})}),"\n",(0,i.jsx)(e.p,{children:"\u7f16\u8bd1uart_duplex.c \u4ee3\u7801\uff0c\u5177\u4f53\u4ee3\u7801\u5982\u9644\u5f55A"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"/opt/gcc-ubuntu-9.3.0-2020.03-x86_64-aarch64-linux-gnu/bin/aarch64-linux-gnu-gcc -o uart_duplex uart_duplex.c  -lpthread\n"})}),"\n",(0,i.jsx)(e.p,{children:"\u56de\u73af\u6d4b\u8bd5\u547d\u4ee4\uff1a\u6253\u5f00/dev/ttyS3\uff0c\u9ed8\u8ba4\u6ce2\u7279\u73874Mbps\uff0c\u9ed8\u8ba4\u6bcf\u8f6e\u6d4b\u8bd51MB\u6570\u636e\uff0c\u6d4b\u8bd5100\u8f6e\uff0c\u8bfb\u5199\u540c\u65f6\u8fdb\u884c\uff0c\u6bcf\u53d1\u3001\u6536512\u5b57\u8282\u505a\u4e00\u8f6e\u6570\u636e\u6821\u9a8c\uff0c\u5b8c\u6574\u4e00\u8f6e\u6d4b\u8bd5\u7ed3\u675f\u540e\uff0c\u5982\u679c\u6ca1\u6709\u51fa\u9519\u5219\u6253\u5370\u6821\u9a8c\u6b63\u786e\u3002"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"# ./uart_duplex -c 100 -d /dev/ttyS3\ntest size:1024 Kbytes, baud:4000000\nStart receive thread\nStart send thread\nStart recv_check thread\nThis is receive test 1 times\nThis is uart send 1 times\nreceive sum:102416 bytes\nreceive sum:205312 bytes\n...\nreceive sum:924164 bytes\nreceive sum:1027076 bytes\nsend 1024Kbytes,time:2700.000000ms, BPS:379259.250000\nThis is receive test 2 times\n## Check the received data is correct ##\n"})}),"\n",(0,i.jsx)(e.p,{children:"uart_duplex\u547d\u4ee4\u662f\u6d4b\u8bd5uart\u7684\uff0c\u53ef\u4ee5\u9605\u8bfb\u5b83\u7684\u5e2e\u52a9\u4fe1\u606f\u83b7\u53d6\u66f4\u591a\u4f7f\u7528\u65b9\u6cd5\u3002"}),"\n",(0,i.jsx)(e.h2,{id:"\u9644\u5f55\u6d4b\u8bd5\u4ee3\u7801",children:"\u9644\u5f55\uff08\u6d4b\u8bd5\u4ee3\u7801\uff09"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:'#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <termios.h>\n#include <errno.h>\n#include <string.h>\n#include <getopt.h>\n#include <sys/time.h>\n#include <pthread.h>\n#include <semaphore.h>\n#include <stdlib.h>\n\n#define BUFF_SIZE (20 * 1024 * 1024)\npthread_t recv_thread_id;\npthread_t recv_check_thread_id;\npthread_t send_thread_id;\nchar send_buffer[BUFF_SIZE] = {0};\nchar recv_buffer[BUFF_SIZE] = {0};\nstatic uint32_t test_size = 1024;\nstatic uint32_t baud = 4000000;\nstatic uint32_t test_count = 0;\nint g_fd;\nuint64_t recv_total = 0;\nsem_t sem_check;\n\n#define FRAME_LEN 512\n#if 1\nstatic void dump_recv_data(uint32_t sum, uint32_t len)\n{\n\tint ii = 0;\n\tprintf("dump receive data:\\n");\n\tfor (ii = 0; ii < len; ii += 4) {\n\t\tprintf("0x%x: 0x%x, 0x%x, 0x%x, 0x%x\\n", sum + ii,\n\t\t\t\trecv_buffer[sum + ii],\n\t\t\t\trecv_buffer[sum + ii + 1],\n\t\t\t\trecv_buffer[sum + ii + 2],\n\t\t\t\trecv_buffer[sum + ii + 3]);\n\n\t}\n\n}\n\nstatic void dump_send_data(uint32_t sum, uint32_t len)\n{\n\tint ii = 0;\n\tprintf("dump send data:\\n");\n\tfor (ii = 0; ii < len; ii += 4) {\n\t\tprintf("0x%x: 0x%x, 0x%x, 0x%x, 0x%x\\n", sum + ii,\n\t\t\t\tsend_buffer[sum + ii],\n\t\t\t\tsend_buffer[sum + ii + 1],\n\t\t\t\tsend_buffer[sum + ii + 2],\n\t\t\t\tsend_buffer[sum + ii + 3]);\n\n\t}\n\n}\n#endif\n\nstatic void set_baudrate(int fd, int nSpeed)\n{\n\tstruct termios newtio;\n\n\ttcgetattr(fd, &newtio);\n\n\tswitch (nSpeed) {\n\tcase 2400:\n\t\tcfsetispeed(&newtio, B2400);\n\t\tcfsetospeed(&newtio, B2400);\n\t\tbreak;\n\n\tcase 4800:\n\t\tcfsetispeed(&newtio, B4800);\n\t\tcfsetospeed(&newtio, B4800);\n\t\tbreak;\n\n\tcase 9600:\n\t\tcfsetispeed(&newtio, B9600);\n\t\tcfsetospeed(&newtio, B9600);\n\t\tbreak;\n\n\tcase 19200:\n\t\tcfsetispeed(&newtio, B19200);\n\t\tcfsetospeed(&newtio, B19200);\n\t\tbreak;\n\n\tcase 38400:\n\t\tcfsetispeed(&newtio, B38400);\n\t\tcfsetospeed(&newtio, B38400);\n\t\tbreak;\n\n\tcase 57600:\n\t\tcfsetispeed(&newtio, B57600);\n\t\tcfsetospeed(&newtio, B57600);\n\t\tbreak;\n\n\tcase 115200:\n\t\tcfsetispeed(&newtio, B115200);\n\t\tcfsetospeed(&newtio, B115200);\n\t\tbreak;\n\tcase 230400:\n\t\tcfsetispeed(&newtio, B230400);\n\t\tcfsetospeed(&newtio, B230400);\n\t\tbreak;\n\tcase 921600:\n\t\tcfsetispeed(&newtio, B921600);\n\t\tcfsetospeed(&newtio, B921600);\n\t\tbreak;\n\tcase 1000000:\n\t\tcfsetispeed(&newtio, B1000000);\n\t\tcfsetospeed(&newtio, B1000000);\n\t\tbreak;\n\n\tcase 1152000:\n\t\tcfsetispeed(&newtio, B1152000);\n\t\tcfsetospeed(&newtio, B1152000);\n\t\tbreak;\n\tcase 1500000:\n\t\tcfsetispeed(&newtio, B1500000);\n\t\tcfsetospeed(&newtio, B1500000);\n\t\tbreak;\n\tcase 2000000:\n\t\tcfsetispeed(&newtio, B2000000);\n\t\tcfsetospeed(&newtio, B2000000);\n\t\tbreak;\n\tcase 2500000:\n\t\tcfsetispeed(&newtio, B2500000);\n\t\tcfsetospeed(&newtio, B2500000);\n\t\tbreak;\n\tcase 3000000:\n\t\tcfsetispeed(&newtio, B3000000);\n\t\tcfsetospeed(&newtio, B3000000);\n\t\tbreak;\n\tcase 3500000:\n\t\tcfsetispeed(&newtio, B3500000);\n\t\tcfsetospeed(&newtio, B3500000);\n\t\tbreak;\n\n\tcase 4000000:\n\t\tcfsetispeed(&newtio, B4000000);\n\t\tcfsetospeed(&newtio, B4000000);\n\t\tbreak;\n\n\tdefault:\n\t\tprintf("\\tSorry, Unsupported baud rate, use previous baudrate!\\n\\n");\n\t\tbreak;\n\t}\n\ttcsetattr(fd,TCSANOW,&newtio);\n}\n\nstatic void set_termios(int fd)\n{\n\tstruct termios term;\n\n\ttcgetattr(fd, &term);\n\tterm.c_cflag &= ~(CSIZE | CSTOPB | PARENB | INPCK);\n\tterm.c_cflag |= (CS8 | CLOCAL | CREAD);\n\tterm.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG);\n\tterm.c_oflag &= ~(OPOST | ONLCR | OCRNL);\n\tterm.c_iflag &= ~(ICRNL |INLCR | IXON | IXOFF | IXANY);\n\tterm.c_cc[VTIME] = 0;\n\tterm.c_cc[VMIN] = 1;\n\ttcsetattr(fd, TCSAFLUSH, &term);\n}\n\nstatic void *send_test(void *times)\n{\n\t/*send thread*/\n\tstruct timeval start, end;\n\tint32_t i = 0;\n\tuint32_t j = 0;\n\tuint32_t tmp = 0;\n\tuint32_t exe_count = 0;\n\tint32_t ret = 0;\n\tfloat ts = 0;\n\n\tprintf("Start send thread\\n");\n\n\tsleep(1);\n\tif (test_count == 0) {\n\t\ttmp = 10;\n\t} else\n\t\ttmp = test_count;\n\tfor (j = 0; j < tmp; j++) {\n\t\tif (test_count == 0)\n\t\t\tj = 0;\n\t\tsleep(1);\n\t\tprintf("This is uart send %d times\\n", ++exe_count);\n\t\tgettimeofday(&start, NULL);\n\t\tfor (i = 0; i <  test_size * 1024; i = i + FRAME_LEN) {\n\t\t\tret = write(g_fd, &send_buffer[i], FRAME_LEN);\n\t\t\tif (ret < FRAME_LEN) {\n\t\t\t\tprintf("write ttyS2 error\\n");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n#if 1\n\t\tgettimeofday(&end, NULL);\n\t\t//\t\tprintf("start %ld sec, %ld usec, end %ld sec, %ld usec\\n", start.tv_sec, start.tv_usec, end.tv_sec, end.tv_usec);\n\t\tts = ((end.tv_sec * 1000000 + end.tv_usec) - (start.tv_sec * 1000000 + start.tv_usec)) / 1000;\n\t\tprintf("send %dKbytes,time:%fms, BPS:%f\\n", test_size, ts, test_size * 1000 / (ts / 1000));\n#endif\n\t}\n\tclose(g_fd);\n\treturn NULL;\n}\n\nstatic void *recv_test(void *times)\n{\n\tint32_t j = 0;\n\tuint32_t exe_count = 0;\n\tint tmp = 0;\n\tint size = 0;\n\tint sum = 0;\n\tint last_count = 0;\n\tint len = 0;\n\tint len_frame = 0; /*use to get correct frame len*/\n\n\tprintf("Start receive thread\\n");\n\n\tmemset(recv_buffer, 0, sizeof(recv_buffer));\n\n\tif (test_count == 0) {\n\t\ttmp = 10;\n\t} else\n\t\ttmp = test_count;\n\tfor (j = 0; j < tmp; j++) {\n\t\tsum = 0;\n\t\tlast_count = 0;\n\t\tif (test_count == 0)\n\t\t\tj = 0;\n\t\tprintf("This is receive test %d times\\n", ++exe_count);\n\t\t//gettimeofday(&start, NULL);\n\t\tsize = test_size * 1024;\n\t\twhile (size > 0) {\n\t\t\tlen = read(g_fd, &recv_buffer[sum], FRAME_LEN);\n\t\t\tif (len < 0) {\n\t\t\t\tprintf("read error\\n");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\trecv_total += len;\n\t\t\tlen_frame += len;\n\t\t\tif (len_frame >= FRAME_LEN) {\n\t\t\t\tlen_frame -= FRAME_LEN;\n\t\t\t\tsem_post(&sem_check);\n\t\t\t}\n\n#if 0\n\t\t\tret = memcmp(&recv_buffer[sum], &send_buffer[sum], len);\n\t\t\tif (ret != 0) {\n\t\t\t\tprintf("data compare error\\n");\n\t\t\t\treturn NULL;\n\t\t\t}\n#endif\n\t\t\tsum +=len;\n\t\t\tsize -= len;\n\t\t\tif ((sum - last_count) > 100 * 1024) {\n\t\t\t\tprintf("receive sum:%d bytes\\n", sum);\n\t\t\t\tlast_count = sum;\n\t\t\t}\n\t\t}\n#if 0\n\t\tgettimeofday(&end, NULL);\n\t\tprintf("start %ld sec, %ld usec, end %ld sec, %ld usec\\n", start.tv_sec, start.tv_usec, end.tv_sec, end.tv_usec);\n\t\tts = ((end.tv_sec * 1000000 + end.tv_usec) - (start.tv_sec * 1000000 + start.tv_usec)) / 1000;\n\n\t\tprintf("receive %dKbytes,time:%fms, BPS:%f\\n", test_size, ts, test_size * 1000 / (ts / 1000));\n#endif\n\t}\n\tclose(g_fd);\n\treturn NULL;\n}\n\nint32_t error_bit(uint64_t *data1, uint64_t *data2, int32_t len)\n{\n\tuint64_t c=0;\n\tint32_t sum = 0;\n\tint i = 0;\n\tfor(i = 0; i < len / 8; i++) {\n\t\tc = data1[i] ^ data2[i];\n\t\twhile(c!=0) {\n\t\t\tc &= (c - 1);\n\t\t\tsum++;\n\t\t}\n\t}\n\treturn sum;\n}\n\nstatic void *recv_check_test(void *times)\n{\n\tint32_t check_pos = 0;\n\tuint32_t *cur_frame = NULL;\n\tint32_t error_bit_cnt = 0;\n\tprintf("Start recv_check thread\\n");\n\twhile (1) {\n\t\tsem_wait(&sem_check);\n\t\t/*check data*/\n\t\tcur_frame = (uint32_t *)&recv_buffer[check_pos];\n\t\tif (*cur_frame != check_pos / FRAME_LEN) {\n\t\t\tprintf("error: may lost frame, curruent frame is %d, expected frame is %d position: 0x%x\\n",\n\t\t\t\t\t*cur_frame, check_pos / FRAME_LEN, check_pos);\n\t\t\t//dump_recv_data(check_pos, FRAME_LEN);\n\t\t\t//dump_send_data(check_pos, FRAME_LEN);\n\t\t\terror_bit_cnt = 0;\n\t\t\terror_bit_cnt = error_bit((uint64_t *)&recv_buffer[check_pos],\n\t\t\t\t\t(uint64_t *)&send_buffer[check_pos],\n\t\t\t\t\tFRAME_LEN / 8);\n\t\t\tcheck_pos += FRAME_LEN;\n\t\t\tprintf("test total data: 0x%lx, error bit count:%d\\n", recv_total, error_bit_cnt);\n\t\t\tif (check_pos == test_size * 1024) {\n\t\t\t\t//exit(1);\n\t\t\t\tprintf("uart: frame head error\\n");\n\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\terror_bit_cnt = 0;\n\t\terror_bit_cnt = error_bit((uint64_t *)&recv_buffer[check_pos],\n\t\t\t\t(uint64_t *)&send_buffer[check_pos],\n\t\t\t\tFRAME_LEN / 8);\n\t\tif (error_bit_cnt) {\n\t\t\tprintf("test total data: 0x%lx!!!!!!!, error bit count:%d\\n", recv_total, error_bit_cnt);\n\t\t\t//dump_recv_data(check_pos, FRAME_LEN);\n\t\t\t//dump_send_data(check_pos, FRAME_LEN);\n\t\t\tcheck_pos += FRAME_LEN;\n\t\t\tif (check_pos == test_size * 1024) {\n\t\t\t\t//exit(1);\n\t\t\t\tprintf("uart: frame data error\\n");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tmemset(&recv_buffer[check_pos], 0, FRAME_LEN);\n\t\tcheck_pos += FRAME_LEN;\n\t\tif (check_pos == test_size * 1024) {\n\t\t\tcheck_pos = 0;\n\t\t\tprintf("## Check the received data is correct ##\\n");\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic const char short_options[] = "s:u:c:b:d:h";\nstatic const struct option long_options[] = {\n\t{"size", required_argument, NULL, \'s\'},\n\t{"baudrate", required_argument, NULL, \'b\'},\n\t{"count", required_argument, NULL, \'c\'},\n\t{"device", required_argument, NULL, \'d\'},\n\t{"help", no_argument, NULL, \'h\'},\n\t{0, 0, 0, 0}};\nint main(int argc, char *argv[])\n{\n\tint ret = 0;\n\tchar *pDevice = NULL;\n\tint i = 0;\n\tint32_t cmd_parser_ret = 0;\n\tuint32_t *frame_num = NULL;\n\tuint32_t *frame_value = NULL;\n\n\twhile ((cmd_parser_ret = getopt_long(argc, argv, short_options, long_options, NULL)) != -1) {\n\t\tswitch (cmd_parser_ret) {\n\t\tcase \'s\':\n\t\t\ttest_size = atoi(optarg);\n\t\t\tbreak;\n\n\t\tcase \'b\':\n\t\t\tbaud = atoi(optarg);\n\t\t\tbreak;\n\n\t\tcase \'c\':\n\t\t\ttest_count = atoi(optarg);\n\t\t\tbreak;\n\t\tcase \'d\':\n\t\t\tpDevice = optarg;\n\t\t\tbreak;\n\n\t\tcase \'h\':\n\t\t\tprintf("**********UART STRESS TEST HELP INFORMATION*********\\n");\n\t\t\tprintf(">>> -s/--size     [test size,unit--Kbytes,default is 1M, MAX is 20M]\\n");\n\t\t\tprintf(">>> -b/--baudrate  [baud,default is 4M]\\n");\n\t\t\tprintf(">>> -c/--count  [test count,default is forever]\\n");\n\t\t\tprintf(">>> -d/--uart  [uart device, user must set this]\\n");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (baud > 4000000) {\n\t\tprintf("baud is larger than max baud\\n");\n\t\treturn -1;\n\t}\n\tg_fd = open(pDevice, O_RDWR | O_NOCTTY);\n\tif (0 > g_fd) {\n\t\tprintf("open fail\\n");\n\t\treturn -1;\n\t}\n\tset_baudrate(g_fd, baud);\n\tset_termios(g_fd);\n\tprintf("test size:%d Kbytes, baud:%d\\n", test_size, baud);\n\tfor (i = 0; i < test_size * 1024; i+=4) {\n\t\tif (i % FRAME_LEN) {\n\t\t\tframe_value = (uint32_t *)&send_buffer[i];\n\t\t\t*frame_value = rand();\n\t\t}\n\n\t}\n\tfor (i = 0; i < test_size * 1024 / FRAME_LEN; i++) {\n\t\tframe_num = (uint32_t *)&send_buffer[i * FRAME_LEN];\n\t\t*frame_num = i;\n\t\t//        printf("pos:0x%x, value:0x%x\\n", i * FRAME_LEN, *frame_num);\n\t}\n\n\tsem_init(&sem_check, 0, 0);\n\tret = pthread_create(&recv_thread_id,\n\t\t\tNULL,\n\t\t\trecv_test,\n\t\t\tNULL);\n\tif (ret < 0) {\n\t\tprintf("create uart1 test thread failed\\n");\n\t\treturn -1;\n\t}\n\tret = pthread_create(&send_thread_id,\n\t\t\tNULL,\n\t\t\tsend_test,\n\t\t\tNULL);\n\tif (ret < 0) {\n\t\tprintf("create uart2 test thread failed\\n");\n\t\treturn -1;\n\t}\n\tret = pthread_create(&recv_check_thread_id,\n\t\t\tNULL,\n\t\t\trecv_check_test,\n\t\t\tNULL);\n\tif (ret < 0) {\n\t\tprintf("create receive check thread failed\\n");\n\t\treturn -1;\n\t}\n\tpthread_join(recv_thread_id, NULL);\n\tpthread_join(recv_check_thread_id, NULL);\n\tpthread_join(send_thread_id, NULL);\n\treturn 0;\n}\n'})})]})}function u(t={}){const{wrapper:e}={...(0,s.R)(),...t.components};return e?(0,i.jsx)(e,{...t,children:(0,i.jsx)(o,{...t})}):o(t)}},28453:(t,e,n)=>{n.d(e,{R:()=>c,x:()=>d});var r=n(96540);const i={},s=r.createContext(i);function c(t){const e=r.useContext(s);return r.useMemo(function(){return"function"==typeof t?t(e):{...e,...t}},[e,t])}function d(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(i):t.components||i:c(t.components),r.createElement(s.Provider,{value:e},t.children)}}}]);