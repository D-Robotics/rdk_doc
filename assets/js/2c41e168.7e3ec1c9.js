"use strict";(self.webpackChunkrdk_doc=self.webpackChunkrdk_doc||[]).push([[53131],{28453:(n,e,t)=>{t.d(e,{R:()=>a,x:()=>d});var s=t(96540);const i={},r=s.createContext(i);function a(n){const e=s.useContext(r);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function d(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:a(n.components),s.createElement(r.Provider,{value:e},n.children)}},55139:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>d,default:()=>_,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"Advanced_development/linux_development/driver_development/driver_spi_dev","title":"SPI\u8c03\u8bd5\u6307\u5357","description":"\u9a71\u52a8\u4ee3\u7801","source":"@site/docs/07_Advanced_development/02_linux_development/driver_development/driver_spi_dev.md","sourceDirName":"07_Advanced_development/02_linux_development/driver_development","slug":"/Advanced_development/linux_development/driver_development/driver_spi_dev","permalink":"/rdk_doc/Advanced_development/linux_development/driver_development/driver_spi_dev","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1756547828000,"sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"tutorialSidebar","previous":{"title":"IO-DOMAIN\u8c03\u8bd5\u6307\u5357","permalink":"/rdk_doc/Advanced_development/linux_development/driver_development/driver_io_domain_dev"},"next":{"title":"PWM \u9a71\u52a8\u8c03\u8bd5\u6307\u5357","permalink":"/rdk_doc/Advanced_development/linux_development/driver_development/driver_pwm_dev"}}');var i=t(74848),r=t(28453);const a={sidebar_position:7},d="SPI\u8c03\u8bd5\u6307\u5357",l={},c=[{value:"\u9a71\u52a8\u4ee3\u7801",id:"\u9a71\u52a8\u4ee3\u7801",level:2},{value:"\u4ee3\u7801\u8def\u5f84",id:"\u4ee3\u7801\u8def\u5f84",level:3},{value:"\u5185\u6838\u914d\u7f6e",id:"\u5185\u6838\u914d\u7f6e",level:3},{value:"DTS\u8bbe\u5907\u8282\u70b9\u914d\u7f6e",id:"dts\u8bbe\u5907\u8282\u70b9\u914d\u7f6e",level:3},{value:"SPI\u9a71\u52a8",id:"spi\u9a71\u52a8",level:2},{value:"SPI master/slave\u914d\u7f6e",id:"spi-masterslave\u914d\u7f6e",level:3},{value:"SPI\u6ce8\u518c",id:"spi\u6ce8\u518c",level:3},{value:"\u786c\u4ef6\u521d\u59cb\u5316",id:"\u786c\u4ef6\u521d\u59cb\u5316",level:3},{value:"\u8c03\u8bd5\u53c2\u6570",id:"\u8c03\u8bd5\u53c2\u6570",level:3},{value:"SPI\u6d4b\u8bd5",id:"spi\u6d4b\u8bd5",level:2},{value:"\u786c\u4ef6\u56de\u73af\u6d4b\u8bd5",id:"\u786c\u4ef6\u56de\u73af\u6d4b\u8bd5",level:3},{value:"\u6d4b\u8bd5\u4ee3\u7801",id:"\u6d4b\u8bd5\u4ee3\u7801",level:3},{value:"\u9644\u5f55",id:"\u9644\u5f55",level:2},{value:"spidev_tc.c\u6d4b\u8bd5\u4ee3\u7801",id:"spidev_tcc\u6d4b\u8bd5\u4ee3\u7801",level:3},{value:"SPI\u65f6\u5e8f",id:"spi\u65f6\u5e8f",level:3}];function o(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"spi\u8c03\u8bd5\u6307\u5357",children:"SPI\u8c03\u8bd5\u6307\u5357"})}),"\n",(0,i.jsx)(e.h2,{id:"\u9a71\u52a8\u4ee3\u7801",children:"\u9a71\u52a8\u4ee3\u7801"}),"\n",(0,i.jsx)(e.h3,{id:"\u4ee3\u7801\u8def\u5f84",children:"\u4ee3\u7801\u8def\u5f84"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"drivers/spi/spidev.c # \u751f\u6210\u5b57\u7b26\u8bbe\u5907\u8282\u70b9\uff0c\u53ef\u4f9b\u7528\u6237\u7a7a\u95f4\u64cd\u4f5c\ndrivers/spi/spi.c # spi\u6846\u67b6\u5c42\u4ee3\u7801\ndrivers/spi/spi-hobot.c # spi\u9a71\u52a8\u5c42\u4ee3\u7801\n"})}),"\n",(0,i.jsx)(e.h3,{id:"\u5185\u6838\u914d\u7f6e",children:"\u5185\u6838\u914d\u7f6e"}),"\n",(0,i.jsx)(e.p,{children:"CONFIG_SPI_SPIDEV=y # spidev.c\u914d\u7f6e\u9009\u9879"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/02_linux_development/driver_development/image-20220322212001661.png",alt:"image-20220322212001661"})}),"\n",(0,i.jsx)(e.p,{children:"CONFIG_SPI_SLAVE=y # CONFIG_SPI_SPIDEV\u4f9d\u8d56\u7684\u914d\u7f6e\u9009\u9879"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/02_linux_development/driver_development/image-20220322212021521.png",alt:"image-20220322212021521"})}),"\n",(0,i.jsx)(e.p,{children:"CONFIG_SPI_HOBOT=y # spi-hobot.c\u9a71\u52a8\u5c42\u914d\u7f6e\u9009\u9879"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/02_linux_development/driver_development/image-20220322212038265.png",alt:"image-20220322212038265"})}),"\n",(0,i.jsx)(e.h3,{id:"dts\u8bbe\u5907\u8282\u70b9\u914d\u7f6e",children:"DTS\u8bbe\u5907\u8282\u70b9\u914d\u7f6e"}),"\n",(0,i.jsx)(e.p,{children:"\u5728\u4e0b\u8ff0\u6587\u4ef6\u4e2d\u6dfb\u52a0\u76f8\u5e94\u7684\u8bbe\u5907\u8282\u70b9\uff0c\u5e76\u5bf9\u5185\u6838\u8fdb\u884c\u7f16\u8bd1\u3002\n\u6587\u4ef6\u8def\u5f84\u4e3a\uff1aarch/arm64/boot/dts/hobot/hobot-xj3.dtsi"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:'spi0: spi@0xA5004000 {\n    compatible = "hobot,hobot-spi";\n    reg = <0 0xA5004000 0 0x1000>;\n    clocks = <&spi0_mclk>;\n    clock-names = "spi_mclk";\n    interrupt-parent = <&gic>;\n    interrupts = <0 33 4>;\n    resets = <&rst 0x50 4>;\n    reset-names = "spi0";\n    pinctrl-names = "default";\n    pinctrl-0 = <&spi0_func>;\n    status = "disabled";\n    #address-cells = <1>;\n    #size-cells = <0>;\n};\n'})}),"\n",(0,i.jsx)(e.p,{children:"\u6587\u4ef6\u8def\u5f84\uff1aarch/arm64/boot/dts/hobot/hobot-x3-sdb.dts"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:'/* \u914d\u7f6e\u4e3amaster */\n&spi0 {\n    status = "okay";\n    spidev@0x00 {\n        compatible = "rohm,dh2228fv";\n        spi-max-frequency = <20000000>;\n        reg = <0>;\n    };\n};\n/* \u914d\u7f6e\u4e3aslave */\n&spi2 {\n    status = "okay";\n    slave = <1>;\n    slave@0x00 {\n        compatible = "rohm,dh2228fv";\n        spi-max-frequency = <20000000>;\n        reg = <0>;\n    };\n};\n'})}),"\n",(0,i.jsx)(e.p,{children:"\u4ee5spi0\u548cspi2\u914d\u7f6e\u4e3a\u4f8b"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"hobot-xj3.dtsi\u4e2d\u7684\u8282\u70b9\u4e3a\u516c\u7528\u7684\u8282\u70b9\u57fa\u672c\u4e0d\u7528\u4fee\u6539\uff0c\u9488\u5bf9\u4e0d\u540c\u7684\u786c\u4ef6\uff0c\u4f1a\u5728\u5bf9\u5e94\u7684dts\u4e2d\u8fdb\u884c\u4fee\u6539"}),"\n",(0,i.jsx)(e.li,{children:"spi0\u914d\u7f6e\u4e3aspi master\uff0cspi2\u914d\u7f6e\u4e3aspi slave\uff0c\u5176\u4e2dspi2\u4e2d isslave = <1>\n\u5c5e\u6027\u8868\u793a\u8be5spi\u914d\u7f6e\u4e3aslave"}),"\n",(0,i.jsx)(e.li,{children:"\u4e24\u4e2a\u8282\u70b9\u4e2d\u7684spidev@0x00\u3001slave@0x00\u8282\u70b9\u4f1a\u5728spidev.c\u4e2d\u88ab\u8bc6\u522b\u6210\u4e3a/dev/spidev0.0\u548c/dev/spidev2.0\u8bbe\u5907\u8282\u70b9\uff0c\u4f9b\u7528\u6237\u7a7a\u95f4\u64cd\u4f5c"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"spi\u9a71\u52a8",children:"SPI\u9a71\u52a8"}),"\n",(0,i.jsx)(e.p,{children:"\u9a71\u52a8\u4f4d\u4e8e\uff1adrivers/spi/spi-hobot.c"}),"\n",(0,i.jsx)(e.h3,{id:"spi-masterslave\u914d\u7f6e",children:"SPI master/slave\u914d\u7f6e"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:'static int hb_spi_probe(struct platform_device *pdev)\n{\n    ...\n    /* master or slave mode select */\n    isslave = of_property_read_bool(pdev->dev.of_node, "slave");\n    if (isslave == MASTER_MODE) {\n        ctlr = spi_alloc_master(&pdev->dev, sizeof(*hbspi));\n        if (!ctlr) {\n            dev_err(&pdev->dev, "failed to alloc spi master\\n");\n            return -ENOMEM;\n        }\n    } else if (isslave == SLAVE_MODE) {\n        ctlr = spi_alloc_slave(&pdev->dev, sizeof(*hbspi));\n        if (!ctlr) {\n            dev_err(&pdev->dev, "failed to alloc spi slave, try master\\n");\n            return -ENOMEM;\n        }\n    }\n    ...\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"spi\u6ce8\u518c",children:"SPI\u6ce8\u518c"}),"\n",(0,i.jsx)(e.p,{children:"\u5411\u5185\u6838\u6ce8\u518cSPI\u63a7\u5236\u5668"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:'static int hb_spi_probe(struct platform_device *pdev)\n{\n    ...\n    if (isslave == MASTER_MODE) {\n        hbspi->isslave = MASTER_MODE;\n        snprintf(ctrl_mode, sizeof(ctrl_mode), "%s", "master");\n        ctlr->bus_num = pdev->id;\n        // ctlr->num_chipselect = HB_SPI_MAX_CS;\n        ctlr->mode_bits = SPI_CPOL | SPI_CPHA | SPI_LSB_FIRST | SPI_CS_HIGH |\n            SPI_NO_CS;\n        ctlr->setup = hb_spi_setup;\n        ctlr->prepare_transfer_hardware = hb_spi_prepare_xfer_hardware;\n        ctlr->transfer_one = hb_spi_transfer_one;\n        ctlr->unprepare_transfer_hardware = hb_spi_unprepare_xfer_hardware;\n        ctlr->set_cs = hb_spi_chipselect;\n        ctlr->dev.of_node = pdev->dev.of_node;\n    } else if (isslave == SLAVE_MODE) {\n        hbspi->isslave = SLAVE_MODE;\n        snprintf(ctrl_mode, sizeof(ctrl_mode), "%s", "slave");\n        ctlr->mode_bits = SPI_CPOL | SPI_CPHA | SPI_LSB_FIRST;\n        ctlr->setup = hb_spi_slave_setup;\n        ctlr->prepare_message = hb_spi_slave_prepare_message;\n        ctlr->transfer_one = hb_spi_slave_transfer_one;\n        ctlr->slave_abort = hb_spi_slave_abort;\n    }\n    /* register spi controller */\n        ret = devm_spi_register_controller(&pdev->dev, ctlr);\n    if (ret) {\n        dev_err(&pdev->dev, "failed to register %s controller(%d)\\n",\n                ctrl_mode, ret);\n        goto clk_dis_mclk;\n    }\n    ...\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"\u786c\u4ef6\u521d\u59cb\u5316",children:"\u786c\u4ef6\u521d\u59cb\u5316"}),"\n",(0,i.jsx)(e.p,{children:"\u786c\u4ef6\u521d\u59cb\u5316\u51fd\u6570\u5982\u4e0b\uff0c\u5bc4\u5b58\u5668\u542b\u4e49\u53ef\u901a\u8fc7\u4e0eD-Robotics \u76f8\u5173\u786e\u8ba4"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:'/* spi hw init */\nstatic void hb_spi_init_hw(struct hb_spi *hbspi)\n{\n    u32 val = 0;\n    /* First, should reset the whole controller */\n    hb_spi_reset(hbspi);\n    hb_spi_en_ctrl(hbspi, HB_SPI_OP_CORE_DIS, HB_SPI_OP_NONE,\n            HB_SPI_OP_NONE);\n    hb_spi_wr(hbspi, HB_SPI_INTSETMASK_REG, HB_SPI_INT_ALL);\n    /* clear all interrupt pending */\n    hb_spi_wr(hbspi, HB_SPI_SRCPND_REG, HB_SPI_INT_ALL);\n    /* init rfto */\n    hb_spi_wr(hbspi, HB_SPI_RFTO_REG, 0x27F);\n    /* no instruction */\n    hb_spi_wr(hbspi, HB_SPI_INST_REG, 0x0);\n    hb_spi_wr(hbspi, HB_SPI_INST_MASK_REG, 0xFFFFFFFF);\n    /* spi master mode */\n    val = hb_spi_rd(hbspi, HB_SPI_CTRL_REG);\n    if (hbspi->isslave == SLAVE_MODE)\n        val |= HB_SPI_SLAVE_MODE;\n    else\n        val &= (~HB_SPI_SLAVE_MODE);\n    if (hbspi->isslave == MASTER_MODE)\n        val &= (~HB_SPI_SAMP_SEL);\n    hb_spi_wr(hbspi, HB_SPI_CTRL_REG, val);\n    if (debug)\n        dev_err(hbspi->dev, "%s CTRL=%08X\\n",\n                __func__, hb_spi_rd(hbspi, HB_SPI_CTRL_REG));\n    hb_spi_config(hbspi);\n    hb_spi_en_ctrl(hbspi, HB_SPI_OP_CORE_EN, 0, 0);\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"\u8c03\u8bd5\u53c2\u6570",children:"\u8c03\u8bd5\u53c2\u6570"}),"\n",(0,i.jsx)(e.p,{children:"\u4e0b\u5217\u4e3aspi\u9a71\u52a8\u4e2d\u8f93\u51fa\u7684\u8c03\u8bd5\u53c2\u6570\uff1a"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:'static int debug;\nstatic int slave_tout = 2000;\nstatic int master_tout = 1000;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, "spi: 0 close debug, other open debug");\nmodule_param(slave_tout, int, 0644);\nMODULE_PARM_DESC(slave_tout, "spi: slave timeout(sec), default 10 s");\nmodule_param(master_tout, int, 0644);\nMODULE_PARM_DESC(master_tout, "spi: master timeout(sec), default 2 s");\n'})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"debug\u7b49\u7ea7\u53ef\u4ee5\u8bbe\u7f6e\u4e3a0\uff0c1\uff0c2\uff0c\u9ed8\u8ba4\u503c\u4e3a0"}),"\n",(0,i.jsx)(e.li,{children:"slave\u8d85\u65f6\u65f6\u95f4\u9ed8\u8ba4\u662f2s\uff0c\u6709\u6548\u6700\u5927\u503c\u662f100s"}),"\n",(0,i.jsx)(e.li,{children:"master\u8d85\u65f6\u65f6\u95f4\u9ed8\u8ba4\u662f1s\uff0c\u6709\u6548\u6700\u5927\u503c\u662f10s"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"\u5728\u5185\u6838\u547d\u4ee4\u884c\u5185\u4f7f\u7528sysfs\u7684\u4fee\u6539\u65b9\u6cd5\u5982\u4e0b\uff0csysfs\u5185\u5355\u4f4d\u5747\u4e3a\u6beb\u79d2\u3002\n\u627e\u5230\u53ef\u7528\u53c2\u6570\uff1a\u5982\u4e0b\uff0c\u5305\u542b3\u4e2a\u53c2\u6570"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"ls /sys/module/spi_hobot/parameters/\n"})}),"\n",(0,i.jsx)(e.p,{children:"\u4ee5\u4e0b\u6253\u5370\u5e94\u51fa\u73b0"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"root@x3dvbj3-hynix2G-2666:~# ls /sys/module/spi_hobot/parameters/\ndebug master_tout slave_tout\n"})}),"\n",(0,i.jsx)(e.p,{children:"\u83b7\u53d6\u5f53\u524ddebug\u53c2\u6570\u7684\u503c\uff1a\u9ed8\u8ba4\u503c\u4e3a0\uff0c\u5373\u4e0d\u5f00\u542fdebug"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"cat /sys/module/spi_hobot/parameters/debug\n"})}),"\n",(0,i.jsx)(e.p,{children:"\u4ee5\u4e0b\u6253\u5370\u5e94\u51fa\u73b0"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"root@x3dvbj3-hynix2G-2666:~# cat /sys/module/spi_hobot/parameters/debug\n0\n"})}),"\n",(0,i.jsx)(e.p,{children:"\u8bbe\u7f6edebug\u53c2\u6570\u503c\u4e3a1\uff0c\u5e76\u518d\u6b21\u786e\u8ba4\u8bbe\u7f6e\u6210\u529f\uff1a"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"echo 1 > /sys/module/spi_hobot/parameters/debug\ncat /sys/module/spi_hobot/parameters/debug\n"})}),"\n",(0,i.jsx)(e.p,{children:"\u4ee5\u4e0b\u6253\u5370\u5e94\u51fa\u73b0\uff1a"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"root@x3dvbj3-hynix2G-2666:~# echo 1 > /sys/module/spi_hobot/parameters/debug\nroot@x3dvbj3-hynix2G-2666:~# cat /sys/module/spi_hobot/parameters/debug\n1\n"})}),"\n",(0,i.jsx)(e.p,{children:"\u83b7\u53d6\u5f53\u524dmaster_tout\u53c2\u6570\uff0c\u5373\u4f5c\u4e3amaster\u8d85\u65f6\u65f6\u95f4\u7684\u503c\uff1a\u9ed8\u8ba4\u503c\u4e3a2s"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"cat /sys/module/spi_hobot/parameters/master_tout\n"})}),"\n",(0,i.jsx)(e.p,{children:"\u4ee5\u4e0b\u6253\u5370\u5e94\u51fa\u73b0\uff1a"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"root@x3dvbj3-hynix2G-2666:~# cat /sys/module/spi_hobot/parameters/master_tout\n1000\n"})}),"\n",(0,i.jsx)(e.p,{children:"\u83b7\u53d6\u5f53\u524dslave_tout\u53c2\u6570\uff0c\u5373\u4f5c\u4e3aslave\u8d85\u65f6\u65f6\u95f4\u7684\u503c\uff1a\u9ed8\u8ba4\u503c\u4e3a1s"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"cat /sys/module/spi_hobot/parameters/slave_tout\n"})}),"\n",(0,i.jsx)(e.p,{children:"\u4ee5\u4e0b\u6253\u5370\u5e94\u51fa\u73b0\uff1a"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"root@x3dvbj3-hynix2G-2666:~# cat /sys/module/spi_hobot/parameters/slave_tout\n2000\n"})}),"\n",(0,i.jsx)(e.h2,{id:"spi\u6d4b\u8bd5",children:"SPI\u6d4b\u8bd5"}),"\n",(0,i.jsx)(e.h3,{id:"\u786c\u4ef6\u56de\u73af\u6d4b\u8bd5",children:"\u786c\u4ef6\u56de\u73af\u6d4b\u8bd5"}),"\n",(0,i.jsx)(e.p,{children:"\u5185\u6838dts\u4f7f\u80fdspi0\u4e3amaster\u6a21\u5f0f\uff1a"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:'/* \u914d\u7f6e\u4e3amaster */\n&spi0 {\n    status = "okay";\n    spidev@0x00 {\n        compatible = "rohm,dh2228fv";\n        spi-max-frequency = <20000000>;\n        reg = <0>;\n    };\n};\n'})}),"\n",(0,i.jsx)(e.p,{children:"\u53ef\u4ee5\u89c2\u5bdf\u5230spidev0.0\u8bbe\u5907\u8282\u70b9"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"# ls /dev/spidev0.0 \n/dev/spidev0.0\n"})}),"\n",(0,i.jsx)(e.p,{children:"\u4f7f\u7528\u8fde\u63a5\u5668\u628aspi\u7684MOSI \u548c MISO \u4e24\u4e2a\u7ba1\u811a\u8fde\u63a5\u8d77\u6765"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/02_linux_development/driver_development/image-20220322222747547.png",alt:"image-20220322222747547"})}),"\n",(0,i.jsx)(e.h3,{id:"\u6d4b\u8bd5\u4ee3\u7801",children:"\u6d4b\u8bd5\u4ee3\u7801"}),"\n",(0,i.jsx)(e.p,{children:"\u7f16\u8bd1spidev_tc.c \u4ee3\u7801\uff0c\u5177\u4f53\u4ee3\u7801\u5982\u9644\u5f55A"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"/opt/gcc-ubuntu-9.3.0-2020.03-x86_64-aarch64-linux-gnu/bin/aarch64-linux-gnu-gcc -o spidev_tc spidev_tc.c -lpthread\n"})}),"\n",(0,i.jsx)(e.p,{children:"\u56de\u73af\u6d4b\u8bd5\u547d\u4ee4\uff1a\u6253\u5f00/dev/spidev0.0\uff0c\u8bbe\u7f6e12MHz\u901f\u7387\uff0c\u8bfb\u5199\u540c\u65f6\u8fdb\u884c\uff0c\u6bcf\u6b21\u8bfb\u51991000\u4e2a\u5b57\u8282\uff0c\u6d4b\u8bd550\u8f6e"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"# ./spidev_tc -D /dev/spidev0.0 -s 12000000 -m 3 -e 1000 -t 50\nspi mode: 0x0\nbits per word: 8\nmax speed: 12000000 Hz (12000 KHz)\nuserspace spi read and write test, len=1000 times=50\ntest: OK, times=0\ntest: OK, times=1\n...\ntest: OK, times=49\n"})}),"\n",(0,i.jsx)(e.p,{children:"spidev_tc \u547d\u4ee4\u662f\u6d4b\u8bd5spi\u7684\u5de5\u5177\u96c6\u547d\u4ee4\uff0c\u53ef\u4ee5\u9605\u8bfb\u5b83\u7684\u5e2e\u52a9\u4fe1\u606f\u83b7\u53d6\u66f4\u591a\u4f7f\u7528\u65b9\u6cd5\u3002"}),"\n",(0,i.jsx)(e.h2,{id:"\u9644\u5f55",children:"\u9644\u5f55"}),"\n",(0,i.jsx)(e.h3,{id:"spidev_tcc\u6d4b\u8bd5\u4ee3\u7801",children:"spidev_tc.c\u6d4b\u8bd5\u4ee3\u7801"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:'/*\n * SPI testing utility (using spidev driver)\n *\n * Copyright (c) 2007  MontaVista Software, Inc.\n * Copyright (c) 2007  Anton Vorontsov <avorontsov@ru.mvista.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License.\n *\n * Cross-compile with cross-gcc -I/path/to/cross-kernel/include\n */\n\n#include <stdint.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <time.h>\n#include <sys/ioctl.h>\n#include <linux/ioctl.h>\n#include <sys/stat.h>\n#include <linux/types.h>\n#include <linux/spi/spidev.h>\n\n#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))\n\nstatic void pabort(const char *s)\n{\n    perror(s);\n    abort();\n}\n\nstatic const char *device = "/dev/spidev0.0";\nstatic uint32_t mode;\nstatic uint8_t bits = 8;\nstatic char *input_file;\nstatic char *output_file;\nstatic uint32_t speed = 500000;\nstatic uint16_t delay;\nstatic int verbose;\nstatic int transfer_size;\nstatic int iterations;\nstatic int interval = 5; /* interval in seconds for showing transfer rate */\nstatic int rw_mode = 0; //1: read, 2: write, 3: write and read\nstatic int rw_len = 4;\nstatic int rw_times = 5;\n\nuint8_t default_tx[] = {\n    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n    0x40, 0x00, 0x00, 0x00, 0x00, 0x95,\n    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n    0xF0, 0x0D,\n};\n\nuint8_t default_rx[ARRAY_SIZE(default_tx)] = {0, };\nchar *input_tx;\n\nstatic void hex_dump(const void *src, size_t length, size_t line_size,\n        char *prefix)\n{\n    int i = 0;\n    const unsigned char *address = src;\n    const unsigned char *line = address;\n    unsigned char c;\n\n    printf("%s | ", prefix);\n    while (length-- > 0) {\n        printf("%02X ", *address++);\n        if (!(++i % line_size) || (length == 0 && i % line_size)) {\n            if (length == 0) {\n                while (i++ % line_size)\n                    printf("__ ");\n            }\n            printf(" | ");  /* right close */\n            while (line < address) {\n                c = *line++;\n                printf("%c", (c < 33 || c == 255) ? 0x2E : c);\n            }\n            printf("\\n");\n            if (length > 0)\n                printf("%s | ", prefix);\n        }\n    }\n}\n\nstatic void hex_dump2(const void *src, size_t length, size_t line_size,\n        char *prefix)\n{\n    int i = 0;\n    const unsigned char *address = src;\n    const unsigned char *line = address;\n    unsigned char c;\n\n    printf("%s | ", prefix);\n    while (length-- > 0) {\n        printf("%02X ", *address++);\n        if (!(++i % line_size) || (length == 0 && i % line_size)) {\n            if (length == 0) {\n                while (i++ % line_size)\n                    printf("__ ");\n            }\n            printf("\\n");\n            if (length > 0)\n                printf("%s | ", prefix);\n        }\n    }\n    printf("\\n");\n}\n\n/*\n *  Unescape - process hexadecimal escape character\n *      converts shell input "\\x23" -> 0x23\n */\nstatic int unescape(char *_dst, char *_src, size_t len)\n{\n    int ret = 0;\n    int match;\n    char *src = _src;\n    char *dst = _dst;\n    unsigned int ch;\n\n    while (*src) {\n        if (*src == \'\\\\\' && *(src+1) == \'x\') {\n            match = sscanf(src + 2, "%2x", &ch);\n            if (!match)\n                pabort("malformed input string");\n\n            src += 4;\n            *dst++ = (unsigned char)ch;\n        } else {\n            *dst++ = *src++;\n        }\n        ret++;\n    }\n    return ret;\n}\n\nstatic void transfer(int fd, uint8_t const *tx, uint8_t const *rx, size_t len)\n{\n    int ret;\n    int out_fd;\n    struct spi_ioc_transfer tr = {\n        .tx_buf = (unsigned long)tx,\n        .rx_buf = (unsigned long)rx,\n        .len = len,\n        .delay_usecs = delay,\n        .speed_hz = speed,\n        .bits_per_word = bits,\n    };\n\n    if (mode & SPI_TX_QUAD)\n        tr.tx_nbits = 4;\n    else if (mode & SPI_TX_DUAL)\n        tr.tx_nbits = 2;\n    if (mode & SPI_RX_QUAD)\n        tr.rx_nbits = 4;\n    else if (mode & SPI_RX_DUAL)\n        tr.rx_nbits = 2;\n    if (!(mode & SPI_LOOP)) {\n        if (mode & (SPI_TX_QUAD | SPI_TX_DUAL))\n            tr.rx_buf = 0;\n        else if (mode & (SPI_RX_QUAD | SPI_RX_DUAL))\n            tr.tx_buf = 0;\n    }\n\n    ret = ioctl(fd, SPI_IOC_MESSAGE(1), &tr);\n    if (ret < 1)\n        pabort("can\'t send spi message");\n\n    if (verbose)\n        hex_dump(tx, len, 32, "TX");\n\n    if (output_file) {\n        out_fd = open(output_file, O_WRONLY | O_CREAT | O_TRUNC, 0666);\n        if (out_fd < 0)\n            pabort("could not open output file");\n\n        ret = write(out_fd, rx, len);\n        if (ret != len)\n            pabort("not all bytes written to output file");\n\n        close(out_fd);\n    }\n\n    if (verbose)\n        hex_dump(rx, len, 32, "RX");\n}\n\nstatic void transfer2(int fd, uint8_t const *tx, uint8_t const *rx, size_t len)\n{\n    int ret;\n    int out_fd;\n    struct spi_ioc_transfer tr = {\n        .tx_buf = (unsigned long)tx,\n        .rx_buf = (unsigned long)rx,\n        .len = len,\n        .delay_usecs = delay,\n        .speed_hz = speed,\n        .bits_per_word = bits,\n    };\n\n    if (mode & SPI_TX_QUAD)\n        tr.tx_nbits = 4;\n    else if (mode & SPI_TX_DUAL)\n        tr.tx_nbits = 2;\n    if (mode & SPI_RX_QUAD)\n        tr.rx_nbits = 4;\n    else if (mode & SPI_RX_DUAL)\n        tr.rx_nbits = 2;\n    if (!(mode & SPI_LOOP)) {\n        if (mode & (SPI_TX_QUAD | SPI_TX_DUAL))\n            tr.rx_buf = 0;\n        else if (mode & (SPI_RX_QUAD | SPI_RX_DUAL))\n            tr.tx_buf = 0;\n    }\n\n    if (verbose && rw_mode >> 1)\n        hex_dump2(tx, len, 32, "TX");\n\n    ret = ioctl(fd, SPI_IOC_MESSAGE(1), &tr);\n    if (ret < 1) {\n        //pabort("can\'t send spi message");\n        printf("can\'t send spi message");\n    } else {\n        if (output_file) {\n            out_fd = open(output_file, O_WRONLY | O_CREAT | O_TRUNC, 0666);\n            if (out_fd < 0)\n                pabort("could not open output file");\n\n            ret = write(out_fd, rx, len);\n            if (ret != len)\n                pabort("not all bytes written to output file");\n\n            close(out_fd);\n        }\n\n        if (verbose && rw_mode&0x01)\n            hex_dump2(rx, len, 32, "RX");\n    }\n\n}\n\nstatic void print_usage(const char *prog)\n{\n    printf("Usage: %s [-DsbdlHOLC3vpNR24SImet]\\n", prog);\n    puts("  -D --device   device to use (default /dev/spidev1.1)\\n"\n            "  -s --speed    max speed (Hz)\\n"\n            "  -d --delay    delay (usec)\\n"\n            "  -b --bpw      bits per word\\n"\n            "  -i --input    input data from a file (e.g. \\"test.bin\\")\\n"\n            "  -o --output   output data to a file (e.g. \\"results.bin\\")\\n"\n            "  -l --loop     loopback\\n"\n            "  -H --cpha     clock phase\\n"\n            "  -O --cpol     clock polarity\\n"\n            "  -L --lsb      least significant bit first\\n"\n            "  -C --cs-high  chip select active high\\n"\n            "  -3 --3wire    SI/SO signals shared\\n"\n            "  -v --verbose  Verbose (show tx buffer)\\n"\n            "  -p            Send data (e.g. \\"1234\\\\xde\\\\xad\\")\\n"\n            "  -N --no-cs    no chip select\\n"\n            "  -R --ready    slave pulls low to pause\\n"\n            "  -2 --dual     dual transfer\\n"\n            "  -4 --quad     quad transfer\\n"\n            "  -S --size     transfer size\\n"\n            "  -I --iter     iterations\\n"\n            "  -m --rw-mode  1 read, 2 write, 3 write and read\\n"\n            "  -e --rw-len   read or write len\\n"\n            "  -t --rw-times read or write times\\n");\n    exit(1);\n}\n\nstatic void parse_opts(int argc, char *argv[])\n{\n    while (1) {\n        static const struct option lopts[] = {\n            { "device",  1, 0, \'D\' },\n            { "speed",   1, 0, \'s\' },\n            { "delay",   1, 0, \'d\' },\n            { "bpw",     1, 0, \'b\' },\n            { "input",   1, 0, \'i\' },\n            { "output",  1, 0, \'o\' },\n            { "loop",    0, 0, \'l\' },\n            { "cpha",    0, 0, \'H\' },\n            { "cpol",    0, 0, \'O\' },\n            { "lsb",     0, 0, \'L\' },\n            { "cs-high", 0, 0, \'C\' },\n            { "3wire",   0, 0, \'3\' },\n            { "no-cs",   0, 0, \'N\' },\n            { "ready",   0, 0, \'R\' },\n            { "dual",    0, 0, \'2\' },\n            { "verbose", 0, 0, \'v\' },\n            { "quad",    0, 0, \'4\' },\n            { "size",    1, 0, \'S\' },\n            { "iter",    1, 0, \'I\' },\n            { "rw-mode",    1, 0, \'m\' },\n            { "rw-len",    1, 0, \'e\' },\n            { "rw-times",    1, 0, \'t\' },\n            { NULL, 0, 0, 0 },\n        };\n        int c;\n\n        c = getopt_long(argc, argv, "D:s:d:b:i:o:lHOLC3NR24p:vS:I:m:e:t:",\n                lopts, NULL);\n        //printf("optind: %d\\n", optind);\n        //printf("optarg: %s\\n", optarg);\n        //printf("option: %c\\n", c);\n\n        if (c == -1)\n            break;\n\n        switch (c) {\n        case \'D\':\n            device = optarg;\n            break;\n        case \'s\':\n            speed = atoi(optarg);\n            break;\n        case \'d\':\n            delay = atoi(optarg);\n            break;\n        case \'b\':\n            bits = atoi(optarg);\n            break;\n        case \'i\':\n            input_file = optarg;\n            break;\n        case \'o\':\n            output_file = optarg;\n            break;\n        case \'l\':\n            mode |= SPI_LOOP;\n            break;\n        case \'H\':\n            mode |= SPI_CPHA;\n            break;\n        case \'O\':\n            mode |= SPI_CPOL;\n            break;\n        case \'L\':\n            mode |= SPI_LSB_FIRST;\n            break;\n        case \'C\':\n            mode |= SPI_CS_HIGH;\n            break;\n        case \'3\':\n            mode |= SPI_3WIRE;\n            break;\n        case \'N\':\n            mode |= SPI_NO_CS;\n            break;\n        case \'v\':\n            verbose = 1;\n            break;\n        case \'R\':\n            mode |= SPI_READY;\n            break;\n        case \'p\':\n            input_tx = optarg;\n            break;\n        case \'2\':\n            mode |= SPI_TX_DUAL;\n            break;\n        case \'4\':\n            mode |= SPI_TX_QUAD;\n            break;\n        case \'S\':\n            transfer_size = atoi(optarg);\n            break;\n        case \'I\':\n            iterations = atoi(optarg);\n            break;\n        case \'m\':\n            rw_mode = atoi(optarg);\n            break;\n        case \'e\':\n            rw_len = atoi(optarg);\n            break;\n        case \'t\':\n            rw_times = atoi(optarg);\n            break;\n        default:\n            print_usage(argv[0]);\n            break;\n        }\n    }\n    if (mode & SPI_LOOP) {\n        if (mode & SPI_TX_DUAL)\n            mode |= SPI_RX_DUAL;\n        if (mode & SPI_TX_QUAD)\n            mode |= SPI_RX_QUAD;\n    }\n}\n\nstatic void transfer_escaped_string(int fd, char *str)\n{\n    size_t size = strlen(str);\n    uint8_t *tx;\n    uint8_t *rx;\n\n    tx = malloc(size);\n    if (!tx)\n        pabort("can\'t allocate tx buffer");\n\n    rx = malloc(size);\n    if (!rx)\n        pabort("can\'t allocate rx buffer");\n\n    size = unescape((char *)tx, str, size);\n    printf("size: %d\\n", size);\n    transfer(fd, tx, rx, size);\n    free(rx);\n    free(tx);\n}\n\nstatic void transfer_file(int fd, char *filename)\n{\n    ssize_t bytes;\n    struct stat sb;\n    int tx_fd;\n    uint8_t *tx;\n    uint8_t *rx;\n\n    if (stat(filename, &sb) == -1)\n        pabort("can\'t stat input file");\n\n    tx_fd = open(filename, O_RDONLY);\n    if (tx_fd < 0)\n        pabort("can\'t open input file");\n\n    tx = malloc(sb.st_size);\n    if (!tx)\n        pabort("can\'t allocate tx buffer");\n\n    rx = malloc(sb.st_size);\n    if (!rx)\n        pabort("can\'t allocate rx buffer");\n\n    bytes = read(tx_fd, tx, sb.st_size);\n    if (bytes != sb.st_size)\n        pabort("failed to read input file");\n\n    transfer(fd, tx, rx, sb.st_size);\n    free(rx);\n    free(tx);\n    close(tx_fd);\n}\n\nstatic uint64_t _read_count;\nstatic uint64_t _write_count;\n\nstatic void show_transfer_rate(void)\n{\n    static uint64_t prev_read_count, prev_write_count;\n    double rx_rate, tx_rate;\n\n    rx_rate = ((_read_count - prev_read_count) * 8) / (interval*1000.0);\n    tx_rate = ((_write_count - prev_write_count) * 8) / (interval*1000.0);\n\n    printf("rate: tx %.1fkbps, rx %.1fkbps\\n", rx_rate, tx_rate);\n\n    prev_read_count = _read_count;\n    prev_write_count = _write_count;\n}\n\nstatic void transfer_buf(int fd, int len)\n{\n    uint8_t *tx;\n    uint8_t *rx;\n    int i;\n\n    tx = malloc(len);\n    if (!tx)\n        pabort("can\'t allocate tx buffer");\n    for (i = 0; i < len; i++)\n        tx[i] = random();\n\n    rx = malloc(len);\n    if (!rx)\n        pabort("can\'t allocate rx buffer");\n\n    transfer(fd, tx, rx, len);\n\n    _write_count += len;\n    _read_count += len;\n\n    if (mode & SPI_LOOP) {\n        if (memcmp(tx, rx, len)) {\n            fprintf(stderr, "transfer error !\\n");\n            hex_dump(tx, len, 32, "TX");\n            hex_dump(rx, len, 32, "RX");\n            exit(1);\n        }\n    }\n\n    free(rx);\n    free(tx);\n}\n\nstatic void transfer_read_write(int fd)\n{\n    uint8_t *tx;\n    uint8_t *rx;\n    int i, j;\n    int len, times;\n    char str[64] = {0};\n\n    len = rw_len > 0 ? rw_len : 4;\n    times = rw_times > 0 ? rw_times : 4;\n    if (rw_mode == 2)\n        sprintf(str, "write");\n    else if (rw_mode == 3)\n        sprintf(str, "read and write");\n    else {\n        rw_mode = 1;\n        sprintf(str, "read");\n    }\n\n    printf("userspace spi %s test, len=%d times=%d\\n", str, len, times);\n\n    tx = malloc(len + 4);\n    if (!tx)\n        pabort("can\'t allocate tx buffer");\n    rx = malloc(len + 4);\n    if (!rx)\n        pabort("can\'t allocate rx buffer");\n\n    for (j = 0; j < rw_times; j++) {\n        memset(tx, 0 ,len);\n        memset(rx, 0, len);\n\n        if (rw_mode >> 1) {\n            for (i = 0; i < len; i++)\n                tx[i] = random();\n        } else {\n            for (i = 0; i < len; i++)\n                tx[i] = i << 2;\n        }\n        transfer2(fd, tx, rx, len);\n        printf("test: %s, times=%d\\n", strncmp(tx, rx, len) == 0 ? "OK" : "Failed", j);\n        //sleep(2);\n    }\n}\n\nint main(int argc, char *argv[])\n{\n    int ret = 0;\n    int fd;\n\n    parse_opts(argc, argv);\n\n    fd = open(device, O_RDWR);\n    if (fd < 0)\n        pabort("can\'t open device");\n\n    /*\n     * spi mode\n     */\n    ret = ioctl(fd, SPI_IOC_WR_MODE32, &mode);\n    if (ret == -1)\n        pabort("can\'t set spi mode");\n\n    ret = ioctl(fd, SPI_IOC_RD_MODE32, &mode);\n    if (ret == -1)\n        pabort("can\'t get spi mode");\n\n    /*\n     * bits per word\n     */\n    ret = ioctl(fd, SPI_IOC_WR_BITS_PER_WORD, &bits);\n    if (ret == -1)\n        pabort("can\'t set bits per word");\n\n    ret = ioctl(fd, SPI_IOC_RD_BITS_PER_WORD, &bits);\n    if (ret == -1)\n        pabort("can\'t get bits per word");\n\n    /*\n     * max speed hz\n     */\n    ret = ioctl(fd, SPI_IOC_WR_MAX_SPEED_HZ, &speed);\n    if (ret == -1)\n        pabort("can\'t set max speed hz");\n\n    ret = ioctl(fd, SPI_IOC_RD_MAX_SPEED_HZ, &speed);\n    if (ret == -1)\n        pabort("can\'t get max speed hz");\n\n    printf("spi mode: 0x%x\\n", mode);\n    printf("bits per word: %d\\n", bits);\n    printf("max speed: %d Hz (%d KHz)\\n", speed, speed/1000);\n\n    if (input_tx && input_file)\n        pabort("only one of -p and --input may be selected");\n\n    if (input_tx)\n        transfer_escaped_string(fd, input_tx);\n    else if (input_file)\n        transfer_file(fd, input_file);\n    else if (transfer_size) {\n        struct timespec last_stat;\n\n        clock_gettime(CLOCK_MONOTONIC, &last_stat);\n\n        while (iterations-- > 0) {\n            struct timespec current;\n\n            transfer_buf(fd, transfer_size);\n\n            clock_gettime(CLOCK_MONOTONIC, &current);\n            if (current.tv_sec - last_stat.tv_sec > interval) {\n                show_transfer_rate();\n                last_stat = current;\n            }\n        }\n        printf("total: tx %.1fKB, rx %.1fKB\\n",\n                _write_count/1024.0, _read_count/1024.0);\n    } else if (rw_mode) {\n        transfer_read_write(fd);\n    } else\n        transfer(fd, default_tx, default_rx, sizeof(default_tx));\n\n    close(fd);\n\n    return ret;\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"spi\u65f6\u5e8f",children:"SPI\u65f6\u5e8f"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/02_linux_development/driver_development/a91efe6c59515b2b9d38b106a7e066a5.png",alt:""})})]})}function _(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(o,{...n})}):o(n)}}}]);