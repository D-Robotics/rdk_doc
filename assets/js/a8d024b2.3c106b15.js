"use strict";(self.webpackChunkrdk_doc=self.webpackChunkrdk_doc||[]).push([[83030],{28453:(t,e,n)=>{n.d(e,{R:()=>d,x:()=>c});var r=n(96540);const i={},s=r.createContext(i);function d(t){const e=r.useContext(s);return r.useMemo(function(){return"function"==typeof t?t(e):{...e,...t}},[e,t])}function c(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(i):t.components||i:d(t.components),r.createElement(s.Provider,{value:e},t.children)}},42743:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>a,contentTitle:()=>c,default:()=>l,frontMatter:()=>d,metadata:()=>r,toc:()=>_});const r=JSON.parse('{"id":"Advanced_development/linux_development/driver_development_x5/driver_uart_dev","title":"UART\u9a71\u52a8\u8c03\u8bd5\u6307\u5357","description":"X5 \u82af\u7247\u5171\u67098\u8def\u4e32\u53e3\uff1aUART0\u3001UART1\uff0cUART2\uff0cUART3\uff0cUART4\uff0cUART5\uff0cUART6\uff0cUART7","source":"@site/docs/07_Advanced_development/02_linux_development/driver_development_x5/driver_uart_dev.md","sourceDirName":"07_Advanced_development/02_linux_development/driver_development_x5","slug":"/Advanced_development/linux_development/driver_development_x5/driver_uart_dev","permalink":"/rdk_doc/Advanced_development/linux_development/driver_development_x5/driver_uart_dev","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1756805311000,"sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"\u914d\u7f6euboot\u548ckernel\u9009\u9879\u53c2\u6570","permalink":"/rdk_doc/Advanced_development/linux_development/driver_development_x5/uboot_kernel_config"},"next":{"title":"I2C\u8c03\u8bd5\u6307\u5357","permalink":"/rdk_doc/Advanced_development/linux_development/driver_development_x5/driver_i2c_dev"}}');var i=n(74848),s=n(28453);const d={sidebar_position:3},c="UART\u9a71\u52a8\u8c03\u8bd5\u6307\u5357",a={},_=[{value:"\u9a71\u52a8\u4ee3\u7801",id:"\u9a71\u52a8\u4ee3\u7801",level:2},{value:"\u4ee3\u7801\u8def\u5f84",id:"\u4ee3\u7801\u8def\u5f84",level:3},{value:"\u5185\u6838\u914d\u7f6e",id:"\u5185\u6838\u914d\u7f6e",level:3},{value:"DTS\u8bbe\u5907\u8282\u70b9\u914d\u7f6e",id:"dts\u8bbe\u5907\u8282\u70b9\u914d\u7f6e",level:3},{value:"DTS\u914d\u7f6eDMA\u7ed1\u5b9a",id:"dts\u914d\u7f6edma\u7ed1\u5b9a",level:3},{value:"UART\u6d4b\u8bd5",id:"uart_test",level:2},{value:"\u9644\u5f55\uff08\u6d4b\u8bd5\u4ee3\u7801\uff09",id:"\u9644\u5f55\u6d4b\u8bd5\u4ee3\u7801",level:2}];function o(t){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...t.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"uart\u9a71\u52a8\u8c03\u8bd5\u6307\u5357",children:"UART\u9a71\u52a8\u8c03\u8bd5\u6307\u5357"})}),"\n",(0,i.jsx)(e.p,{children:"X5 \u82af\u7247\u5171\u67098\u8def\u4e32\u53e3\uff1aUART0\u3001UART1\uff0cUART2\uff0cUART3\uff0cUART4\uff0cUART5\uff0cUART6\uff0cUART7"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"UART0 \u7528\u4f5c\u8c03\u8bd5\u4e32\u53e3\uff0c\u53ea\u6709 UART1, UART7 \u652f\u6301\u786c\u4ef6\u81ea\u52a8\u6d41\u63a7"}),"\n",(0,i.jsx)(e.li,{children:"\u652f\u6301\u6bd4\u7279\u7387 115.2Kbps\uff0c230.4Kbps\uff0c460.8Kbps\uff0c921.6Kbps\uff0c1.5Mbps\uff0c2Mbps\uff0c4Mbps\u3002"}),"\n",(0,i.jsx)(e.li,{children:"\u652f\u6301\u57fa\u4e8e\u4e2d\u65ad\u6216\u57fa\u4e8e DMA \u7684\u6a21\u5f0f"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"\u9a71\u52a8\u4ee3\u7801",children:"\u9a71\u52a8\u4ee3\u7801"}),"\n",(0,i.jsx)(e.h3,{id:"\u4ee3\u7801\u8def\u5f84",children:"\u4ee3\u7801\u8def\u5f84"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"drivers/tty/serial/8250/8250_dw.c\ndrivers/tty/serial/8250/8250_dwlib.c\ndrivers/tty/serial/8250/8250_dwlib.h\n"})}),"\n",(0,i.jsx)(e.h3,{id:"\u5185\u6838\u914d\u7f6e",children:"\u5185\u6838\u914d\u7f6e"}),"\n",(0,i.jsx)(e.p,{children:"SERIAL_8250_DW"}),"\n",(0,i.jsx)(e.p,{children:"SERIAL_8250_DWLIB"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:"https://rdk-doc.oss-cn-beijing.aliyuncs.com/doc/img/07_Advanced_development/02_linux_development/driver_development_x5/image-20220324112539182.png",alt:"image-20220324112539182"})}),"\n",(0,i.jsx)(e.h3,{id:"dts\u8bbe\u5907\u8282\u70b9\u914d\u7f6e",children:"DTS\u8bbe\u5907\u8282\u70b9\u914d\u7f6e"}),"\n",(0,i.jsxs)(e.p,{children:["X5 UART\u63a7\u5236\u5668\u7684\u8bbe\u5907\u6811\u5b9a\u4e49\u4f4d\u4e8eSDK\u5305\u7684kernel\u6587\u4ef6\u5939\u4e0b\u7684",(0,i.jsx)("font",{color:"red",children:"arch/arm64/boot/dts/hobot/x5.dtsi"}),"\u6587\u4ef6\u5185\u3002"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)("font",{color:"red",children:"\u5907\u6ce8\uff1a"})," x5.dtsi\u4e2d\u7684\u8282\u70b9\u4e3b\u8981\u58f0\u660eSoC\u5171\u6709\u7279\u6027\uff0c\u548c\u5177\u4f53\u7535\u8def\u677f\u65e0\u5173\uff0c\u4e00\u822c\u60c5\u51b5\u4e0b\u4e0d\u7528\u4fee\u6539\u3002"]}),"\n",(0,i.jsx)(e.p,{children:"X5 \u7684UART\u63a7\u5236\u5668\u9ed8\u8ba4\u5173\u95ed\uff0c\u5f53\u9700\u8981\u4f7f\u80fd\u5bf9\u5e94\u7684\u4e32\u53e3\u65f6\uff0c\u53ef\u4ee5\u5230\u5177\u4f53\u7684\u677f\u5b50\u914d\u7f6e\u8bbe\u5907\u6811\u4e2d\u4fee\u6539\u3001\u6dfb\u52a0\u81ea\u5b9a\u4e49\u914d\u7f6e\u3002\n\u4f8b\u5982\u5728 x5-rdk-v1p0.dts \u6587\u4ef6\u5185\u4f7f\u80fd uart0\u30012\u30015\uff1a"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:'/* arch/arm64/boot/dts/hobotx5-rdk-v1p0.dts */\n...\n&uart0 {\n\tstatus = "okay";\n};\n\n&uart2 {\n\tstatus = "okay";\n\tpinctrl-names = "default";\n\tpinctrl-0 = <&pinctrl_uart2>;\n\t...\n};\n\n&uart5 {\n\tstatus = "okay";\n\tpinctrl-names = "default";\n\tpinctrl-0 = <&pinctrl_uart5>;\n};\n...\n'})}),"\n",(0,i.jsx)(e.h3,{id:"dts\u914d\u7f6edma\u7ed1\u5b9a",children:"DTS\u914d\u7f6eDMA\u7ed1\u5b9a"}),"\n",(0,i.jsx)(e.p,{children:"X5\u6240\u6709UART\u5747\u652f\u6301\u4f7f\u7528DMA\u642c\u8fd0\u3002"}),"\n",(0,i.jsx)("font",{color:"red",children:"\u6ce8\u610f\uff1a"}),"\n",(0,i.jsx)(e.p,{children:"UART0(dsp_uart)\u4f5c\u4e3a\u5185\u6838\u7684\u9ed8\u8ba4UART\u8f93\u51fa\uff0cLinux\u7981\u6b62\u4f7f\u7528DMA\u642c\u8fd0;"}),"\n",(0,i.jsx)("font",{color:"red",children:"\u914d\u7f6eUART\u4f7f\u7528DMA\u4f20\u8f93\u540e\uff0c\u4f20\u8f93\u5fc5\u987b16\u5b57\u8282\u5bf9\u9f50\u3002"}),"\n",(0,i.jsx)(e.p,{children:"\u4ee5UART7\u4e3a\u4f8b\uff1a"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:'/* arch/arm64/boot/dts/hobotx5-rdk-v1p0.dts */\n...\n&uart7 {\n\tstatus = "okay";\n\tpinctrl-names = "default";\n\tpinctrl-0 = <&pinctrl_uart7>;\n\tdma-names = "tx", "rx";\n\tdmas = <&axi_dmac 1>, <&axi_dmac 0>;\n}\n'})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)("font",{color:"red",children:"\u6ce8\u610f\uff1a"}),"UART7\u5728EVB\u4e0a\u9ed8\u8ba4\u529f\u80fd\u4e3aGPIO\uff0c\u5982\u679c\u9700\u8981UART7\u7684\u8bdd\uff0c\u9700\u8981\u9996\u5148\u4ece\u201cls_gpio0_porta\u201d\u5185\u5c06UART7\u5bf9\u5e94\u7684PIN\uff08lsio_gpio0_0~lsio_gpio0_3\uff09\u5220\u6389\uff1b"]}),"\n",(0,i.jsx)(e.p,{children:"UART DMA\u63e1\u624b\u5217\u8868\u5982\u4e0b\uff1a"}),"\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"UART"}),(0,i.jsx)(e.th,{children:"RX"}),(0,i.jsx)(e.th,{children:"TX"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"UART1"}),(0,i.jsx)(e.td,{children:"2"}),(0,i.jsx)(e.td,{children:"3"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"UART2"}),(0,i.jsx)(e.td,{children:"4"}),(0,i.jsx)(e.td,{children:"5"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"UART3"}),(0,i.jsx)(e.td,{children:"6"}),(0,i.jsx)(e.td,{children:"7"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"UART4"}),(0,i.jsx)(e.td,{children:"8"}),(0,i.jsx)(e.td,{children:"9"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"UART5"}),(0,i.jsx)(e.td,{children:"35"}),(0,i.jsx)(e.td,{children:"36"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"UART6"}),(0,i.jsx)(e.td,{children:"37"}),(0,i.jsx)(e.td,{children:"38"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"UART7"}),(0,i.jsx)(e.td,{children:"0"}),(0,i.jsx)(e.td,{children:"1"})]})]})]}),"\n",(0,i.jsx)(e.h2,{id:"uart_test",children:"UART\u6d4b\u8bd5"}),"\n",(0,i.jsx)(e.p,{children:"\u786c\u4ef6\u4e0a\u628auart1\u7684TX\u548cRX\u8fdb\u884c\u8fde\u63a5\u3002\u5bf9\u5e9440pin 8\uff0c10 \u7ba1\u811a"}),"\n",(0,i.jsx)(e.p,{children:"\u7f16\u8bd1uart_duplex.c \u4ee3\u7801\uff0c\u5177\u4f53\u4ee3\u7801\u5982\u9644\u5f55A\n\u8bf7\u6ce8\u610f\u4fee\u6539\u4e0b\u5217\u547d\u4ee4\u4e2d\u7684\u4ea4\u53c9\u7f16\u8bd1\u5de5\u5177\u94fe\u8def\u5f84\u3002"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"/opt/arm-gnu-toolchain-11.3.rel1-x86_64-aarch64-none-linux-gnu -o uart_duplex uart_duplex.c  -lpthread\n"})}),"\n",(0,i.jsx)(e.p,{children:"\u56de\u73af\u6d4b\u8bd5\u547d\u4ee4\uff1a\u6253\u5f00/dev/ttyS1\uff0c\u9ed8\u8ba4\u6ce2\u7279\u73874Mbps\uff0c\u9ed8\u8ba4\u6bcf\u8f6e\u6d4b\u8bd51MB\u6570\u636e\uff0c\u6d4b\u8bd5100\u8f6e\uff0c\u8bfb\u5199\u540c\u65f6\u8fdb\u884c\uff0c\u6bcf\u53d1\u3001\u6536512\u5b57\u8282\u505a\u4e00\u8f6e\u6570\u636e\u6821\u9a8c\uff0c\u5b8c\u6574\u4e00\u8f6e\u6d4b\u8bd5\u7ed3\u675f\u540e\uff0c\u5982\u679c\u6ca1\u6709\u51fa\u9519\u5219\u6253\u5370\u6821\u9a8c\u6b63\u786e\u3002"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"# ./uart_duplex -c 100 -d /dev/ttyS1\ntest size:1024 Kbytes, baud:4000000\nStart receive thread\nStart send thread\nStart recv_check thread\nThis is receive test 1 times\nThis is uart send 1 times\nreceive sum:102416 bytes\nreceive sum:205312 bytes\n...\nreceive sum:924164 bytes\nreceive sum:1027076 bytes\nsend 1024Kbytes,time:2700.000000ms, BPS:379259.250000\nThis is receive test 2 times\n### Check the received data is correct ###\n"})}),"\n",(0,i.jsx)(e.p,{children:"uart_duplex\u547d\u4ee4\u662f\u6d4b\u8bd5uart\u7684\uff0c\u53ef\u4ee5\u9605\u8bfb\u5b83\u7684\u5e2e\u52a9\u4fe1\u606f\u83b7\u53d6\u66f4\u591a\u4f7f\u7528\u65b9\u6cd5\u3002"}),"\n",(0,i.jsx)(e.h2,{id:"\u9644\u5f55\u6d4b\u8bd5\u4ee3\u7801",children:"\u9644\u5f55\uff08\u6d4b\u8bd5\u4ee3\u7801\uff09"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:'#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <termios.h>\n#include <errno.h>\n#include <string.h>\n#include <getopt.h>\n#include <sys/time.h>\n#include <pthread.h>\n#include <semaphore.h>\n#include <stdlib.h>\n\n#define BUFF_SIZE (20 * 1024 * 1024)\npthread_t recv_thread_id;\npthread_t recv_check_thread_id;\npthread_t send_thread_id;\nchar send_buffer[BUFF_SIZE] = {0};\nchar recv_buffer[BUFF_SIZE] = {0};\nstatic uint32_t test_size = 1024;\nstatic uint32_t baud = 4000000;\nstatic uint32_t test_count = 0;\nint g_fd;\nuint64_t recv_total = 0;\nsem_t sem_check;\n\n#define FRAME_LEN 512\n#if 1\nstatic void dump_recv_data(uint32_t sum, uint32_t len)\n{\n\tint ii = 0;\n\tprintf("dump receive data:\\n");\n\tfor (ii = 0; ii < len; ii += 4) {\n\t\tprintf("0x%x: 0x%x, 0x%x, 0x%x, 0x%x\\n", sum + ii,\n\t\t\t\trecv_buffer[sum + ii],\n\t\t\t\trecv_buffer[sum + ii + 1],\n\t\t\t\trecv_buffer[sum + ii + 2],\n\t\t\t\trecv_buffer[sum + ii + 3]);\n\n\t}\n\n}\n\nstatic void dump_send_data(uint32_t sum, uint32_t len)\n{\n\tint ii = 0;\n\tprintf("dump send data:\\n");\n\tfor (ii = 0; ii < len; ii += 4) {\n\t\tprintf("0x%x: 0x%x, 0x%x, 0x%x, 0x%x\\n", sum + ii,\n\t\t\t\tsend_buffer[sum + ii],\n\t\t\t\tsend_buffer[sum + ii + 1],\n\t\t\t\tsend_buffer[sum + ii + 2],\n\t\t\t\tsend_buffer[sum + ii + 3]);\n\n\t}\n\n}\n#endif\n\nstatic void set_baudrate(int fd, int nSpeed)\n{\n\tstruct termios newtio;\n\n\ttcgetattr(fd, &newtio);\n\n\tswitch (nSpeed) {\n\tcase 2400:\n\t\tcfsetispeed(&newtio, B2400);\n\t\tcfsetospeed(&newtio, B2400);\n\t\tbreak;\n\n\tcase 4800:\n\t\tcfsetispeed(&newtio, B4800);\n\t\tcfsetospeed(&newtio, B4800);\n\t\tbreak;\n\n\tcase 9600:\n\t\tcfsetispeed(&newtio, B9600);\n\t\tcfsetospeed(&newtio, B9600);\n\t\tbreak;\n\n\tcase 19200:\n\t\tcfsetispeed(&newtio, B19200);\n\t\tcfsetospeed(&newtio, B19200);\n\t\tbreak;\n\n\tcase 38400:\n\t\tcfsetispeed(&newtio, B38400);\n\t\tcfsetospeed(&newtio, B38400);\n\t\tbreak;\n\n\tcase 57600:\n\t\tcfsetispeed(&newtio, B57600);\n\t\tcfsetospeed(&newtio, B57600);\n\t\tbreak;\n\n\tcase 115200:\n\t\tcfsetispeed(&newtio, B115200);\n\t\tcfsetospeed(&newtio, B115200);\n\t\tbreak;\n\tcase 230400:\n\t\tcfsetispeed(&newtio, B230400);\n\t\tcfsetospeed(&newtio, B230400);\n\t\tbreak;\n\tcase 921600:\n\t\tcfsetispeed(&newtio, B921600);\n\t\tcfsetospeed(&newtio, B921600);\n\t\tbreak;\n\tcase 1000000:\n\t\tcfsetispeed(&newtio, B1000000);\n\t\tcfsetospeed(&newtio, B1000000);\n\t\tbreak;\n\n\tcase 1152000:\n\t\tcfsetispeed(&newtio, B1152000);\n\t\tcfsetospeed(&newtio, B1152000);\n\t\tbreak;\n\tcase 1500000:\n\t\tcfsetispeed(&newtio, B1500000);\n\t\tcfsetospeed(&newtio, B1500000);\n\t\tbreak;\n\tcase 2000000:\n\t\tcfsetispeed(&newtio, B2000000);\n\t\tcfsetospeed(&newtio, B2000000);\n\t\tbreak;\n\tcase 2500000:\n\t\tcfsetispeed(&newtio, B2500000);\n\t\tcfsetospeed(&newtio, B2500000);\n\t\tbreak;\n\tcase 3000000:\n\t\tcfsetispeed(&newtio, B3000000);\n\t\tcfsetospeed(&newtio, B3000000);\n\t\tbreak;\n\tcase 3500000:\n\t\tcfsetispeed(&newtio, B3500000);\n\t\tcfsetospeed(&newtio, B3500000);\n\t\tbreak;\n\n\tcase 4000000:\n\t\tcfsetispeed(&newtio, B4000000);\n\t\tcfsetospeed(&newtio, B4000000);\n\t\tbreak;\n\n\tdefault:\n\t\tprintf("\\tSorry, Unsupported baud rate, use previous baudrate!\\n\\n");\n\t\tbreak;\n\t}\n\ttcsetattr(fd,TCSANOW,&newtio);\n}\n\nstatic void set_termios(int fd)\n{\n\tstruct termios term;\n\n\ttcgetattr(fd, &term);\n\tterm.c_cflag &= ~(CSIZE | CSTOPB | PARENB | INPCK);\n\tterm.c_cflag |= (CS8 | CLOCAL | CREAD);\n\tterm.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG);\n\tterm.c_oflag &= ~(OPOST | ONLCR | OCRNL);\n\tterm.c_iflag &= ~(ICRNL |INLCR | IXON | IXOFF | IXANY);\n\tterm.c_cc[VTIME] = 0;\n\tterm.c_cc[VMIN] = 1;\n\ttcsetattr(fd, TCSAFLUSH, &term);\n}\n\nstatic void *send_test(void *times)\n{\n\t/*send thread*/\n\tstruct timeval start, end;\n\tint32_t i = 0;\n\tuint32_t j = 0;\n\tuint32_t tmp = 0;\n\tuint32_t exe_count = 0;\n\tint32_t ret = 0;\n\tfloat ts = 0;\n\n\tprintf("Start send thread\\n");\n\n\tsleep(1);\n\tif (test_count == 0) {\n\t\ttmp = 10;\n\t} else\n\t\ttmp = test_count;\n\tfor (j = 0; j < tmp; j++) {\n\t\tif (test_count == 0)\n\t\t\tj = 0;\n\t\tsleep(1);\n\t\tprintf("This is uart send %d times\\n", ++exe_count);\n\t\tgettimeofday(&start, NULL);\n\t\tfor (i = 0; i <  test_size * 1024; i = i + FRAME_LEN) {\n\t\t\tret = write(g_fd, &send_buffer[i], FRAME_LEN);\n\t\t\tif (ret < FRAME_LEN) {\n\t\t\t\tprintf("write ttyS2 error\\n");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n#if 1\n\t\tgettimeofday(&end, NULL);\n\t\t//\t\tprintf("start %ld sec, %ld usec, end %ld sec, %ld usec\\n", start.tv_sec, start.tv_usec, end.tv_sec, end.tv_usec);\n\t\tts = ((end.tv_sec * 1000000 + end.tv_usec) - (start.tv_sec * 1000000 + start.tv_usec)) / 1000;\n\t\tprintf("send %dKbytes,time:%fms, BPS:%f\\n", test_size, ts, test_size * 1000 / (ts / 1000));\n#endif\n\t}\n\tclose(g_fd);\n\treturn NULL;\n}\n\nstatic void *recv_test(void *times)\n{\n\tint32_t j = 0;\n\tuint32_t exe_count = 0;\n\tint tmp = 0;\n\tint size = 0;\n\tint sum = 0;\n\tint last_count = 0;\n\tint len = 0;\n\tint len_frame = 0; /*use to get correct frame len*/\n\n\tprintf("Start receive thread\\n");\n\n\tmemset(recv_buffer, 0, sizeof(recv_buffer));\n\n\tif (test_count == 0) {\n\t\ttmp = 10;\n\t} else\n\t\ttmp = test_count;\n\tfor (j = 0; j < tmp; j++) {\n\t\tsum = 0;\n\t\tlast_count = 0;\n\t\tif (test_count == 0)\n\t\t\tj = 0;\n\t\tprintf("This is receive test %d times\\n", ++exe_count);\n\t\t//gettimeofday(&start, NULL);\n\t\tsize = test_size * 1024;\n\t\twhile (size > 0) {\n\t\t\tlen = read(g_fd, &recv_buffer[sum], FRAME_LEN);\n\t\t\tif (len < 0) {\n\t\t\t\tprintf("read error\\n");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\trecv_total += len;\n\t\t\tlen_frame += len;\n\t\t\tif (len_frame >= FRAME_LEN) {\n\t\t\t\tlen_frame -= FRAME_LEN;\n\t\t\t\tsem_post(&sem_check);\n\t\t\t}\n\n#if 0\n\t\t\tret = memcmp(&recv_buffer[sum], &send_buffer[sum], len);\n\t\t\tif (ret != 0) {\n\t\t\t\tprintf("data compare error\\n");\n\t\t\t\treturn NULL;\n\t\t\t}\n#endif\n\t\t\tsum +=len;\n\t\t\tsize -= len;\n\t\t\tif ((sum - last_count) > 100 * 1024) {\n\t\t\t\tprintf("receive sum:%d bytes\\n", sum);\n\t\t\t\tlast_count = sum;\n\t\t\t}\n\t\t}\n#if 0\n\t\tgettimeofday(&end, NULL);\n\t\tprintf("start %ld sec, %ld usec, end %ld sec, %ld usec\\n", start.tv_sec, start.tv_usec, end.tv_sec, end.tv_usec);\n\t\tts = ((end.tv_sec * 1000000 + end.tv_usec) - (start.tv_sec * 1000000 + start.tv_usec)) / 1000;\n\n\t\tprintf("receive %dKbytes,time:%fms, BPS:%f\\n", test_size, ts, test_size * 1000 / (ts / 1000));\n#endif\n\t}\n\tclose(g_fd);\n\treturn NULL;\n}\n\nint32_t error_bit(uint64_t *data1, uint64_t *data2, int32_t len)\n{\n\tuint64_t c=0;\n\tint32_t sum = 0;\n\tint i = 0;\n\tfor(i = 0; i < len / 8; i++) {\n\t\tc = data1[i] ^ data2[i];\n\t\twhile(c!=0) {\n\t\t\tc &= (c - 1);\n\t\t\tsum++;\n\t\t}\n\t}\n\treturn sum;\n}\n\nstatic void *recv_check_test(void *times)\n{\n\tint32_t check_pos = 0;\n\tuint32_t *cur_frame = NULL;\n\tint32_t error_bit_cnt = 0;\n\tprintf("Start recv_check thread\\n");\n\twhile (1) {\n\t\tsem_wait(&sem_check);\n\t\t/*check data*/\n\t\tcur_frame = (uint32_t *)&recv_buffer[check_pos];\n\t\tif (*cur_frame != check_pos / FRAME_LEN) {\n\t\t\tprintf("error: may lost frame, curruent frame is %d, expected frame is %d position: 0x%x\\n",\n\t\t\t\t\t*cur_frame, check_pos / FRAME_LEN, check_pos);\n\t\t\t//dump_recv_data(check_pos, FRAME_LEN);\n\t\t\t//dump_send_data(check_pos, FRAME_LEN);\n\t\t\terror_bit_cnt = 0;\n\t\t\terror_bit_cnt = error_bit((uint64_t *)&recv_buffer[check_pos],\n\t\t\t\t\t(uint64_t *)&send_buffer[check_pos],\n\t\t\t\t\tFRAME_LEN / 8);\n\t\t\tcheck_pos += FRAME_LEN;\n\t\t\tprintf("test total data: 0x%lx, error bit count:%d\\n", recv_total, error_bit_cnt);\n\t\t\tif (check_pos == test_size * 1024) {\n\t\t\t\t//exit(1);\n\t\t\t\tprintf("uart: frame head error\\n");\n\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\terror_bit_cnt = 0;\n\t\terror_bit_cnt = error_bit((uint64_t *)&recv_buffer[check_pos],\n\t\t\t\t(uint64_t *)&send_buffer[check_pos],\n\t\t\t\tFRAME_LEN / 8);\n\t\tif (error_bit_cnt) {\n\t\t\tprintf("test total data: 0x%lx!!!!!!!, error bit count:%d\\n", recv_total, error_bit_cnt);\n\t\t\t//dump_recv_data(check_pos, FRAME_LEN);\n\t\t\t//dump_send_data(check_pos, FRAME_LEN);\n\t\t\tcheck_pos += FRAME_LEN;\n\t\t\tif (check_pos == test_size * 1024) {\n\t\t\t\t//exit(1);\n\t\t\t\tprintf("uart: frame data error\\n");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tmemset(&recv_buffer[check_pos], 0, FRAME_LEN);\n\t\tcheck_pos += FRAME_LEN;\n\t\tif (check_pos == test_size * 1024) {\n\t\t\tcheck_pos = 0;\n\t\t\tprintf("### Check the received data is correct ###\\n");\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic const char short_options[] = "s:u:c:b:d:h";\nstatic const struct option long_options[] = {\n\t{"size", required_argument, NULL, \'s\'},\n\t{"baudrate", required_argument, NULL, \'b\'},\n\t{"count", required_argument, NULL, \'c\'},\n\t{"device", required_argument, NULL, \'d\'},\n\t{"help", no_argument, NULL, \'h\'},\n\t{0, 0, 0, 0}};\nint main(int argc, char *argv[])\n{\n\tint ret = 0;\n\tchar *pDevice = NULL;\n\tint i = 0;\n\tint32_t cmd_parser_ret = 0;\n\tuint32_t *frame_num = NULL;\n\tuint32_t *frame_value = NULL;\n\n\twhile ((cmd_parser_ret = getopt_long(argc, argv, short_options, long_options, NULL)) != -1) {\n\t\tswitch (cmd_parser_ret) {\n\t\tcase \'s\':\n\t\t\ttest_size = atoi(optarg);\n\t\t\tbreak;\n\n\t\tcase \'b\':\n\t\t\tbaud = atoi(optarg);\n\t\t\tbreak;\n\n\t\tcase \'c\':\n\t\t\ttest_count = atoi(optarg);\n\t\t\tbreak;\n\t\tcase \'d\':\n\t\t\tpDevice = optarg;\n\t\t\tbreak;\n\n\t\tcase \'h\':\n\t\t\tprintf("**********UART STRESS TEST HELP INFORMATION*********\\n");\n\t\t\tprintf(">>> -s/--size     [test size,unit--Kbytes,default is 1M, MAX is 20M]\\n");\n\t\t\tprintf(">>> -b/--baudrate  [baud,default is 4M]\\n");\n\t\t\tprintf(">>> -c/--count  [test count,default is forever]\\n");\n\t\t\tprintf(">>> -d/--uart  [uart device, user must set this]\\n");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (baud > 4000000) {\n\t\tprintf("baud is larger than max baud\\n");\n\t\treturn -1;\n\t}\n\tg_fd = open(pDevice, O_RDWR | O_NOCTTY);\n\tif (0 > g_fd) {\n\t\tprintf("open fail\\n");\n\t\treturn -1;\n\t}\n\tset_baudrate(g_fd, baud);\n\tset_termios(g_fd);\n\tprintf("test size:%d Kbytes, baud:%d\\n", test_size, baud);\n\tfor (i = 0; i < test_size * 1024; i+=4) {\n\t\tif (i % FRAME_LEN) {\n\t\t\tframe_value = (uint32_t *)&send_buffer[i];\n\t\t\t*frame_value = rand();\n\t\t}\n\n\t}\n\tfor (i = 0; i < test_size * 1024 / FRAME_LEN; i++) {\n\t\tframe_num = (uint32_t *)&send_buffer[i * FRAME_LEN];\n\t\t*frame_num = i;\n\t\t//        printf("pos:0x%x, value:0x%x\\n", i * FRAME_LEN, *frame_num);\n\t}\n\n\tsem_init(&sem_check, 0, 0);\n\tret = pthread_create(&recv_thread_id,\n\t\t\tNULL,\n\t\t\trecv_test,\n\t\t\tNULL);\n\tif (ret < 0) {\n\t\tprintf("create uart1 test thread failed\\n");\n\t\treturn -1;\n\t}\n\tret = pthread_create(&send_thread_id,\n\t\t\tNULL,\n\t\t\tsend_test,\n\t\t\tNULL);\n\tif (ret < 0) {\n\t\tprintf("create uart2 test thread failed\\n");\n\t\treturn -1;\n\t}\n\tret = pthread_create(&recv_check_thread_id,\n\t\t\tNULL,\n\t\t\trecv_check_test,\n\t\t\tNULL);\n\tif (ret < 0) {\n\t\tprintf("create receive check thread failed\\n");\n\t\treturn -1;\n\t}\n\tpthread_join(recv_thread_id, NULL);\n\tpthread_join(recv_check_thread_id, NULL);\n\tpthread_join(send_thread_id, NULL);\n\treturn 0;\n}\n'})})]})}function l(t={}){const{wrapper:e}={...(0,s.R)(),...t.components};return e?(0,i.jsx)(e,{...t,children:(0,i.jsx)(o,{...t})}):o(t)}}}]);